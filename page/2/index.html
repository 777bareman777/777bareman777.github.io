<!DOCTYPE html>





<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.4.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.4.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.4.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.4.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: 'Copy',
      copy_success: 'Copied',
      copy_failure: 'Copy failed'
    },
    sidebarPadding: 40
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="777bareman777 Blog">
<meta property="og:url" content="http://777bareman777.github.io/page/2/index.html">
<meta property="og:site_name" content="777bareman777 Blog">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="777bareman777 Blog">
  <link rel="canonical" href="http://777bareman777.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>777bareman777 Blog</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">
  <div class="container use-motion">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">777bareman777 Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">켄넬 교육받은 댕댕이</p>
      
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-about">
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>About</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>Tags</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-categories">
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>Categories</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>

  </li>
  </ul>

    

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <div id="posts" class="posts-expand">
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://777bareman777.github.io/2019/09/20/UnderstandPE6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="777bareman777">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="777bareman777 Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/09/20/UnderstandPE6/" class="post-title-link" itemprop="url">PE 구조 이해하기 - IMAGE_SECTION_HEADER 구조</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-09-20 17:00:55" itemprop="dateCreated datePublished" datetime="2019-09-20T17:00:55+09:00">2019-09-20</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-01-17 07:14:51" itemprop="dateModified" datetime="2020-01-17T07:14:51+09:00">2020-01-17</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/PE-file/" itemprop="url" rel="index"><span itemprop="name">PE file</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/PE-file/Windows-Reversing/" itemprop="url" rel="index"><span itemprop="name">Windows Reversing</span></a></span>

                
                
              
            </span>
          

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
        
      
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2019/09/20/UnderstandPE6/#comments" itemprop="discussionUrl"><span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/09/20/UnderstandPE6/" itemprop="commentCount"></span></a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>windows 시스템 실행파일의 구조와 원리 책 내용을 요약 및 정리 하는 포스팅이에요.</p>
<p>섹션들의 정보들의 위치와 크기를 나타내는 <strong>IMAGE_SECTION_HEADER</strong>에 대한 내용을 알아볼 거에요.</p>
<br>

<h2 id="IMAGE-SECTION-HEADER의-시작"><a href="#IMAGE-SECTION-HEADER의-시작" class="headerlink" title="IMAGE_SECTION_HEADER의 시작"></a>IMAGE_SECTION_HEADER의 시작</h2><p>IMAGE_NT_HEADER에 대한 설명이 이제 다 끝났어요. 그 다음으로 이어질 구조체인 IMAGE_SECTION_HEADER에 대한 설명을 시작할게요.</p>
<p>여기에서도 섹션들의 정보들의 위치와 크기등 여러가지를 알려주는 IMAGE_SECTION_HEADER에 대해 알아볼 건데요. 섹션들의 정보들의 위차와 크기를 나타내는 IMAGE_DATA_DIRECTORY 구조체와 어떤 차이가 있는 걸까요?</p>
<p>IMAGE_DATA_DIRECTORY 구조체에 있는 섹션들은 IMAGE_SECTION_HEADER 구조체에 있는 섹션들에게 병합되어 있기 때문에 PE 파일 내에 정보가 없어요! 따라서 IMAGE_DATA_DIRECTORY 구조체에 있는 섹션들의 정보를 확인하고 싶으면, IMAGE_SECTION_HEADER 구조체에 있는 정보들과 조합해서 찾아야 합니다!</p>
<p>자 진짜로 IMAGE_SECTION_HEADER에 대한 설명을 시작할게요!</p>
<p><strong>IMAGE_SECTION_HEADER 구조체는 40바이트로 구성되어 있고요. IMAGE_FILE_HEADER의 NumberOfSections 필드에 있는 섹션의 개수만큼 IMAGE_SECTION_HEADER 가 존재해요.</strong><br>이 구조체도 마찬가지로 “WinNT.h” 헤더 파일에 정의되어 있습니다.</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#defome IMAGE_SECTION_HEADER 8</span></span><br><span class="line"></span><br><span class="line">typedef struct _IMAGE_SECTION_HEADER &#123;</span><br><span class="line">  <span class="keyword">BYTE </span> Name[IMAGE_SIZEOF_SHORT_NAME]<span class="comment">;</span></span><br><span class="line">  union &#123;</span><br><span class="line">    DWORD PhysicalAddress<span class="comment">;</span></span><br><span class="line">    DWORD VirtualSize<span class="comment">;</span></span><br><span class="line">  &#125; Misc<span class="comment">;</span></span><br><span class="line">  DWORD VirtualAddress<span class="comment">;</span></span><br><span class="line">  DWORD SizeOfRawData<span class="comment">;</span></span><br><span class="line">  DWORD PointerToRawData<span class="comment">;</span></span><br><span class="line">  DWORD PointerToRelocations<span class="comment">;</span></span><br><span class="line">  DWORD PointerToLinenumbers<span class="comment">;</span></span><br><span class="line">  WORD  NumberOfRelocations<span class="comment">;</span></span><br><span class="line">  WORD  NumberOfLinenumbers<span class="comment">;</span></span><br><span class="line">  DWORD Characteristics<span class="comment">;</span></span><br><span class="line">&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<br>

<h3 id="첫-번째-멤버-BYTE-Name-IMAGE-SIZEOF-SHORT-NAME"><a href="#첫-번째-멤버-BYTE-Name-IMAGE-SIZEOF-SHORT-NAME" class="headerlink" title="첫 번째 멤버, BYTE Name[IMAGE_SIZEOF_SHORT_NAME]"></a>첫 번째 멤버, BYTE Name[IMAGE_SIZEOF_SHORT_NAME]</h3><p><strong>섹션의 아스키 이름</strong>을 나타내요. IMAGE_SIZEOF_SHORT_NAME은 8바이트로 매크로 상수로 정의되어 있고요. 문자열임에도 불구하고 NULL을 신경쓰지 않아요.<br>그 이유가 섹션 이름을 8바이트 이상으로 지정했을 경우 링커가 알아서 8바이트 이후의 문자열은 잘라 버린 후 값을 채우기 때문이에요.</p>
<br>

<h3 id="두-번째-멤버-DOWRD-PhysicalAddress-or-VirtualSize"><a href="#두-번째-멤버-DOWRD-PhysicalAddress-or-VirtualSize" class="headerlink" title="두 번째 멤버, DOWRD PhysicalAddress or VirtualSize"></a>두 번째 멤버, DOWRD PhysicalAddress or VirtualSize</h3><p>이 필드는 OBJ 파일인 경우와 PE의 경우 의미가 달라져요.</p>
<p><strong>PE의 경우 공용체의 VirtualSize 필드를 사용하여 코드와 데이터의 실제 바이트수</strong>를 담고 있어요. 즉, 파일 바이트 정렬의 배수로 라운드업이 되기 전의 실제 바이트 수를 담고 있어요.<br>이 값에 대한 라운드업된 값은 이 구조체의 SizeOfRawData 필드에 저장되요.</p>
<p>이전까지는 OBJ 파일의 경우 공용체의 PhysicalAddress 필드를 통해 섹션의 물리적인 번지를 지정했지만, 현재에는 OBJ의 경우 이 필드는 0으로 세팅되요. 즉, PhysicalAddress 필드는 더 이상 의미가 없어졌어요.</p>
<p>이렇게 물리적인 번지를 직접 사용하지 않는 이유가 현대에는 보호모드가 보편적으로 사용되기 때문이에요.</p>
<br>

<h3 id="세-번째-멤버-DWORD-VirtualAddress"><a href="#세-번째-멤버-DWORD-VirtualAddress" class="headerlink" title="세 번째 멤버, DWORD VirtualAddress"></a>세 번째 멤버, DWORD VirtualAddress</h3><p><strong>PE에서 해당 섹션을 매핑시켜야 할 가상 주소 공간 상의 RVA</strong>를 가지고 있어요.<br>즉, <strong>메모리 상에서의 본 섹션의 시작 주소</strong>를 의미하는 거죠.<br>그리고 <strong>SectionAlignment 필드 값의 배수</strong>가 되어야 한다.</p>
<br>

<h3 id="네-번째-멤버-DWORD-SizeOfRawData"><a href="#네-번째-멤버-DWORD-SizeOfRawData" class="headerlink" title="네 번째 멤버, DWORD SizeOfRawData"></a>네 번째 멤버, DWORD SizeOfRawData</h3><p><strong>VirtualSize 필드 값에 대한 파일 정렬(Alignment) 값의 배수로 라운드업된 값</strong>이다.<br>만약 IMAGE_OPTIONAL_HEADER의 FileAlignment 필드의 값이 0x200 이고, VirtualSize 필드 값이 0x35A이면 SizeOfRawData 필드 값은 0x400이 된다.</p>
<p>OBJ 파일의 경우 이 값은 0이다.</p>
<br>

<h3 id="다섯-번째-멤버-DWORD-PointerToRawData"><a href="#다섯-번째-멤버-DWORD-PointerToRawData" class="headerlink" title="다섯 번째 멤버, DWORD PointerToRawData"></a>다섯 번째 멤버, DWORD PointerToRawData</h3><p><strong>해당 섹션의 PE 파일 내에서 시작하는 실제 파일 오프셋 값</strong>이다.<br>이 값 역시 IMAGE_OPTIONAL_HEADER의 <strong>FileAlignmnet 필드 값의 배수</strong>가 되어야 한다.<br>이 필드의 값은 <strong>VirtualAddress 필드의 값과 같을 수도 있고 다를 수도</strong> 있다.</p>
<p>그렇게 하는 이유가 VirtualAddress 필드는 IMAGE_OPTIONAL_HEADER의 SectionAlignment 필드 값의 배수가 되기 때문에 바이트 정렬 문제로 인하여 하드디스크 상의 공간을 낭비될 수 있고, 이때 PointerToRawData 필드에 실제 섹션의 파일 상의 시작 오프셋을 지정하고 오프셋에 섹션 데이터를 기록함으로써 PE 파일의 크기를 줄일 수 있는 거라고 해요.</p>
<p>따라서 VirtualAddress 필드와 PointerToRawData 필드 사이의 관계를 파악하는 것이 중요하다고 해요.<br>VirtualAddress의 값은 RVA이기 때문에 IMAGE_OPTIONAL_HEADER의 ImageBase 필드 값을 더한 결과가 프로그램 로더가 PE 파일을 위하여 프로세스 커널 객체를 생성한 후 가상 주소 공간을 만들고 나서 이 섹션을 해당 주소 공간에 매핑시킬 실제 번지 값이 되요. 그리고 PointerToRawData의 값은 이 섹션이 위치한 PE 파일 내의 파일 선두로 부터의 오프셋이 되고요.</p>
<p>VirtualAddress 필드와 PointerToRawData 필드는 중요한 필드인 거죠!<br>아래의 사진은 책에 첨부되더 있는 VirtualAddress와 PointerToRawData 사이의 관계에 대한 그림입니다.</p>
<img src="/2019/09/20/UnderstandPE6/1.png">

<br>

<h3 id="여섯-번째-멤버-PointerToRelocations"><a href="#여섯-번째-멤버-PointerToRelocations" class="headerlink" title="여섯 번째 멤버, PointerToRelocations"></a>여섯 번째 멤버, PointerToRelocations</h3><p>본 섹션을 위한 <strong>재배치 파일 오프셋</strong>이에요. 이 필드는 OBJ에서만 사용되고 실행 파일에서는 0으로 세트되요. OBJ 파일에서 이 필드가 0이 아닐 경우 IMAGE_RELOCATION 구조체 배열의 시작 주소를 가리켜요.</p>
<br>

<h3 id="일곱-번째-멤버-PointerToLinenumbers"><a href="#일곱-번째-멤버-PointerToLinenumbers" class="headerlink" title="일곱 번째 멤버, PointerToLinenumbers"></a>일곱 번째 멤버, PointerToLinenumbers</h3><p>본 섹션을 위한 <strong>COFF 스타일의 라인 번호를 위한 파일 오프셋</strong>이에요. 이 필드의 값이 0이 아닐 경우 IMAGE_LINENUMBER 구조체 배열의 시작을 가리키고, COFF 라인 번호가 PE에 첨부되었을 경우에만 사용해요.</p>
<br>

<h3 id="여덟-번째-멤버-NumberOfRelocations"><a href="#여덟-번째-멤버-NumberOfRelocations" class="headerlink" title="여덟 번째 멤버, NumberOfRelocations"></a>여덟 번째 멤버, NumberOfRelocations</h3><p>PointerToRelocations 필드가 가리키는 <strong>IMAGE_RELOCATION 구조체 배열의 원소의 개수</strong>에요. 실행 파일에서는 항상 0이에요!</p>
<br>

<h3 id="아홉-번째-멤버-NumberOfLinenumbers"><a href="#아홉-번째-멤버-NumberOfLinenumbers" class="headerlink" title="아홉 번째 멤버, NumberOfLinenumbers"></a>아홉 번째 멤버, NumberOfLinenumbers</h3><p>PointerToLinenumbers 필드가 가리키는 <strong>IMAGE_LINENUMBER 구조체 배열의 원소의 개수</strong>에요. 마찬가지로 COFF 라인 번호가 PE 파일에 추가 되어쓸 때만 사용해요.</p>
<br>

<h3 id="열-번째-멤버-Characteristics"><a href="#열-번째-멤버-Characteristics" class="headerlink" title="열 번째 멤버, Characteristics"></a>열 번째 멤버, Characteristics</h3><p><strong>이 필드는 해당 섹션의 속성을 나타내는 플래그의 집합</strong>이에요.<br>“WinNT.h” 헤더 파일에 IMAGE_SCN_XXX_XXX의 형태로 매크로로 정의되어 있어요.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Section contains code.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SCN_CNT_CODE 0x00000020</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Section contains ubutuakuzed data</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SCN_CNT_INITIALIZED_DATA 0x00000040</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Section contains uninitialized data</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SCN_CNT_UNINITIALIZED_DATA 0x00000080</span></span><br></pre></td></tr></table></figure>

<p>링커는 링크 시에 필요에 따라서나 혹은 사용자의 지시에 의해 여러 섹션들을 하나로 병합할수 있어요. 병합하는 옵션은 /MERGS:from=to 형식으로 지정하면 되요. 이때 병합된 섹션 내에 특정 섹션이 포함되어 있는지를 확인할 수 있는 플래그 집함을 제공한느데 위의 플래그 집함이 그 목적으로 사용된다고 해요.</p>
<h4 id="IMAGE-SCN-CNT-CODE"><a href="#IMAGE-SCN-CNT-CODE" class="headerlink" title="IMAGE_SCN_CNT_CODE"></a>IMAGE_SCN_CNT_CODE</h4><p>섹션의 코드를 포함하고 있고, 보통 이 플래그는 실행 가능 플래그를 의미하는 IMAGE_SCN_MEM_EXECUTE(0x20000000) 플래그와 함께 저장된다고 해요.</p>
<h4 id="IMAGE-SCN-CNT-INITIALIZED-DATA"><a href="#IMAGE-SCN-CNT-INITIALIZED-DATA" class="headerlink" title="IMAGE_SCN_CNT_INITIALIZED_DATA"></a>IMAGE_SCN_CNT_INITIALIZED_DATA</h4><p>섹션이 초기화된 데이터를 포함하고 있어요. 실행 가능 섹션과 .bss 섹션을 제외한 거의 대부분의 섹션이 이 플래그를 가져요.</p>
<h4 id="IMAGE-SCN-CNT-UNINTIALIZED-DATA"><a href="#IMAGE-SCN-CNT-UNINTIALIZED-DATA" class="headerlink" title="IMAGE_SCN_CNT_UNINTIALIZED_DATA"></a>IMAGE_SCN_CNT_UNINTIALIZED_DATA</h4><p>섹션이 초기화되지 않은 데이터(.bss 섹션 …)들이 가져요.</p>
<br>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SCN_MEM_DISCARDABLE 0x02000000 <span class="comment">// Section can be discared.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SCN_MEM_NOT_CACHED 0x04000000 <span class="comment">// Section is not cachable.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SCN_MEM_NOT_PAGED 0x08000000 <span class="comment">// Section is not pageable.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SCN_MEM_SHARED 0x10000000 <span class="comment">// Section is shareable.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SCN_MEM_EXECUTE 0x20000000 <span class="comment">// Section is readable.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SCN_MEM_READ 0x40000000 <span class="comment">// Section is readable.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SCN_MEM_WRITE 0x80000000 <span class="comment">// Section is writeable.</span></span></span><br></pre></td></tr></table></figure>

<p>위의 매크로 정의들은 메모리 페이지 속성을 나타내는 플래그들이에요.</p>
<h4 id="IMAGE-SCN-MEM-DISCARDABLE"><a href="#IMAGE-SCN-MEM-DISCARDABLE" class="headerlink" title="IMAGE_SCN_MEM_DISCARDABLE"></a>IMAGE_SCN_MEM_DISCARDABLE</h4><p>이 섹션은 실행 이미지가 메모리에 완전히 매핑되고 난 뒤 버려질 수 있다는 것을 의미해요.<br>일단 메모리에 로드(매핑)되고 난 후 프로세스에게 더 이상 의미없는 섹션이며, 가장 일반적인 버릴 수 있는 섹션은 기본 재배치(.reloc)섹션이에요.</p>
<h4 id="IMAGE-SCN-MEM-NOT-CACHD"><a href="#IMAGE-SCN-MEM-NOT-CACHD" class="headerlink" title="IMAGE_SCN_MEM_NOT_CACHD"></a>IMAGE_SCN_MEM_NOT_CACHD</h4><h4 id="IMAGE-SCN-MEM-NOT-PAGED"><a href="#IMAGE-SCN-MEM-NOT-PAGED" class="headerlink" title="IMAGE_SCN_MEM_NOT_PAGED"></a>IMAGE_SCN_MEM_NOT_PAGED</h4><p>해당 섹션은 페이지되지 않거나 캐쉬되지 않아요. 페이지 되지 않는다는 말은 결코 페이지 파일로 스왑되지 않는 다는 것을 의미하며 이는 항상 RAM에 존재하는 섹션임을 의미해요. 이런 종류의 섹션을 필요로 하는 경우는 커널 모드에서 작동하는 디바이스 드라이버 가능 실행 모듈이에요.</p>
<h4 id="IMAGE-SCN-MEM-SHARED"><a href="#IMAGE-SCN-MEM-SHARED" class="headerlink" title="IMAGE_SCN_MEM_SHARED"></a>IMAGE_SCN_MEM_SHARED</h4><p>해당 섹션은 공유 가능한 섹션이라는 것을 의미해요. DLL과 함께 사용될 때 이 섹션에 있는 데이터는 DLL을 사용하는 모든 프로세스들에 의해 공유될 수 있어요.<br>일반적으로 데이터 섹션들은 공유 불가능하다. 이 말은 해당 DLL을 사용하는 각각의 프로세스는 이 섹션의 데이터에 대한 자신만의 사본을 가진다는 의미에요.<br>하지만 공유 가능 섹션은 메모리 매니저에게 해당 섹션을 공유 가능하도록 지시해요. 공유 가능 섹션을 만들려면 링커 시에 SHARED 속성을 주면 되요.</p>
<blockquote><p>LINK /SECTION:MYDATA, RWS …</p>
</blockquote>

<h4 id="IMAGE-SCN-MEM-EXECUTE"><a href="#IMAGE-SCN-MEM-EXECUTE" class="headerlink" title="IMAGE_SCN_MEM_EXECUTE"></a>IMAGE_SCN_MEM_EXECUTE</h4><p>이 섹션은 실행 가능한 섹션임을 의미해요. 이 플래그는 보통 코드 포함 플래그인 IMAGE_SCN_CNT_CODE 플래그와 함께 셋되요.</p>
<h4 id="IMAGE-SCN-MEM-READ"><a href="#IMAGE-SCN-MEM-READ" class="headerlink" title="IMAGE_SCN_MEM_READ"></a>IMAGE_SCN_MEM_READ</h4><p>이 섹션은 읽기 가능한 섹션임을 의미해요. 이 플래그는 언제나 EXE 파일 내의 대부분의 섹션들에 셋되요.</p>
<h4 id="IMAGE-SCN-MEM-WRITE"><a href="#IMAGE-SCN-MEM-WRITE" class="headerlink" title="IMAGE_SCN_MEM_WRITE"></a>IMAGE_SCN_MEM_WRITE</h4><p>이 섹션은 쓰기 가능한 섹션임을 의미해요. 이 플래그가 EXE의 섹션에 세트되지 않으면 로더는 메모리 맵드 페이지를 읽기 전용 또는 실행 전용으로 마크한다고 해요.<br>쓰기 가능한 전형적인 예로 .data와 .bss 섹션이 있고, .idata 섹션 역시 이 플래그를 가져요.</p>
<br>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Section contains comments or some other type of information</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SCN_LNK_INFO 0x00000200</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Section contents will not become of image.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SCN_LNK_REMOVE 0x00000800</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Section contents comdat.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SCN_LNK_COMDAT 0x00010000</span></span><br></pre></td></tr></table></figure>

<p>위의 매크로들은 컴파일 후 생성되는 OBJ 파일 내에서만 설정되는 플래그들로서 후에 링크 시에 링크로 하여금 최종 실행 모듈을 생성하는 데 필요한 정보를 참조할 수 있게 되요.</p>
<h4 id="IMAGE-SCN-LNK-INFO"><a href="#IMAGE-SCN-LNK-INFO" class="headerlink" title="IMAGE_SCN_LNK_INFO"></a>IMAGE_SCN_LNK_INFO</h4><p>해당 섹션이 링커에 의해 사용될 주석이나 다른 어떤 종류의 정보를 가져요. 이 섹션의 전형적인 예는 컴파일러에 의해 생성되며 링커를 위한 명령을 담고 있는 .drectve 섹션이에요.</p>
<h4 id="IMAGE-SCN-LNK-REMOVE"><a href="#IMAGE-SCN-LNK-REMOVE" class="headerlink" title="IMAGE_SCN_LNK_REMOVE"></a>IMAGE_SCN_LNK_REMOVE</h4><p>이 플래그는 링크 시에 최종 실행 파일의 일부가 되지 말아야 할 섹션의 내용들을 지시해요. 이 섹션들은 링커에게 정보를 넘겨주기 위한 컴파일러나 어셈블러에 의해 사용되요.</p>
<h4 id="IMAGE-CSCN-LNK-COMDAT"><a href="#IMAGE-CSCN-LNK-COMDAT" class="headerlink" title="IMAGE_CSCN_LNK_COMDAT"></a>IMAGE_CSCN_LNK_COMDAT</h4><p>해당 섹션의 내용은 공용 데이터라는 것을 의미해요. 이것은 COMDATA 라고 하는데, 공용 데이터나 코드 플래그는 여러 OBJ 파일에 걸쳐서 정의될 수 있어요. 링커는 실행 파일로 포함시키기 위해 하나의 복사본을 선택할 수 있어요.<br>COMDATA는 C++ 템플릿 함수와 함수 레벨 링킹을 지원하는데 매우 중요한 녀석이에요.</p>
<br>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Default alignemnt if no others are sepcifed.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SCN_ALIGN_1BYTES 0x00100000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SCN_ASLIGN_2BYTES 0x00200000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SCN_ALIGN_4BYTES 0x00300000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SCN_ALIGN_8BYTES 0x00400000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SCN_ALIGN_8192BYTES 0x00E00000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SCN_ALIGN_MASK 0x00F00000</span></span><br></pre></td></tr></table></figure>

<p>위의 매크로들은 생성된 실행 파일 내의 해당 섹셔의 데이터 정렬 단위를 나타내는 플래그이며, OBJ 파일 내에서만 셋팅되요.</p>
<h4 id="IMAGE-SCN-ALIGN-XBYTES"><a href="#IMAGE-SCN-ALIGN-XBYTES" class="headerlink" title="IMAGE_SCN_ALIGN_XBYTES"></a>IMAGE_SCN_ALIGN_XBYTES</h4><p>_XBYTES의 값으로 1BYT부터 8192BYTE 까지의 정렬 단위를 사타내요. 특별히 지정되지 않으면 디폴트로 16BYTE에 해당하는 IMAGE_SCN_ALIGN_16BYTES가 되고 이 값은 0x00500000 이에요.</p>
<br>

<h3 id="마지막으로…"><a href="#마지막으로…" class="headerlink" title="마지막으로…"></a>마지막으로…</h3><p>IMAGE_SECTION_HEADER에 있는 멤버들 중, <strong>VirtualSize, VirtualAddress, SizeOfRawData, PointerToRawData, Characteristics</strong> 멤버에 대해서는 확실하게 알아야 해요.</p>
<p>이 멤버들을 이용해서 메모리의 속성이 어떤지 파악할 수 있고, 어떤 부분이 데이터들이 저장되어 있는지 알 수 있거든요. 이 부분을 알아야지 우리가 필요한 데이터들을 찾을 수 있어요.</p>
<br>

<p>PE 파일에서 각 섹션의 실제 내용을 확인하고자 한다면 PointerToRawData가 가리키는 위치로 파일 오프셋을 이동시키고, 그곳에서부터 SizeOfRawData의 바이트 수만큼이 해당 섹션의 실제 내용이 되요.<br>이 섹션이 실제로 가상 주소 공간에 매핑되었을 때의 RVA가 VirtualAddress가 되며 매핑된 후의 <strong>섹션의 실제 시작 포인터를 얻고자 한다면 VirtualAddress 값에다가 IMAGE_OPTIONAL_HEADER의 ImageBase 필드 값을 더하면 되요.</strong> 그리고 매핑된 후에 이 섹션이 차지하고 있는 메모리 상의 크기는 VirtualSize에 명시되어 있어요.</p>
<p>일반적으로 포함되어 있는 섹션의 Charateristics 값을 한번 살펴봐요.</p>
<h4 id="textbss의-속성"><a href="#textbss의-속성" class="headerlink" title=".textbss의 속성"></a>.textbss의 속성</h4><ul>
<li>.textbss -&gt; 0xE0000000<ul>
<li>IMAGE_SCN_MEM__EXECUTE -&gt; 0x20000000</li>
<li>IMAGE_SCN_MEM_READ -&gt; 0x40000000</li>
<li>IMAGE_SCN_MEM_WRITE -&gt; 0x80000000</li>
<li>IMAGE_SCN_CNT_CODE -&gt; 0x00000020</li>
<li>IMAGE_SCN_CNT_UNINITALIZED_DATA -&gt; 0x00000080</li>
</ul>
</li>
</ul>
<p>.textbss 섹션은 코드 섹션과 초기화되지 않은 데이터가 있는 .bss 섹션이 혼합되어 있다는 것을 알 수 있어요. 그래서 메모리 속성으로는 실행, 읽기, 쓰기 속성이 지정되어 있고, 컨테이터 속성 중에서는 코드 속성과 초기화되지 않는 데이터 속성이 지정되어 있죠.</p>
<h4 id="text의-속성"><a href="#text의-속성" class="headerlink" title=".text의 속성"></a>.text의 속성</h4><ul>
<li>.text -&gt; 0x60000020<ul>
<li>IMAGE_SCN_MEM_EXECUTE -&gt; 0x20000000</li>
<li>IMAGE_SCN_MEM_READ -&gt; 0x40000000</li>
<li>IMAGE_SCN_CNT_CODE -&gt; 0x00000020</li>
</ul>
</li>
</ul>
<p>이 섹션은 코드 섹션으로서 전형적인 콛그 섹션의 속성만을 가지고 있어요. 메모리 속성으로는 실행과 읽기 속성을 가지며 컨테이너 속성으로는 코드 속성을 가져요.</p>
<h4 id="rdata의-속성"><a href="#rdata의-속성" class="headerlink" title=".rdata의 속성"></a>.rdata의 속성</h4><ul>
<li>.rdata -&gt; 0x40000040<ul>
<li>IMAGE_SCN_MEM_READ -&gt; 0x40000000</li>
<li>IMAGE_SCN_CNT_INITIALIZED_DATA -&gt; 0x00000040</li>
</ul>
</li>
</ul>
<p>이 섹션은 읽기 전용 데이터 섹션이에요. 따라서 메모리 속성은 읽기 속성만 가지며 컨테이너 속성으로는 초기화된 데이터 속성을 가져요.</p>
<h4 id="data-idata의-속성"><a href="#data-idata의-속성" class="headerlink" title=".data, .idata의 속성"></a>.data, .idata의 속성</h4><ul>
<li>.data, .idata -&gt; 0xC0000040<ul>
<li>IMAGE_SCN_MEM_READ -&gt; 0x40000000</li>
<li>IMAGE_SCN_MEM_WRITE -&gt; 0x80000000</li>
<li>IMAGE_SCN_CNT_INITIALIZED_DATA -&gt; 0x00000040</li>
</ul>
</li>
</ul>
<p>.data 섹션은 전형적인 데이터 섹션이에요. 그래서 읽기 쓰기가 가능하며, 초기화된 전역 변수들은 모두 이 섹션에 자리를 잡아요. 따라서 메모리 속성은 읽기, 쓰기 속성이 모두 지정되어 있으며 컨테이너 속성은 초기화된 데이터 속성이에요.</p>
<p>.idata 섹션은 임포트된 DLL과 그 함수들에 대한 정보를 담고 있는 섹션이에요. 따라서 프로그램 로드 시에 로더는 이 섹션을 참조하여 해당 DLL을 메모리에 매핑을 시켜요. 그렇기 때문에 당연히 메모리 속성은 읽기 속성을 가져야 해요. 그리고 이 정보는 링크 시에 정해지기 때문에 초기화된 데이터 컨테이너 속성을 가질 수밖에 없어요.</p>
<p>하지만 임포트 섹션은 왜 쓰기 속성을 가질까요? 그 이유는 로더가 DLL을 로드한 후에 이 섹션에 존재하는 DLL에 속하는 임포트 함수에 대한 함수 포인터를 임포트 주소 테이블(IAT)라고 하는 곳에 저장하기 떄문이에요.</p>
<p>임포트 주소 테이블(IAT)이 임포트 섹션 내에 존재하기 때문에 임포트 섹션은 쓰기 속성을 가져야만 하고, 임포트 함수를 사용할 때 임포트 주소 테이블(IAT)를 통해서 함수의 포인터를 얻어서 사용해요.</p>
<br>
<br>
<br>
<br>
<br>

<h2 id="참고자료"><a href="#참고자료" class="headerlink" title="참고자료"></a>참고자료</h2><hr>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_section_header" target="_blank" rel="noopener">IMAGE_SECTION_HEADER</a></p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://777bareman777.github.io/2019/09/19/UnderstandPE5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="777bareman777">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="777bareman777 Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/09/19/UnderstandPE5/" class="post-title-link" itemprop="url">PE 구조 이해하기 - IMAGE_DATA_DIRECTORY 구조</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-09-19 16:33:57" itemprop="dateCreated datePublished" datetime="2019-09-19T16:33:57+09:00">2019-09-19</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-09-24 09:13:36" itemprop="dateModified" datetime="2019-09-24T09:13:36+09:00">2019-09-24</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/PE-file/" itemprop="url" rel="index"><span itemprop="name">PE file</span></a></span>

                
                
              
            </span>
          

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
        
      
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2019/09/19/UnderstandPE5/#comments" itemprop="discussionUrl"><span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/09/19/UnderstandPE5/" itemprop="commentCount"></span></a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>windows 시스템 실행파일의 구조와 원리 책 내용을 요약 및 정리 하는 포스팅이에요.</p>
<p>주요 섹션들과 정보들의 위치와 크기를 나타내는 <strong>IMAGE_DATA_DIRECTORAY</strong>에 대한 내용을 알아볼 거에요.</p>
<br>

<h2 id="IMAGE-DATA-DIRECTORY의-시작"><a href="#IMAGE-DATA-DIRECTORY의-시작" class="headerlink" title="IMAGE_DATA_DIRECTORY의 시작"></a>IMAGE_DATA_DIRECTORY의 시작</h2><p><strong>이 구조체에는 주요 섹션들과 정보들의 위치와 크기를 나타내는 값들이 저장되어 있어요.</strong><br>구조체 배열의 크기에 대한 값이 <strong>매크로 상수 값(IMAGE_UNMBEROF_DIRECTROY_ENTRIES)</strong>으로 지정이 되어 있지만, 공식 문서에서는 항상 16개로 고정되어 있지 않다고해요.<br>따라서 <strong>IMAGE_DATA_DIRECTORY 구조체의 배열의 개수를 알기 위해서는 IMAGE_OPTIONAL_HEADER 구조체의 NumberOfRvaAndSizes 멤버를 확인</strong>해야 되요.</p>
<br>

<p>지금은 16개로 고정되있다고 생각을 할게요!<br>16개가 있다면 이 구조체는 128바이트로 이루어진 구조체 배열이에요.<br>그리고 이 배열의 마지막 엔트리, 인덱스 15에 해당하는 엔트리는 언제나 0으로 세팅되야 한다고 해요.</p>
<p>즉, <strong>배열의 인덱스 0부터 NumberOfRvaSizes-1까지의 인덱스가 지정하는 필드가 모두 사용되는 것이 아니라 마지막에 해당하는 인덱스를 제외하고 사용하는 거죠.</strong></p>
<p>각 엔트리들은 나름대로의 의미를 가지고 있고요. 특히 <strong>병합된 섹션과 관련된 정보가 엔트리에 들어가기 때문이에요. 그래서 이 필드는 반드시 참조해야 하는 영역입니다.</strong></p>
<p>각 배열의 엔트리의 의미는 이것 또한 “WinNT.h” 헤더 파일에 정의되어 있어요.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_UNMBEROF_DIRECTORAY_ENTRIES 16</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_DATA_DIRECTORY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	DWORD VirtualAddress;</span><br><span class="line">	DWORD Size;</span><br><span class="line">&#125; IMAGE_DATA_DIRECTROY, *PIMAGE_DATA_DIRECTROY:</span><br></pre></td></tr></table></figure>

<p><strong>VirtualAddress 와 Size는 각각 해당 IMAGE_DATA_DIRECTORY_ENTRY의 인덱스에 해당하는 미리 지정된 섹션 또는 블록의 정보에 대한 시작 주소와 그 크기를 가리키는 RVA</strong> 이에요.</p>
<p>예를 들면, 인덱스 0번은 Export Directory(내보내기 함수 테이블)에 대한 RVA와 크기이고, Import Directory(가져오기 함수 테이블)에 대한 RVA와 크기에요.</p>
<br>

<h2 id="IMAGE-DATA-DIRECTORY-ENTRY의-종류"><a href="#IMAGE-DATA-DIRECTORY-ENTRY의-종류" class="headerlink" title="IMAGE_DATA_DIRECTORY_ENTRY의 종류"></a>IMAGE_DATA_DIRECTORY_ENTRY의 종류</h2><p>이것 또한 각 인덱스의 의미는 “WinNT.h” 헤더 파일에 정의되어 있죠.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Directory Entries</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_EXPORT          0   <span class="comment">// Export Directory</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_IMPORT          1   <span class="comment">// Import Directory</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_RESOURCE        2   <span class="comment">// Resource Directory</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_EXCEPTION       3   <span class="comment">// Exception Directory</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_SECURITY        4   <span class="comment">// Security Directory</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_BASERELOC       5   <span class="comment">// Base Relocation Table</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_DEBUG           6   <span class="comment">// Debug Directory</span></span></span><br><span class="line"><span class="comment">//      IMAGE_DIRECTORY_ENTRY_COPYRIGHT       7   // (X86 usage)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_ARCHITECTURE    7   <span class="comment">// Architecture Specific Data</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_GLOBALPTR       8   <span class="comment">// RVA of GP</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_TLS             9   <span class="comment">// TLS Directory</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG    10   <span class="comment">// Load Configuration Directory</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT   11   <span class="comment">// Bound Import Directory in headers</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_IAT            12   <span class="comment">// Import Address Table</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT   13   <span class="comment">// Delay Load Import Descriptors</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR 14   <span class="comment">// COM Runtime descriptor</span></span></span><br></pre></td></tr></table></figure>

<br>

<h3 id="0번-인덱스-IMAGE-DIRECTORY-ENTRY-EXPORT"><a href="#0번-인덱스-IMAGE-DIRECTORY-ENTRY-EXPORT" class="headerlink" title="0번 인덱스, IMAGE_DIRECTORY_ENTRY_EXPORT"></a>0번 인덱스, IMAGE_DIRECTORY_ENTRY_EXPORT</h3><p>익스포트 테이블(Export Directory Table), IMAGE_EXPORT_DIRECTORY 구조체의 시작 번지를 가리켜요. 이 시작 번지가 <strong>익스포트 섹션의 시작 주소</strong>에요.</p>
<br>

<h3 id="1번-인덱스-IMAGE-DIRECTORY-ENTRY-IMPORT"><a href="#1번-인덱스-IMAGE-DIRECTORY-ENTRY-IMPORT" class="headerlink" title="1번 인덱스, IMAGE_DIRECTORY_ENTRY_IMPORT"></a>1번 인덱스, IMAGE_DIRECTORY_ENTRY_IMPORT</h3><p>임포트 테이블(Import Directory Table), IMAGE_IMPORT_DESCRIPTOR 구조체 배열의 번지를 가리켜요. 이 시작 번지가 <strong>임포트 섹션의 시작 주소</strong>에요.</p>
<br>

<h3 id="2번-인덱스-IMAGE-DIRECTORY-ENTRY-RESOURCE"><a href="#2번-인덱스-IMAGE-DIRECTORY-ENTRY-RESOURCE" class="headerlink" title="2번 인덱스, IMAGE_DIRECTORY_ENTRY_RESOURCE"></a>2번 인덱스, IMAGE_DIRECTORY_ENTRY_RESOURCE</h3><p>리소스, IMAGE_RESOURCE_DIRECTORY 구조체의 시작 번지를 가리켜요. 이 시작 번지가 <strong>리소스 섹션의 시작 주소</strong>에요.</p>
<br>

<h3 id="3번-인덱스-IMAGE-DIRECTORY-ENTRY-EXCEPTION"><a href="#3번-인덱스-IMAGE-DIRECTORY-ENTRY-EXCEPTION" class="headerlink" title="3번 인덱스, IMAGE_DIRECTORY_ENTRY_EXCEPTION"></a>3번 인덱스, IMAGE_DIRECTORY_ENTRY_EXCEPTION</h3><p><strong>예외 핸들러 테이블(Exception Directory Table), IMAGE_RUNTIME_FUNCTION_ENTRY 구조체 배열의 시작 번지</strong>를 가리켜요. CPU에 의존적이고, 테이블 기반 예외 핸들링을 위한 것이죠. x86 계열을 제외한 모든 CPU상에서 사용되는데, X86 기반의 윈도우 PE 파일에서는 의미가 없는 영역이에요.</p>
<p><strong>IA-64 CPU, 64비트 CPU에서는 사용</strong>하는 영역인거죠!!</p>
<br>

<h3 id="4번-인덱스-IMAGE-DIRECTORY-ENTRY-SECURITY"><a href="#4번-인덱스-IMAGE-DIRECTORY-ENTRY-SECURITY" class="headerlink" title="4번 인덱스, IMAGE_DIRECTORY_ENTRY_SECURITY"></a>4번 인덱스, IMAGE_DIRECTORY_ENTRY_SECURITY</h3><p><strong>“WinTrust.h” 헤더 파일에 정의되어 있는 WIN_CRETIFICATEW 구조체들의 리스트 시작 번지</strong>를 가리켜요.<br>이 리스트는 메모리 상에 매핑되지 않기 때문에 <strong>VirtualAddress 필드 값</strong>은 RVA가 아니라 <strong>파일 오프셋</strong>에 해당되요.</p>
<br>

<h3 id="5번-인덱스-IMAGE-DIRECTORY-ENTRY-BASERELOC"><a href="#5번-인덱스-IMAGE-DIRECTORY-ENTRY-BASERELOC" class="headerlink" title="5번 인덱스, IMAGE_DIRECTORY_ENTRY_BASERELOC"></a>5번 인덱스, IMAGE_DIRECTORY_ENTRY_BASERELOC</h3><p><strong>기본 재배치(Base Relocation) 정보</strong>를 가리켜요.</p>
<p><strong>재배치</strong>는 무엇일까요?<br>로더가 실행 모듈을 원하는 위치, 즉 IMAGE_OPTIONAL_HEADER의 <strong>ImageBase 필드에 지정된 가상 주소 공간의 주소에 위치시키지 못했을 때 코드 상의 포인터 연산과 관련된 주소를 다시 갱신해야 하는 경우</strong>를 재배치 라고 불러요!</p>
<p>저번에 말했듯이 EXE의 경우에는 이런 상황이 거의 없어요. 그 이유는 EXE 파일보다 DLL이 먼저 메모리에 로딩되기 때문이에요. 그에 반면 DLL의 경우에는 빈번히 발생하죠.<br>이를 위해 재배치 섹셔이 존재하는데, 이 필드가 재배치 섹션의 시작 주소를 가리켜요.</p>
<br>

<h3 id="6번-인덱스-IMAGE-DIRECTORY-ENTRY-DEBUG"><a href="#6번-인덱스-IMAGE-DIRECTORY-ENTRY-DEBUG" class="headerlink" title="6번 인덱스, IMAGE_DIRECTORY_ENTRY_DEBUG"></a>6번 인덱스, IMAGE_DIRECTORY_ENTRY_DEBUG</h3><p><strong>IMAGE_DEBUG_DIRECTORY 구조체의 배열을 가리키는 번지</strong>에요.<br>각각 해당 <strong>이미지의 디버그 정보를 가지고 있죠.</strong></p>
<p>초기 볼랜드 링커의 경우 이 인덱스에 해당하는 IMAGE_DATA_DIRECTORY 엔트리의 Size 필드를 이 섹션의 바이트 수가 아니라 구조체의 수로 세트했다고 해요.</p>
<p>물론 지금은 섹션의 크기를 가지고 있어요!<br>따라서 IMAGE_DEBUG_DIRECTORY 구조체의 수를 얻기 위해서는 Size 필드의 값을 IMAGE_DEBUG_DIRECTORY 구조체의 바이트 수(28 바이트)로 나누면 되요.</p>
<br>

<h3 id="7번-인덱스-IMAGE-DIRECTORY-ENTRY-ARCHITECTURE"><a href="#7번-인덱스-IMAGE-DIRECTORY-ENTRY-ARCHITECTURE" class="headerlink" title="7번 인덱스, IMAGE_DIRECTORY_ENTRY_ARCHITECTURE"></a>7번 인덱스, IMAGE_DIRECTORY_ENTRY_ARCHITECTURE</h3><p><strong>아키텍처에 대한 구체적인 데이터, IMAGE_ARCHITECTURE_HEADER 구조체의 배열에 대한 시작 번지</strong>를 가리켜요.</p>
<p>X86 또는 IA-64 계열에서는 사용하지 않아요.<br>애초에 인텔 계열 CPU를 위해 만들어진 운영체제 이기 때문에 아키텍처에 대한 구체적인 데이터가 필요가 없는거죠!</p>
<br>

<h3 id="8번-인덱스-IMAGE-DIRECTORY-ENTRY-GLOBALPTR"><a href="#8번-인덱스-IMAGE-DIRECTORY-ENTRY-GLOBALPTR" class="headerlink" title="8번 인덱스, IMAGE_DIRECTORY_ENTRY_GLOBALPTR"></a>8번 인덱스, IMAGE_DIRECTORY_ENTRY_GLOBALPTR</h3><p><strong>글로벌 포인터 레지스터(GP, Global Pointer)로 사용되는 시작 번지</strong>를 가리켜요.<br>x86에서는 사용되지 않지만, IA-64 에서는 사용되요.<br>여기서 Size 필드는 필요가 없어요. 사용되지 않아요.</p>
<br>

<h3 id="9번-인덱스-IMAGE-DIRECTORY-ENTRY-TLS"><a href="#9번-인덱스-IMAGE-DIRECTORY-ENTRY-TLS" class="headerlink" title="9번 인덱스, IMAGE_DIRECTORY_ENTRY_TLS"></a>9번 인덱스, IMAGE_DIRECTORY_ENTRY_TLS</h3><p><strong>스레드 지역 저장소 초기화 섹션에 대한 시작 번지</strong>를 가리켜요.<br>별도의 TLS 함수를 사용하지 않고 __declspec(thread)라는 지시어를 통해 변수가 선언되면 이 변수는 TLS에 들어가게 되고 이를 위해 링커는 별도의 TLS 섹션을 만들게 되죠.</p>
<br>

<h3 id="10번-인덱스-IMAGE-DIRECTROY-ENTRY-LOAD-CONFIG"><a href="#10번-인덱스-IMAGE-DIRECTROY-ENTRY-LOAD-CONFIG" class="headerlink" title="10번 인덱스, IMAGE_DIRECTROY_ENTRY_LOAD_CONFIG"></a>10번 인덱스, IMAGE_DIRECTROY_ENTRY_LOAD_CONFIG</h3><p><strong>IMAGE_LOAD_CONFIG_DIRECTORY 구조체애 대한 시작 번지</strong>를 가리켜요.<br>Windows NT, Windows 2000, Windows XP의 구체적인 정보가 들어가 있다고해요.</p>
<p>이 구조체를 실행 파일에 집어 넣으러면 IMAGE_LOAD_CONFIG_DIRECTORY 구조체를 _load_config_used라는 이름으로 전역적으로 정의 해야 한다고 해요</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">extern <span class="string">"C"</span></span><br><span class="line"></span><br><span class="line"><span class="type">IMAGE_LOAD_CONFIG_DIRECTORY</span> __load_config_used = <span class="meta">&#123;...&#125;</span>;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="11번-인덱스-IMAGE-DIRECTORY-ENTRY-BOUND-IMPORT"><a href="#11번-인덱스-IMAGE-DIRECTORY-ENTRY-BOUND-IMPORT" class="headerlink" title="11번 인덱스, IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT"></a>11번 인덱스, IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT</h3><p><strong>IMAGE_BOUND_IMPORT_DESCRIPTOR 구조체 배열에 대한 시작 번지</strong>를 가리켜요.<br><strong>DLL 바인딩과 관련된 정보</strong>를 가리켜요.</p>
<p>이 필드도 중요한 녀석이죠! 나중에 더 상세하게 다룰 예정입니다!</p>
<br>

<h3 id="12번-인덱스-IMAGE-DIRECTORY-ENTRY-IAT"><a href="#12번-인덱스-IMAGE-DIRECTORY-ENTRY-IAT" class="headerlink" title="12번 인덱스, IMAGE_DIRECTORY_ENTRY_IAT"></a>12번 인덱스, IMAGE_DIRECTORY_ENTRY_IAT</h3><p><strong>첫 번째 임포트 주소 테이블(IAT, Import Address Table)의 시작 번지</strong>를 가리켜요.<br>임포트된 각각의 DLL에 대한 IAT는 메모리 상에서 연속적으로 나타나게 되요.<br>Size 필드는 모든 IAT의 전체 크기를 가리켜요.</p>
<p>로더는 임포트 섹션을 해석할 동안 이 엔트리의 주소와 크기를 이용해서 임시적으로 IAT들을 읽기/쓰기 모드로 마킹한다고 해요.</p>
<br>

<h3 id="13번-인덱스-IMAGE-DIRECTORY-ENTRY-DELAY-IMPORT"><a href="#13번-인덱스-IMAGE-DIRECTORY-ENTRY-DELAY-IMPORT" class="headerlink" title="13번 인덱스, IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT"></a>13번 인덱스, IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT</h3><p>Visual C++ 이 제공하는 DELAYTMP.H 헤더 파일에 정의되어 있는 <strong>ImgDelayDescr 구조체의 배열을 가리키는 시작 번지</strong>에요.</p>
<p><strong>지연 로딩 DLL은 해당 API가 처음으로 호출되기 전까지 로드되지 않아요.</strong><br>윈도우는 지연 로딩 DLL에 대한 어떠한 암시적인 정보고 가지고 있지 않아요.<br>전적으로 지연 로딩의 정보는 링커나 런타임 라이브러리에 구현되어 있죠.</p>
<br>

<h3 id="14번-인덱스-IMAGE-DIRECTORY-ENTRY-COM-DESCRIPTOR"><a href="#14번-인덱스-IMAGE-DIRECTORY-ENTRY-COM-DESCRIPTOR" class="headerlink" title="14번 인덱스, IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR"></a>14번 인덱스, IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR</h3><p>업데이트된 시스템 헤더 파일에 IMAGE_DIRECTORY_ENTRY_COMHEADER 라는 이름으로 변경되었다고 해요.</p>
<p>이 필드의 정보는 .NET 응용 애플리케이션이나 DLL용 PE를 위한 거라고 해요.<br>PE 내의 .NET 정보에 대한 최상위 정보의 시작 번지를 가리킨다고 해요.</p>
<p>이 정보 같은 경우에는 IMAGE_COR20_HEADER 구조체의 형태로 구성되었다고 합니다.</p>
<br>

<h2 id="마지막으로…"><a href="#마지막으로…" class="headerlink" title="마지막으로…"></a>마지막으로…</h2><p>모두 다 알면 좋겠지만, <strong>Export Directory, Import Directory, Exception Directory, Base Relocation Table, Bound Import Directory, Import Address Table(IAT), Delay Load Import Descriptors</strong>에 해당 하는 섹션들은 확실하게 공부를 해야한다고 생각을 합니다!</p>
<br>
<br>
<br>
<br>
<br>

<h2 id="참고자료"><a href="#참고자료" class="headerlink" title="참고자료"></a>참고자료</h2><hr>
<p><a href="https://docs.microsoft.com/ko-kr/windows/win32/api/winnt/ns-winnt-image_data_directory" target="_blank" rel="noopener">IMAGE_DATA_DIRECTORY</a></p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://777bareman777.github.io/2019/09/18/UnderstandPE4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="777bareman777">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="777bareman777 Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/09/18/UnderstandPE4/" class="post-title-link" itemprop="url">PE 구조 이해하기 - IMAGE_OPTIONAL_HEADER 구조</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-09-18 14:46:56" itemprop="dateCreated datePublished" datetime="2019-09-18T14:46:56+09:00">2019-09-18</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-01-17 07:14:52" itemprop="dateModified" datetime="2020-01-17T07:14:52+09:00">2020-01-17</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/PE-file/" itemprop="url" rel="index"><span itemprop="name">PE file</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/PE-file/Windows-Reversing/" itemprop="url" rel="index"><span itemprop="name">Windows Reversing</span></a></span>

                
                
              
            </span>
          

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
        
      
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2019/09/18/UnderstandPE4/#comments" itemprop="discussionUrl"><span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/09/18/UnderstandPE4/" itemprop="commentCount"></span></a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>windows 시스템 실행파일의 구조와 원리 책 내용을 요약 및 정리 하는 포스팅이에요.</p>
<p>PE파일의 PE 시그니처 다음에 이어지는 <strong>IMAGE_OPTIONAL_HEADER</strong>에 대한 내용을 알아볼 거에요.</p>
<br>

<h2 id="IMAGE-OPTIONAL-HEADER의-시작"><a href="#IMAGE-OPTIONAL-HEADER의-시작" class="headerlink" title="IMAGE_OPTIONAL_HEADER의 시작"></a>IMAGE_OPTIONAL_HEADER의 시작</h2><p>IMAGE_FILE_HEADER에 이어서 나오는 구조체는 <strong>224바이트</strong>로 구성된 <strong>IMAGE_OPTIONAL_HEADER</strong> 이에요.</p>
<p>IMAGE_OPTIONAL_HEADER 구조체는 <strong>96바이트를 차지하는 30개의 기본 필드</strong>와 <strong>8바이트 크기의 IMAGE_DATA_DIRECTORY 구조체에 대한 엔트리 개수가 16개인 배열 128(=8*16)바이트</strong>로 구성되어 있어요.</p>
<p>-&gt; IMAGE_OPTIONAL_HEADER32 구조체를 가지고 설명. </p>
<p>-&gt; 64비트 같은 경우에는 BaseOfData 부분이 없으며, 메모리 영역 부분이 DWORD 형이 아닌 ULONGLONG 형으로 선언이 되어있고, 데이터 디렉토리 구조체의 크기가 고정되어 있지 않음.</p>
<p>구조체는 다음과 같이 “WinNT.h” 헤더 파일에 정의되어 있음.</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _IMAGE_OPTIONAL_HEADER &#123;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">		<span class="type">Standard</span> fields.</span><br><span class="line">	*/</span><br><span class="line"></span><br><span class="line">  <span class="type">WORD</span>                 <span class="type">Magic</span>;</span><br><span class="line">  <span class="type">BYTE</span>                 <span class="type">MajorLinkerVersion</span>;</span><br><span class="line">  <span class="type">BYTE</span>                 <span class="type">MinorLinkerVersion</span>;</span><br><span class="line">  <span class="type">DWORD</span>                <span class="type">SizeOfCode</span>;</span><br><span class="line">  <span class="type">DWORD</span>                <span class="type">SizeOfInitializedData</span>;</span><br><span class="line">  <span class="type">DWORD</span>                <span class="type">SizeOfUninitializedData</span>;</span><br><span class="line">  <span class="type">DWORD</span>                <span class="type">AddressOfEntryPoint</span>;</span><br><span class="line">  <span class="type">DWORD</span>                <span class="type">BaseOfCode</span>;</span><br><span class="line">  <span class="type">DWORD</span>                <span class="type">BaseOfData</span>;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">		<span class="type">NT</span> additional fields.</span><br><span class="line">	*/</span><br><span class="line"></span><br><span class="line">  <span class="type">DWORD</span>                <span class="type">ImageBase</span>;</span><br><span class="line">  <span class="type">DWORD</span>                <span class="type">SectionAlignment</span>;</span><br><span class="line">  <span class="type">DWORD</span>                <span class="type">FileAlignment</span>;</span><br><span class="line">  <span class="type">WORD</span>                 <span class="type">MajorOperatingSystemVersion</span>;</span><br><span class="line">  <span class="type">WORD</span>                 <span class="type">MinorOperatingSystemVersion</span>;</span><br><span class="line">  <span class="type">WORD</span>                 <span class="type">MajorImageVersion</span>;</span><br><span class="line">  <span class="type">WORD</span>                 <span class="type">MinorImageVersion</span>;</span><br><span class="line">  <span class="type">WORD</span>                 <span class="type">MajorSubsystemVersion</span>;</span><br><span class="line">  <span class="type">WORD</span>                 <span class="type">MinorSubsystemVersion</span>;</span><br><span class="line">  <span class="type">DWORD</span>                <span class="type">Win32VersionValue</span>;</span><br><span class="line">  <span class="type">DWORD</span>                <span class="type">SizeOfImage</span>;</span><br><span class="line">  <span class="type">DWORD</span>                <span class="type">SizeOfHeaders</span>;</span><br><span class="line">  <span class="type">DWORD</span>                <span class="type">CheckSum</span>;</span><br><span class="line">  <span class="type">WORD</span>                 <span class="type">Subsystem</span>;</span><br><span class="line">  <span class="type">WORD</span>                 <span class="type">DllCharacteristics</span>;</span><br><span class="line">  <span class="type">DWORD</span>                <span class="type">SizeOfStackReserve</span>;</span><br><span class="line">  <span class="type">DWORD</span>                <span class="type">SizeOfStackCommit</span>;</span><br><span class="line">  <span class="type">DWORD</span>                <span class="type">SizeOfHeapReserve</span>;</span><br><span class="line">  <span class="type">DWORD</span>                <span class="type">SizeOfHeapCommit</span>;</span><br><span class="line">  <span class="type">DWORD</span>                <span class="type">LoaderFlags</span>;</span><br><span class="line">  <span class="type">DWORD</span>                <span class="type">NumberOfRvaAndSizes</span>;</span><br><span class="line">  <span class="type">IMAGE_DATA_DIRECTORY</span> <span class="type">DataDirectory</span>[<span class="type">IMAGE_NUMBEROF_DIRECTORY_ENTRIES</span>];</span><br><span class="line">&#125; <span class="type">IMAGE_OPTIONAL_HEADER32</span>, *<span class="type">PIMAGE_OPTIONAL_HEADER32</span>;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="첫-번째-멤버-WORD-Magic"><a href="#첫-번째-멤버-WORD-Magic" class="headerlink" title="첫 번째 멤버, WORD Magic"></a>첫 번째 멤버, WORD Magic</h3><p>IMAGE_OPTIONAL_HEADER를 나타내는 <strong>시그니처</strong>에요. 이 값은 3<strong>2비트 PE의 경우 0x010B</strong>이고, <strong>64비트 PE의 경우 0x020B</strong>에요.<br>닷넴 프레임워크 .NET PE의 경우 항상 0x010B 라고 해요.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_NT_OPTIONAL_HDR32 0x10B</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_NT_OPTIONAL_HDR64_MAGIC 0x20B</span></span><br></pre></td></tr></table></figure>

<br>

<h3 id="두-번째-멤버-BYTE-MajorLinkerVersion"><a href="#두-번째-멤버-BYTE-MajorLinkerVersion" class="headerlink" title="두 번째 멤버, BYTE MajorLinkerVersion"></a>두 번째 멤버, BYTE MajorLinkerVersion</h3><h3 id="세-번째-멤버-BYTE-MinorLinkerVersion"><a href="#세-번째-멤버-BYTE-MinorLinkerVersion" class="headerlink" title="세 번째 멤버, BYTE MinorLinkerVersion"></a>세 번째 멤버, BYTE MinorLinkerVersion</h3><p>P<strong>E 파일을 만들어낸 링커의 버전</strong>을 나타내요.<br>예를 드러 메이저 0x09, 마이너 0x0A라면 링커 버전 9.10을 나타내는 거죠.</p>
<p>“Visual Studio.NET Command Prompt”를 실행시켜 Link.exe를 실행시키면 링커의 버전을 확인할 수 있다고 해요.</p>
<br>

<h3 id="네-번째-멤버-DWORD-SizeOfCode"><a href="#네-번째-멤버-DWORD-SizeOfCode" class="headerlink" title="네 번째 멤버, DWORD SizeOfCode"></a>네 번째 멤버, DWORD SizeOfCode</h3><p><strong>모든 코드 섹션들의 사이즈를 합한 라운드업된 크기</strong>에요.<br>일반적으로 실행 파일은 하나의 코드 섹션을 가지기 때문에 이 필드는 .text 섹션의 바이트 수와 동일해요.</p>
<p><strong>정확하게 말하면, 섹션 중 “IMAGE_SCN_CNT_CODE” 속성을 가진 섹션들의 전체 크기</strong>라고 해요.<br>이러한 속성들은 IMAGE_SECTION_HEADER의 Characteristics에서 찾아볼 수 있어요.</p>
<br>

<h3 id="다섯-번째-멤버-DWORD-SizeOfInitializeData"><a href="#다섯-번째-멤버-DWORD-SizeOfInitializeData" class="headerlink" title="다섯 번째 멤버, DWORD SizeOfInitializeData"></a>다섯 번째 멤버, DWORD SizeOfInitializeData</h3><p><strong>코드 섹션을 제외한 초기화된 데이터 섹션의 전체 크기</strong>를 나타내요.<br><strong>초기화된 데이터 섹션은 “IMAGE_SCN_CNT_INITALIZED_DATA” 속성</strong>을 가져요.</p>
<br>

<h3 id="여섯-번째-멤버-DWORD-SizeOfUninitializedData"><a href="#여섯-번째-멤버-DWORD-SizeOfUninitializedData" class="headerlink" title="여섯 번째 멤버, DWORD SizeOfUninitializedData"></a>여섯 번째 멤버, DWORD SizeOfUninitializedData</h3><p><strong>초기화되지 않은 데이터 섹션(일반적으로 .bss 섹션 또는 .textbss 섹션)의 바이트수</strong>를 나타내요.</p>
<p><strong>초기화되지 않은 데이터 섹션은 “IMAGE_SCN_CNT_UNINITALIZED_DATA” 속성</strong>을 가져요.</p>
<p>일반적으로 초기화되지 않은 데이터를 일반 데이터 섹션에 병합시킬 수 있기 때문에 보통 이 필드의 값은 0이 된다.</p>
<br>

<h3 id="일곱-번째-멤버-DWORD-AddressOfEntryPoint"><a href="#일곱-번째-멤버-DWORD-AddressOfEntryPoint" class="headerlink" title="일곱 번째 멤버, DWORD AddressOfEntryPoint"></a>일곱 번째 멤버, DWORD AddressOfEntryPoint</h3><p><strong>로더가 실행을 시작할 주소</strong>를 나타내요. RVA 형태로 값이 저장되고, 일반적으로 <strong>.text 섹션 내의 특정 번지</strong>가 되요.<br>즉, 이 필드의 값은 <strong>프로그램이 처음으로 실행될 코드를 담고 있는 주소</strong>인 거죠.</p>
<p>좀 더 자세히보면, 프로그램이 로드된 후 이 프로세스의 메인 스레드 문맥(Context)의 EIP/RIP 레지스터가 가질 수 있는 최초의 값이에요.<br>일반적으로 이 <strong>번지가 가리키는 값은 소위 말하는 런타임 시작 루틴(EXE의 경우 WinMainCRTStartup 또는 mainCRTStartup, DLL의 경우 DllMainCRTStartup)의 번지 값</strong>이에요.</p>
<p>AddressOfEntryPoint 멤버는 중요한 필드죠!</p>
<br>

<h3 id="여덟-번째-멤버-DWORD-BaseOfCode"><a href="#여덟-번째-멤버-DWORD-BaseOfCode" class="headerlink" title="여덟 번째 멤버, DWORD BaseOfCode"></a>여덟 번째 멤버, DWORD BaseOfCode</h3><p><strong>첫 번째 코드 섹션이 시작 되는 RVA값</strong>을 가지고 있어요.<br>코드 섹션은 전형적으로 PE 헤더 다음, 데이터 섹션 바로 직전에 있어요.</p>
<p>MS 링커가 만들어내는 EXE의 RVA는 보통 0x1000인데, 이 값은 설정에 따라 바뀔 수 있어요.</p>
<br>

<h3 id="아홉-번째-멤버-DWORD-BaseOfData"><a href="#아홉-번째-멤버-DWORD-BaseOfData" class="headerlink" title="아홉 번째 멤버, DWORD BaseOfData"></a>아홉 번째 멤버, DWORD BaseOfData</h3><p>이론적으로 <strong>메모리에 로드될 때 데이터의 첫 번째 바이트의 RVA</strong>를 가리켜요.<br>그리고 이 필드의 값은 MS의 링커 버전에 따라 다르고, 64비트 PE에서는 없는 멤버에요.</p>
<br>

<h3 id="열-번째-멤버-ImageBase"><a href="#열-번째-멤버-ImageBase" class="headerlink" title="열 번째 멤버, ImageBase"></a>열 번째 멤버, ImageBase</h3><p>해당 <strong>PE가 가상 주소 공간에 매핑될 때, 매핑시키고자 하는 메모리 상의 시작 주소</strong>에요.</p>
<p>그 주소가 사용되고 있지 않으면 로더는 이 멤버가 가리키는 값으로 매핑시키기를 원해요.</p>
<p>만약에 PE 파일이 ImageBase가 가리키는 주소에 로드되면 로더는 기본 재배치를 수행하는 과정을 건너뛸 수 있어요.</p>
<p><strong>EXE에 대해서 이 값은 기본 이미지 베이스의 값은 0x00400000</strong> 이고, <strong>DLL의 경우 이 값은 0x10000000</strong> 이에요. 이 값들은 링크 시 옵션 /BASE를 지정함으로써 변결될 수 있어요.</p>
<h4 id="추가적으로…"><a href="#추가적으로…" class="headerlink" title="추가적으로…"></a>추가적으로…</h4><p>일반적으로 PE 파일이 가상 메모리 공간에 매핑될 때, DLL 파일보다 EXE 파일이 먼저 올라가게 되요. 그래서 EXE 파일이 메모리에 올라갈 때 재배치 과정을 거치지 않아요. 하지만 DLL의 경우에는 그 해당하는 위치가 다른 녀석들이 이미 올라가 있는 경우가 많아서 재배치 과정을 거쳐요.</p>
<p>요즘에는 윈도우의 보호기법 중 하나인 ASLR(Address space layout randomization) 때문에 ImageBase에 있는 주소에 PE 파일들이 매핑되지 않고, 랜덤으로 가상 메모리 공간에 매핑이 되요!</p>
<br> 

<h3 id="열한-번째-멤버-SectionAlignment"><a href="#열한-번째-멤버-SectionAlignment" class="headerlink" title="열한 번째 멤버, SectionAlignment"></a>열한 번째 멤버, SectionAlignment</h3><p><strong>PE 파일이 메모리에 매핑될 때</strong> 각 섹션의 시작 주소는 언제나 이 <strong>SectionAlignment 필드에서 지정된 값의 배수가 되는 가상 주소가 되도록 보장되요.</strong></p>
<p>이러한 제한이 바로 <strong>PE 파일 자체가 메모리 맵 파일</strong>임을 말하고 있는 거에요. </p>
<p>일반적인 파일들은 시스템 페이징 파일을 통해서 메모리에 매핑이 되지만, <strong>PE 파일 경우에 PE 파일 자체가 페이징 파일이 되기 떄문에 섹션의 시작 주소는 항상 메모리 페이지의 배수</strong>이어야 되요.</p>
<p>PE 파일 자체가 메모리 맵 파일이라고 하더라도 <strong>메모리에서 PE 파일에 대한 변조가 일어나더라도 실제 파일에는 영향을 끼치지 않아요.</strong></p>
<p>메모리 속성 중 “<strong>실행 가능</strong>“ 속성을 가지게 되면 이 페이지에 대한 “<strong>쓰기</strong>“ 동작에 대한 파일로의 반영은 “<strong>COW</strong>“ 라는 매커니즘을 통해서 페이지에 데이터를 갱신하게 되면 매핑된 파일로의 반영이 아니라 <strong>해당 데이터를 그 페이지에 갱신하기 직전에 페이지 파일(PageFile.sys)로 복사되어서 백업된 뒤 해당 페이지가 갱신</strong>되요.</p>
<p>따라서 <strong>메모리에 매핑된 PE는 “실행 가능”속성을 지니기 때문에 디스크 상의 해당 PE 자체로의 즉각적인 반영이 이루어지지 않는거죠.</strong></p>
<br>

<h3 id="열두-번째-멤버-FileAlignment"><a href="#열두-번째-멤버-FileAlignment" class="headerlink" title="열두 번째 멤버, FileAlignment"></a>열두 번째 멤버, FileAlignment</h3><p><strong>PE 파일 내에서 섹션들의 정렬 단위</strong>를 나타내요.<br><strong>하드 디스크에 저장된 PE 파일 내의 각각의 섹션을 구성하는 바이너리 데이터들은 FileAlignemnt 필드의 값의 배수</strong>로 시작하도록 보장해요.</p>
<p><strong>이 값이 실질적으로 디스크의 섹터 단위</strong>가 되는거죠.<br>NTFS의 경우 한 섹터는 디폴트로 4K이고, <strong>보통 0x200 아니면 0x100의 값</strong>을 가지고 있어요.<br>MS 링커 버전에 따라 기본 값은 변경이 되고, 무조건 이 값은 2의 멱승이 되어야 해요.</p>
<p><strong>만약 SectionAlignment 필드의 값이 CPU 페이지 사이즈보다 작을 경우 이 필드는 SectionAlignment 필드의 값과 같아야 해요.</strong></p>
<br>

<h3 id="열세-번째-멤버-MajorOperatingSystemVersion"><a href="#열세-번째-멤버-MajorOperatingSystemVersion" class="headerlink" title="열세 번째 멤버, MajorOperatingSystemVersion"></a>열세 번째 멤버, MajorOperatingSystemVersion</h3><h3 id="열네-번째-멤버-MinorOperatingSystemVersion"><a href="#열네-번째-멤버-MinorOperatingSystemVersion" class="headerlink" title="열네 번째 멤버, MinorOperatingSystemVersion"></a>열네 번째 멤버, MinorOperatingSystemVersion</h3><p><strong>PE 파일을 실행하는 데 필요한 운영체제의 최소 버전</strong>을 말해요.<br>Windows 10 기반에서 컴파일과 링킹 과정을 거쳤다고 하더라도, 특정 버전 이상에서만 지원되는 기능 같은 것들을 사용하지 않으면 그 이전 버전에서도 돌아갈 수 있기 때문에 운영체제의 최소 버전 값이 정해져요.</p>
<br>

<h3 id="열다섯-번째-멤버-MajorImageVersion"><a href="#열다섯-번째-멤버-MajorImageVersion" class="headerlink" title="열다섯 번째 멤버, MajorImageVersion"></a>열다섯 번째 멤버, MajorImageVersion</h3><h3 id="열여섯-번째-멤버-MinorImageVersion"><a href="#열여섯-번째-멤버-MinorImageVersion" class="headerlink" title="열여섯 번째 멤버, MinorImageVersion"></a>열여섯 번째 멤버, MinorImageVersion</h3><p>유저가 정의 가능한 필드이며, 사<strong>용자가 만드는 EXE나 DLL에 유저 나름대로의 버전</strong>을 넣을 수 있어요.<br>링킹 시에 /VERSION 옵션을 사용해서 링킹을 해주면 되요.</p>
<br>

<h3 id="열일곱-번째-멤버-MajorSubsystemVersion"><a href="#열일곱-번째-멤버-MajorSubsystemVersion" class="headerlink" title="열일곱 번째 멤버, MajorSubsystemVersion"></a>열일곱 번째 멤버, MajorSubsystemVersion</h3><h3 id="열여덟-번째-멤버-MinorSubsystemVersion"><a href="#열여덟-번째-멤버-MinorSubsystemVersion" class="headerlink" title="열여덟 번째 멤버, MinorSubsystemVersion"></a>열여덟 번째 멤버, MinorSubsystemVersion</h3><p><strong>PE 파일을 실행하는 데 필요한 서브시스템의 최소 버전</strong>을 말해요.<br>링킹 시에 /SUBSYSTEM 스위치로 변경할 수 있어요.</p>
<br>

<h3 id="열아홉-번째-멤버-Win32VersionValue"><a href="#열아홉-번째-멤버-Win32VersionValue" class="headerlink" title="열아홉 번째 멤버, Win32VersionValue"></a>열아홉 번째 멤버, Win32VersionValue</h3><p>이 필드는 VC++ 6.0 SDK 까지는 예약 필드였는데, 7.0에 와서 Win32VersionValue 라는 이름을 가진 필드로 바뀌었고, 보통 0으로 결정되요.</p>
<br>

<h3 id="스물-번째-멤버-DWORD-SizeOfImage"><a href="#스물-번째-멤버-DWORD-SizeOfImage" class="headerlink" title="스물 번째 멤버, DWORD SizeOfImage"></a>스물 번째 멤버, DWORD SizeOfImage</h3><p>이 멤버는 <strong>로더가 해당 PE 파일을 메모리 상에 로드할 때 확보/예약해야 할 해당 PE를 위한 충분한 크기 값</strong>을 가져요.<br>PE 파일의 크기와 같을 수도 있지만 <strong>PE 파일 상에서의 섹션의 배치가 메모리에 매핑되면서 달라질 수 있기 때문에 보통은 PE 파일의 크기보다 커요.</strong></p>
<p><strong>이 필드의 값은 반드시 SectionAlignment 필드의 값의 배수</strong>가 되어야 해요.</p>
<br>

<h3 id="스물-첫-번째-멤버-DWORD-SizeOfHeaders"><a href="#스물-첫-번째-멤버-DWORD-SizeOfHeaders" class="headerlink" title="스물 첫 번째 멤버, DWORD SizeOfHeaders"></a>스물 첫 번째 멤버, DWORD SizeOfHeaders</h3><p>이 필드는 <strong>MS-DOS 헤더, PE 헤더, 섹션 테이블들의 크기를 모두 합친 바이트의 수</strong>에요.<br><strong>모든 헤더나 테이블들은 PE 파일 상에서 반드시 코드 또는 데이터 섹션의 앞쪽에 위치</strong>에 있어야 해요.</p>
<p><strong>이 필드의 값은 FilaAlignment 필드 값의 배수</strong>가 되어야 해요.</p>
<br>

<h3 id="스물-두-번째-멤버-DWORD-CheckSum"><a href="#스물-두-번째-멤버-DWORD-CheckSum" class="headerlink" title="스물 두 번째 멤버, DWORD CheckSum"></a>스물 두 번째 멤버, DWORD CheckSum</h3><p>이름 그대로 이미지의 체크섬 값이다. PE 파일의 체크섬 값은 IMAGEHELP.DLL의 CheckSumMAppedFile API를 통해서 얻을 수 있으며, 체크섬 값은 커널 모드 드라이버나 시스템 DLL의 경우 요구 된다.<br>그 외의 경우라면 보통 0으로 설정이 된다.<br>/RELEASE 링커 스위치를 통해 이 필드를 설정을 할 수 있다.</p>
<br>

<h3 id="스물-세-번째-멤버-WORD-Subsystem"><a href="#스물-세-번째-멤버-WORD-Subsystem" class="headerlink" title="스물 세 번째 멤버, WORD Subsystem"></a>스물 세 번째 멤버, WORD Subsystem</h3><p><strong>Win32 아키텍처는 크게 유저 모드와 커널 모드로 나눌 수 있으며, 유저 모드에는 서브시스템이라는 컴포넌트가 존재</strong>해요.</p>
<p>Win32에서 지원하는 기본 서브 시스템은 Win32 서브시스템, 이전 OS/2와의 호환을 위한 OS/2 서브시스템, 이전 UNIX와의 호환을 위해 최소 표준으로 지원되는 POSIX/CUI 서브시스템 이렇게 3가지 정도가 있다고 해요.</p>
<p>어떤 서브시스템을 지원하는지 알고 싶으면, “WinNT.h” 헤더 파일에 정의되어 있으니, 그것을 참고하면 되요.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SUBSYSTEM_UNKNOWN              0   <span class="comment">// Unknown subsystem.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SUBSYSTEM_NATIVE               1   <span class="comment">// Image doesn't require a subsystem.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SUBSYSTEM_WINDOWS_GUI          2   <span class="comment">// Image runs in the Windows GUI subsystem.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SUBSYSTEM_WINDOWS_CUI          3   <span class="comment">// Image runs in the Windows character subsystem.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SUBSYSTEM_OS2_CUI              5   <span class="comment">// image runs in the OS/2 character subsystem.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SUBSYSTEM_POSIX_CUI            7   <span class="comment">// image runs in the Posix character subsystem.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SUBSYSTEM_NATIVE_WINDOWS       8   <span class="comment">// image is a native Win9x driver.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SUBSYSTEM_WINDOWS_CE_GUI       9   <span class="comment">// Image runs in the Windows CE subsystem.</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SUBSYSTEM_EFI_APPLICATION      10  <span class="comment">//</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER  11   <span class="comment">//</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER   12  <span class="comment">//</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SUBSYSTEM_EFI_ROM              13</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SUBSYSTEM_XBOX                 14</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SUBSYSTEM_WINDOWS_BOOT_APPLICATION 16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SUBSYSTEM_XBOX_CODE_CATALOG    17</span></span><br></pre></td></tr></table></figure>

<p>대부분의 경우 IMAGE_SUBSYSTEM_WINDOS_GUI 또는 IMAGE_SUBSYSTEM_WINDOWS_CUI 이에요.</p>
<p>WinMain()으로 시작하는 경우 IMAGE_SUBSYSTEM_WINDOWS_GUI 인 0x0002가 될 것이고, main()으로 시작하는 콘솔 응용 애플리케이션의 경우 IMAGE_SUBSYSTEM_WINDOWS_CUI인 0x0003이 될거에요.</p>
<p>그 이외의 다바이스 드라이버 같이 별도로 서브시스템을 사용하지 않는 경우 IMAGE_SUBSYSTEM_NATIVE인 0x00001의 값을 가지게 되요.</p>
<br>

<h3 id="스물-네-번째-멤버-WORD-DllCharacteristics"><a href="#스물-네-번째-멤버-WORD-DllCharacteristics" class="headerlink" title="스물 네 번째 멤버, WORD DllCharacteristics"></a>스물 네 번째 멤버, WORD DllCharacteristics</h3><p>이 멤버는 <strong>PE가 DLL 이라는 전제 하에 어떤 상황에서 DLL 초기화 함수(DLLMain())을 호출 되어야 하는지를 지시하는 플래그 값</strong>이 저장되어 있어요.</p>
<p>“WinNT.h” 헤더 파일에 이 필드에 집어 넣을 수 있는 매크로 정의가 되어 있어요.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DllCharacteristics Entries</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//      IMAGE_LIBRARY_PROCESS_INIT            0x0001     // Reserved.</span></span><br><span class="line"><span class="comment">//      IMAGE_LIBRARY_PROCESS_TERM            0x0002     // Reserved.</span></span><br><span class="line"><span class="comment">//      IMAGE_LIBRARY_THREAD_INIT             0x0004     // Reserved.</span></span><br><span class="line"><span class="comment">//      IMAGE_LIBRARY_THREAD_TERM             0x0008     // Reserved.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DLLCHARACTERISTICS_HIGH_ENTROPY_VA    0x0020  <span class="comment">// Image can handle a high entropy 64-bit virtual address space.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE 0x0040     <span class="comment">// DLL can move.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DLLCHARACTERISTICS_FORCE_INTEGRITY    0x0080     <span class="comment">// Code Integrity Image</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DLLCHARACTERISTICS_NX_COMPAT    0x0100     <span class="comment">// Image is NX compatible</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DLLCHARACTERISTICS_NO_ISOLATION 0x0200     <span class="comment">// Image understands isolation and doesn't want it</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DLLCHARACTERISTICS_NO_SEH       0x0400     <span class="comment">// Image does not use SEH.  No SE handler may reside in this image</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DLLCHARACTERISTICS_NO_BIND      0x0800     <span class="comment">// Do not bind this image.</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DLLCHARACTERISTICS_APPCONTAINER 0x1000     <span class="comment">// Image should execute in an AppContainer</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DLLCHARACTERISTICS_WDM_DRIVER   0x2000     <span class="comment">// Driver uses WDM model</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DLLCHARACTERISTICS_GUARD_CF     0x4000     <span class="comment">// Image supports Control Flow Guard.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE     0x8000</span></span><br></pre></td></tr></table></figure>

<p>이 중 DllMain() 정의시 아래의 대응 관계처럼 이 진입점 함수의 파라미터로 넘어오는 fdwReason의 가능한 네가지 값과 동일한 위상이라고 볼 수 있어요.</p>
<ul>
<li>IMAGE_LIBRARY_PROCESS_INIT &lt; - &gt; DLL_PROCESS_ATTACH</li>
<li>IMAGE_LIBRARY_PROCESS_TERM &lt; - &gt; DLL_PROCESS_DEATCH</li>
<li>IMAGE_LIBRARY_THREAD_INIT &lt; - &gt; DLL_THREAD_ATTACH</li>
<li>IMAGE_LIBRARY_THREAD_TERM &lt; - &gt; DLL_PROCESS_DETACH</li>
</ul>
<p>하지만 이 필드의 값은 EXE의 경우에도 0이며, DLL의 경우에도 0이에요.<br>MS는 위의 예약어에 해당하는 네 가지 플래그를 더이상 사용하지 않고 IMAGE_DLLCHARACTERISTIC_XXX 라는 플래그들을 추가했어요.</p>
<ul>
<li><p>IMAGE_DLLCHARACTERISTICS_NO_SEH ( 0x0400)</p>
<blockquote><p>구조적 예외 핸들링(SEH, Structured Exception Handling)을 사용하지 않는다. 구조적 예외 핸들링은 Win32 시스템에서 제공하는 기능(C++ 에서의 try{…}catch(…){…{ 예외 제어 구문과 비슷한 기능)이다.</p>
<p>Visual C++ 컴파일러의 경우 이 SEH를 지원하기 위해 <strong>try{…}</strong>except(…){…} 라는 키워드를 제공한다. 이 플래그의 경우 VC++ 6.0에서는 지원하지 않음.</p>
</blockquote>
</li>
<li><p>IMAGE_DLLCHARACTERISTICS_NO_BIND ( 0x0800)</p>
<blockquote><p>이 플래그는 이 이미지를 바인딩하지 않음을 의미함. VC++ 6.0 에서는 없는 정의</p>
</blockquote>
</li>
<li><p>IMAGE_DLLCHARACTERISTICS_WDM_DRIVER ( 0x2000)</p>
<blockquote><p>드라이버가 WDM 모델을 사용한다는 의미. WDM은 Windows Driver Model의 약자로서 모든 Microsoft Windows 운영체제에 걸쳐서 호환 가능한 소스코드로 구성되는 디바이스 드라이버를 작성할 수 있도록 소개된 모델임.</p>
<p>WDM 룰을 따르는 커널 모드 드라이버를 WDM 드라이버라고 부름. DDK의 서브셋의 일종임.</p>
</blockquote></li>
<li><p>IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE ( 0x8000)</p>
<blockquote><p>이 플래그는 터미널 서버가 터미널 서비스가 인식하지 못하는 애플리케이션을 로드시켰을 경우 실행 가능하도록 하기 위해 호환 가능한 코드를 담고 있는 DLL도 같이 로드시킬 수 있음을 의미함.</p>
</blockquote>

</li>
</ul>
<br>

<h3 id="스물-다섯-번째-멤버-DWORD-SizeOfStackReserver"><a href="#스물-다섯-번째-멤버-DWORD-SizeOfStackReserver" class="headerlink" title="스물 다섯 번째 멤버, DWORD SizeOfStackReserver"></a>스물 다섯 번째 멤버, DWORD SizeOfStackReserver</h3><h3 id="스물-여섯-번째-멤버-DWORD-SizeOfStackCommit"><a href="#스물-여섯-번째-멤버-DWORD-SizeOfStackCommit" class="headerlink" title="스물 여섯 번째 멤버, DWORD SizeOfStackCommit"></a>스물 여섯 번째 멤버, DWORD SizeOfStackCommit</h3><h3 id="스물-일곱-번째-멤버-DWORD-SizeOfHeapReserve"><a href="#스물-일곱-번째-멤버-DWORD-SizeOfHeapReserve" class="headerlink" title="스물 일곱 번째 멤버, DWORD SizeOfHeapReserve"></a>스물 일곱 번째 멤버, DWORD SizeOfHeapReserve</h3><h3 id="스물-여덟-번째-멤버-DWORD-SizeOfHeapCommit"><a href="#스물-여덟-번째-멤버-DWORD-SizeOfHeapCommit" class="headerlink" title="스물 여덟 번째 멤버, DWORD SizeOfHeapCommit"></a>스물 여덟 번째 멤버, DWORD SizeOfHeapCommit</h3><p>프로세스는 가상 주소 공간에 자신만의 스택과 힙을 별도로 가져요.<br>프로세스 생성 시 시스템은 언제나 메인 스레드를 위한 디폴트 스택과 프로세스를 위한 디폴트 힙을 해당 프로세스 내에 생성 시켜 주는데, 이 <strong>스택과 힘의 크기와 속성에 관계된 설정</strong>을 이 필드에서 지정해요.</p>
<p>PE 파일의 경우 로드되면서 하나의 프로세스가 되든지, DLL 이라면 특정 프로세스의 주소 공간 내부에 잠입해 들어가게 되는데요.<br>이때 <strong>스택과 힙의 예약 크기와 커밋 크기를 지정</strong>해줄 수 있어요.</p>
<p>PE 파일이 메모리에 로드될 때 시스템은 이 필드들의 값을 참조하여 해당 프로세스에 디폴트 스택과 디폴트 힙을 만들어 줘요.</p>
<p><strong>링커가 만들어낸 디폴트 값은 스택과 힙 모두 예약 크기 1M인 0x00100000 이며 커밋 크기는 1페이지에 해당하는 4K인 0x00001000</strong>이에요.</p>
<br>

<h3 id="스물-아홉-번째-멤버-DWORD-LoaderFlags"><a href="#스물-아홉-번째-멤버-DWORD-LoaderFlags" class="headerlink" title="스물 아홉 번째 멤버, DWORD LoaderFlags"></a>스물 아홉 번째 멤버, DWORD LoaderFlags</h3><p>이 필드는 0으로 설정이되요. 원래 목적은 디버깅 지원에 관계 되었다고 해요.</p>
<br>

<h3 id="서른-번째-멤버-DWORD-NumberOfRvaAndSizes"><a href="#서른-번째-멤버-DWORD-NumberOfRvaAndSizes" class="headerlink" title="서른 번째 멤버, DWORD NumberOfRvaAndSizes"></a>서른 번째 멤버, DWORD NumberOfRvaAndSizes</h3><p>이 필드는 바로 다음에 나올 주요 섹션들과 정보들의 위치와 크기를 나타내는  <strong>IMAGE_DATA_DIRECTORY 구조체 배열의 원소 개수를 의미</strong>해요.<br>책 에서는 이 구조체의 개수는 항상 16라서, 이 멤버의 값은 언제나 0x00000010 이라고 해요.</p>
<p><strong>하지만 공식 문서에서 항상 그렇지 않다고 해요. 따라서 IMAGE_DATA_DIRECTORY 구조체 배열의 개수를 알기 위해서는 이 멤버의 값을 확인 해야 되요.</strong></p>
<br>

<h2 id="마지막으로…"><a href="#마지막으로…" class="headerlink" title="마지막으로…"></a>마지막으로…</h2><p>IMAGE_OPTIONAL_HEADER에서 기억하고 가야할 멤버들은 <strong>AddressOfEntryPoint, ImageBase, SectionAlignment, FileAlignment, SizeOfImage, NumberOfRvaAndSizes</strong> 라고 생각해요.</p>
<p><strong>AddressOfEntryPoint</strong>는 OP의 주소 값이 들어가고,<br><strong>ImageBase</strong>는 가상 주소 공간에 매핑될 때, 매핑시키고자 하는 메모리 상의 주소 값이고,<br><strong>SectionAlignment</strong>는 메모리에 매핑될 때, 섹션의 크기를 확인할 때 사용하는 녀석이고,<br><strong>FileAlignemt</strong>는 파일 내에서, 섹션의 크기를 확인할 때 사용하는 녀석이고,<br><strong>SizeOfImage</strong>는 PE 파일을 메모리 상에 로드할 때 확보해야할 크기 값을 가지고 있는 녀석이고,<br><strong>NumberOfRvaAndSizes</strong>는 PE 파일 안에 있는 섹션들의 위치와 크기를 나타내는 녀석이므로 기억해야 한다고 생각해요!</p>
<br>
<br>
<br>
<br>
<br>

<h2 id="참고자료"><a href="#참고자료" class="headerlink" title="참고자료"></a>참고자료</h2><hr>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_optional_header64" target="_blank" rel="noopener">IMAGE_OPTIONAL_HEADER</a></p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://777bareman777.github.io/2019/09/18/UnderstandPE3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="777bareman777">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="777bareman777 Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/09/18/UnderstandPE3/" class="post-title-link" itemprop="url">PE 구조 이해하기 - IMAGE_FILE_HEADER 구조</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-09-18 01:02:50" itemprop="dateCreated datePublished" datetime="2019-09-18T01:02:50+09:00">2019-09-18</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-01-17 07:14:53" itemprop="dateModified" datetime="2020-01-17T07:14:53+09:00">2020-01-17</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/PE-file/" itemprop="url" rel="index"><span itemprop="name">PE file</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/PE-file/Windows-Reversing/" itemprop="url" rel="index"><span itemprop="name">Windows Reversing</span></a></span>

                
                
              
            </span>
          

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
        
      
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2019/09/18/UnderstandPE3/#comments" itemprop="discussionUrl"><span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/09/18/UnderstandPE3/" itemprop="commentCount"></span></a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>windows 시스템 실행파일의 구조와 원리 책 내용을 요약 및 정리 하는 포스팅이에요.</p>
<p>PE파일의 PE 시그니처 다음에 이어지는 <strong>IMAGE_FILE_HEADER</strong>에 대한 내용을 알아볼 거에요.</p>
<br>

<h2 id="IMAGE-FILE-HEADER-구조체"><a href="#IMAGE-FILE-HEADER-구조체" class="headerlink" title="IMAGE_FILE_HEADER 구조체"></a>IMAGE_FILE_HEADER 구조체</h2><p><strong>IMAGE_FILE_HEADER</strong> 구조체는 <strong>20바이트</strong>로 구성이 되어 있어요.<br>이것도 당연히 “WinNT.h” 헤더 파일에 정의되어 있어요.</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _IMAGE_FILE_HEADER &#123;</span><br><span class="line">  <span class="type">WORD</span>  <span class="type">Machine</span>;</span><br><span class="line">  <span class="type">WORD</span>  <span class="type">NumberOfSections</span>;</span><br><span class="line">  <span class="type">DWORD</span> <span class="type">TimeDateStamp</span>;</span><br><span class="line">  <span class="type">DWORD</span> <span class="type">PointerToSymbolTable</span>;</span><br><span class="line">  <span class="type">DWORD</span> <span class="type">NumberOfSymbols</span>;</span><br><span class="line">  <span class="type">WORD</span>  <span class="type">SizeOfOptionalHeader</span>;</span><br><span class="line">  <span class="type">WORD</span>  <span class="type">Characteristics</span>;</span><br><span class="line">&#125; <span class="type">IMAGE_FILE_HEADER</span>, *<span class="type">PIMAGE_FILE_HEADER</span>;</span><br></pre></td></tr></table></figure>

<p>구조체 멤버에 대해 하나씩 설명을 해드릴게요.</p>
<br>

<h3 id="첫-번째-멤버-WORD-Machine"><a href="#첫-번째-멤버-WORD-Machine" class="headerlink" title="첫 번째 멤버, WORD Machine"></a>첫 번째 멤버, WORD Machine</h3><p>Machine 필드는 PE 파일의 CPU ID를 나타내요. 즉, 사용자가 <strong>어떤 CPU를 통해서 PE 파일을 생성했는지 알 수 있어요</strong>.</p>
<p>C언어와 C++로 짜여진 코드 같은 경우에는 CPU 의존적이라서 이런 정보가 들어가 있나봐요.</p>
<p>이것도 CPU ID에 해당하는 매크로 상수가 정의되어 있는데, 자주 사용되는 매크로 상수는 아래와 같아요</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_IA64              0x0200  <span class="comment">// Intel 64</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_AMD64             0x8664  <span class="comment">// AMD64 (K8)</span></span></span><br></pre></td></tr></table></figure>

<br>

<h3 id="두-번째-멤버-WORD-NumberOfSections"><a href="#두-번째-멤버-WORD-NumberOfSections" class="headerlink" title="두 번째 멤버, WORD NumberOfSections"></a>두 번째 멤버, WORD NumberOfSections</h3><p><strong>PE 파일에서의 섹션의 수</strong>를 나타내요. IMAGE_SECTION_HEADER 구조체 배열의 원소의 개수. 즉, 해당 PE 파일의 섹션의 개수를 의미해요.</p>
<br>

<h3 id="세-번째-멤버-DWORD-TimeDateStamp"><a href="#세-번째-멤버-DWORD-TimeDateStamp" class="headerlink" title="세 번째 멤버, DWORD TimeDateStamp"></a>세 번째 멤버, DWORD TimeDateStamp</h3><p>OBj 파일이라면 컴파일러가, EXE 또는 DLL과 같은 PE 파일이라면 링커가 해당 <strong>파일을 만들어낸 시간</strong>을 의미해요.</p>
<p>이 값은 1970년 1월 1일 09시(GMT 시간 기준)로부터 해당 파일을 만들어낸 시점까지의 초 단위로 표현해요.</p>
<br>

<h3 id="네-번째-멤버-DWOARD-PointerToSymbolTable"><a href="#네-번째-멤버-DWOARD-PointerToSymbolTable" class="headerlink" title="네 번째 멤버, DWOARD PointerToSymbolTable"></a>네 번째 멤버, DWOARD PointerToSymbolTable</h3><p>PointerToSymbolTable 필드는 말 그대로 심볼 테이블의 데이터를 가리키는 주소 값이 들어가는 영역이에요. 즉, <strong>COFF 심벌의 파일 오프셋 값</strong>을 가지고 있는 거에요.</p>
<p><strong>이 필드 같은 경우에는 컴파일러에 의해 생성되는 OBJ 파일 또는 디버그 모드로 만들어져서 COFF 디버그 정보를 가진 PE 파일에서만 사용이 되요.</strong></p>
<p>PE 파일은 복수의 디버그 포맷을 지원하기 떄문에 IMAGE_DIRECTORY_ENTRY_DEBUG 엔트리를 참조해야 되고요.</p>
<p><em>요즘에는 COFF 심벌 테이블은 새로운 디버그 포맷에 의해 대체되어서 PE 파일 내에서는 거의 사용하지 않아요.</em><br>물론 링커 스위치를 /DEBUGTYPE:COFF로 지정할 경우 생성할 수 있어요.</p>
<br>

<h3 id="다섯-번째-멤버-DOWRD-NumberOfSymbols"><a href="#다섯-번째-멤버-DOWRD-NumberOfSymbols" class="headerlink" title="다섯 번째 멤버, DOWRD NumberOfSymbols"></a>다섯 번째 멤버, DOWRD NumberOfSymbols</h3><p><strong>PointerToSymbolTable 필드가 가리키는 COFF 심벌 테이블 내에서의 심벌의 수</strong>를 나타냄.</p>
<p><em>이것도 마찬가지로 새로운 디버그 포맷에 의해 대체되어서 사용되지 않음.</em></p>
<br>

<h3 id="여섯-번째-멤버-WORD-SizeOfOptionalHeader"><a href="#여섯-번째-멤버-WORD-SizeOfOptionalHeader" class="headerlink" title="여섯 번째 멤버, WORD SizeOfOptionalHeader"></a>여섯 번째 멤버, WORD SizeOfOptionalHeader</h3><p>IMAGE_FILE_HEADER 구조체 바로 다음에 이어서 나오는 <strong>IMAGE_OPTIONAL_HEADER 구조체의 바이트 수</strong>를 나타내요. </p>
<p>이 필드는 OBJ 파일의 경우 0이고, 실행 파일의 경우는 “sizeof(IMAGE_OPTIONAL_HEADER)”의 값을 가져요.</p>
<p>32비트 PE 파일의 경우 0xE0(224)바이트이고, 64비트 PE 파일의 경우 0xF0(240)바이트에요.</p>
<br>

<h3 id="일곱-번째-멤버-WORD-Characteristics"><a href="#일곱-번째-멤버-WORD-Characteristics" class="headerlink" title="일곱 번째 멤버, WORD Characteristics"></a>일곱 번째 멤버, WORD Characteristics</h3><p><strong>PE 파일에 대한 특정 정보를 나타내는 플래그</strong>에요. 이 필드도 “WinNT.h” 헤더 파일에 정의되어 있어요.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_RELOCS_STRIPPED           0x0001  <span class="comment">// Relocation info stripped from file.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_EXECUTABLE_IMAGE          0x0002  <span class="comment">// File is executable  (i.e. no unresolved external references).</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_LINE_NUMS_STRIPPED        0x0004  <span class="comment">// Line nunbers stripped from file.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_LOCAL_SYMS_STRIPPED       0x0008  <span class="comment">// Local symbols stripped from file.</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_AGGRESIVE_WS_TRIM         0x0010  <span class="comment">// Aggressively trim working set</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_LARGE_ADDRESS_AWARE       0x0020  <span class="comment">// App can handle &gt;2gb addresses</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_BYTES_REVERSED_LO         0x0080  <span class="comment">// Bytes of machine word are reversed.</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_32BIT_MACHINE             0x0100  <span class="comment">// 32 bit word machine.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_DEBUG_STRIPPED            0x0200  <span class="comment">// Debugging info stripped from file in .DBG file</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP   0x0400  <span class="comment">// If Image is on removable media, copy and run from the swap file.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_NET_RUN_FROM_SWAP         0x0800  <span class="comment">// If Image is on Net, copy and run from the swap file.</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_SYSTEM                    0x1000  <span class="comment">// System File.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_DLL                       0x2000  <span class="comment">// File is a DLL.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_UP_SYSTEM_ONLY            0x4000  <span class="comment">// File should only be run on a UP machine</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_BYTES_REVERSED_HI         0x8000  <span class="comment">// Bytes of machine word are reversed.</span></span></span><br></pre></td></tr></table></figure>

<p>이 중에서도 중요한 것은 요것들이에요.</p>
<table>
<thead>
<tr>
<th>매크로명</th>
<th>값</th>
<th>의미</th>
</tr>
</thead>
<tbody><tr>
<td>IMAGE_FILE_RELOCS_STRIPPED</td>
<td>0x0001</td>
<td>현재 파일에 재배치 정보가 없음</td>
</tr>
<tr>
<td>IMAGE_FILE_EXECUTABLE_IMAGE</td>
<td>0x0002</td>
<td>본 파일은 실행 파일 이미지이다.</td>
</tr>
<tr>
<td>IMAGE_FILE_LINE_NUMS_STRIPPED</td>
<td>0x0004</td>
<td>본 파일에 라인 정보가 없다.</td>
</tr>
<tr>
<td>IMAGE_FILE_LOCAL_SYMS_STRIPPED</td>
<td>0x0008</td>
<td>본 파일에 로컬 심벌이 없다.</td>
</tr>
<tr>
<td>IMAGE_FILE_AGGRESIVE</td>
<td>0x0010</td>
<td>OS로 하여금 적극적으로 워킹셋을 정리할 수 있도록 한다</td>
</tr>
<tr>
<td>IMAGE_FILE_LARGE_ADD_RESS_AWARE</td>
<td>0x0020</td>
<td>애플리케이션이 2G 이상의 가상 주소 번지를 제어할 수 있도록한다.</td>
</tr>
<tr>
<td>IMAGE_FILE_32BIT_MACHINE</td>
<td>0x0100</td>
<td>본 PE는 32비트 워드 머신을 필요로 한다.</td>
</tr>
<tr>
<td>IMAGE_FILE_DEBUG_STRIPPED</td>
<td>0x0200</td>
<td>디버그 정보가 본 파일에는 없고 .DBG 파일에 존재한다.</td>
</tr>
<tr>
<td>IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP</td>
<td>0x0400</td>
<td>PE 이미지가 이동 가능한 장치 위에 존재할 때 고정 디스크 상의 스왑 파일로 카피해서 실행한다.</td>
</tr>
<tr>
<td>IMAGE_FILE_NET_RUN_FROM_SWAP</td>
<td>0x0800</td>
<td>PE 이미지가 네트워크 상에 존재할 때 고정 디스크 상의 스왑 파일로 카피해서 실행한다.</td>
</tr>
<tr>
<td>IMAGE_FILE_DLL</td>
<td>0x2000</td>
<td>본 파일은 동적 링크 라이브러리 파일이다.</td>
</tr>
<tr>
<td>IMAGE_FILE_UP_SYSTEM_ONLYT</td>
<td>0x4000</td>
<td>본 파일은 하나의 프로세서만을 장착한 머신에서 실행된다.</td>
</tr>
</tbody></table>
<br>

<h2 id="마지막으로…"><a href="#마지막으로…" class="headerlink" title="마지막으로…"></a>마지막으로…</h2><p>IMAGE_FILE_HEADER에 대해서 살펴봤는데요.<br><strong>여기서 중요한 멤버들은 섹션의 수를 조절할 수 있는 NumberOfSections 하고, PE 파일에 대한 특정 정보는 나타내는 플래그인 Characteristics</strong> 이에요.</p>
<p>NumberOfSections을 조절하면, 우리가 원하는대로 임의의 섹션을 추가할 수 있어요. 이러한 방법을 이용해서 악성코드를 삽입도 가능하다고 해요!</p>
<p>PE 파일에 특정 정보를 나타내는 플래그인 Characteristics 값의 조합을 알고 있으면, PE 파일을 분석할 필요 없이 이 값만을 가지고 PE 파일이 어떤 특징을 가지고 있는지 알 수 있을 거에요.</p>
<br>
<br>
<br>
<br>
<br>

<h2 id="참고자료"><a href="#참고자료" class="headerlink" title="참고자료"></a>참고자료</h2><hr>
<p><a href="https://docs.microsoft.com/ko-kr/windows/win32/api/winnt/ns-winnt-image_file_header" target="_blank" rel="noopener">IMAGE_FILE_HEADER</a></p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://777bareman777.github.io/2019/09/18/UnderstandPE2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="777bareman777">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="777bareman777 Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/09/18/UnderstandPE2/" class="post-title-link" itemprop="url">PE 구조 이해하기 - IMAGE_NT_HEADERS 구조</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-09-18 00:43:45" itemprop="dateCreated datePublished" datetime="2019-09-18T00:43:45+09:00">2019-09-18</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-09-24 09:13:29" itemprop="dateModified" datetime="2019-09-24T09:13:29+09:00">2019-09-24</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/PE-file/" itemprop="url" rel="index"><span itemprop="name">PE file</span></a></span>

                
                
              
            </span>
          

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
        
      
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2019/09/18/UnderstandPE2/#comments" itemprop="discussionUrl"><span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/09/18/UnderstandPE2/" itemprop="commentCount"></span></a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>windows 시스템 실행파일의 구조와 원리 책 내용을 요약 및 정리 하는 포스팅이에요.</p>
<p>PE파일의 맨 앞부분에 해당하는 <strong>IMAGE_NT_HEADER</strong>에 대한 알아볼 거에요.</p>
<p>이 부분은 내용이 길어서 여기서는 간단한 구조체 설명만 할거에요.</p>
<br>

<h2 id="PE-파일의-시작"><a href="#PE-파일의-시작" class="headerlink" title="PE 파일의 시작"></a>PE 파일의 시작</h2><p>IMAGE_NT_HEADER은 진정한 PE파일의 시작을 알리는 신호이면서, PE에 관계된 많은 부분을 담고 있어요.</p>
<p>이것도 마찬가지로 IMAGE_NT_HEADER도 “WinNT.h” 헤더 파일에 정의되어 있어요.</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _IMAGE_NT_HEADERS</span><br><span class="line">&#123;</span><br><span class="line">	DWORD Signature<span class="comment">;</span></span><br><span class="line">	IMAGE_FILE_HEADER FileHeader<span class="comment">;</span></span><br><span class="line">	IMAGE_OPTIONAL_HEADER32 OptionalHeader<span class="comment">;</span></span><br><span class="line">&#125; IMAGE_NT_HEADER32, *PIMAGE_NT_HEADER32<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>여기서 DWORD 형인 Signature 필드는 PE 파일을 나타내는 매직넘버에요. 이 값도 마찬가지로 “WinNT.h” 헤더 파일에 정의되어 있어요.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DOS_SIGNATURE                 0x5A4D      <span class="comment">// MZ</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_OS2_SIGNATURE                 0x454E      <span class="comment">// NE</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_OS2_SIGNATURE_LE              0x454C      <span class="comment">// LE</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_VXD_SIGNATURE                 0x454C      <span class="comment">// LE</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_NT_SIGNATURE                  0x00004550  <span class="comment">// PE00</span></span></span><br></pre></td></tr></table></figure>

<br>

<h3 id="PE-파일임을-확인하는-방법"><a href="#PE-파일임을-확인하는-방법" class="headerlink" title="PE 파일임을 확인하는 방법?"></a>PE 파일임을 확인하는 방법?</h3><p>PE 파일을 확인하는 방법은 아주 간단해요.<br>IMAGE_DOS_HEADER 구조체의 마지막 필드인 e_lfanew가 가리키는 값만큼 파일 포인터를 이동시켜 그 오프셋부터 DWORD형으로 값을 읽고, 그 값을 IMAGE_NT_SIGNAUTRE 매크로 상수와 비교하기만 하면 되요.</p>
<br>

<h2 id="마지막으로…"><a href="#마지막으로…" class="headerlink" title="마지막으로…"></a>마지막으로…</h2><p>IMAGE_NT_HEADER 구조체는 <strong>매직넘버 필드</strong>뿐만 아니라, PE에 관계된 부분을 설명해주는 다른 구조체들도 포함되어 있어요. <strong>IMAGE_FILE_HEADER</strong> 와 <strong>IMAGE_OPTIONAL_HEADER</strong> 에요.</p>
<p>여기서는 <strong>IMAGE_NT_HEADERS</strong> 중에서 32비트용 <strong>IMAGE_NT_HEADER32</strong>를 설명을 했어요. 64비트용 <strong>IMAGE_NT_HEADER64</strong>도 있다는 것을 잊지 마세요!<br>그리고 이 구조체에 필드로 들어있는 <strong>IMAGE_OPTIONAL_HEADERS</strong> 도 32비트용인 <strong>IMAGE_OPTIONAL_HEADER32</strong>, 64비트용인 <strong>IMAGE_OPTIONAL_HEADER64</strong>가 있어요.</p>
<p>32비트용과 64비트용은 별다른 차이가 없어요.<br>대부분의 구조가 거의 같기 때문에 32비트용을 완벽하게 이해하고 차후에 64비트용에서 쓰이는 부분과 바뀐 부분만 체크하면 되요</p>
<br>
<br>
<br>
<br>
<br>

<h2 id="참고자료"><a href="#참고자료" class="headerlink" title="참고자료"></a>참고자료</h2><hr>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_nt_headers32" target="_blank" rel="noopener">IMAGE_NT_HEADER32</a><br><a href="https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_nt_headers64" target="_blank" rel="noopener">IMAGE_NT_HEADER64</a></p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://777bareman777.github.io/2019/09/17/UnderstandPE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="777bareman777">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="777bareman777 Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/09/17/UnderstandPE/" class="post-title-link" itemprop="url">PE 구조 이해하기 - IMAGE_DOS_HEADER 구조</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-09-17 16:09:44" itemprop="dateCreated datePublished" datetime="2019-09-17T16:09:44+09:00">2019-09-17</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-09-24 09:13:30" itemprop="dateModified" datetime="2019-09-24T09:13:30+09:00">2019-09-24</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/PE-file/" itemprop="url" rel="index"><span itemprop="name">PE file</span></a></span>

                
                
              
            </span>
          

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
        
      
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2019/09/17/UnderstandPE/#comments" itemprop="discussionUrl"><span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/09/17/UnderstandPE/" itemprop="commentCount"></span></a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>windows 시스템 실행파일의 구조와 원리 책 내용을 요약 및 정리 하는 포스팅이에요.</p>
<p>PE파일의 맨 앞부분에 해당하는 <strong>DOS 스텁</strong>에 대한 내용을 알아볼 거에요.</p>
<br>

<h2 id="DOS-스텁의-시작"><a href="#DOS-스텁의-시작" class="headerlink" title="DOS 스텁의 시작"></a>DOS 스텁의 시작</h2><p>PE 파일은 몇십 바이트의 MS-DOS 스텁으로 시작 하고, MS-DOS 스텁은 예전의 MS-DOS 시절때의 MZ 포맷으로 PE 포맷에서는 큰 의미가 없다고 해요.</p>
<p>MS-DOS 스텁은 PE 파일을 도스 환경에서 실행 시킬 때 “This program cannot be run in DOS mode” 라는 문장을 출력하기 위한 조그마한 16비트 도스용 응용 프로그램에 불과해요.<br>그리고 DOS 스텁은 40바이트의 IMAGE_DOS_HEADER 구조체와 해당 프로그램 코드로 이루어져 있어요. </p>
<br>

<h3 id="IMAGE-DOS-HEADER-구조체"><a href="#IMAGE-DOS-HEADER-구조체" class="headerlink" title="IMAGE_DOS_HEADER 구조체"></a>IMAGE_DOS_HEADER 구조체</h3><p>IMAGE_DOS_HEADER 구조체는 “WinNT.h” 헤더 파일에 정의되어 있다고 해요.</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _IMAGE_DOS_HEADER <span class="regexp">//</span> DOS .EXE header</span><br><span class="line">&#123;</span><br><span class="line">    WORD e_magic;       <span class="regexp">//</span> Magic number</span><br><span class="line">    WORD e_cblp;        <span class="regexp">//</span> Byte on last page of file</span><br><span class="line">    WORD e_cp;          <span class="regexp">//</span> Pages <span class="keyword">in</span> file</span><br><span class="line">    WORD e_crlc;        <span class="regexp">//</span> Relocations</span><br><span class="line">    WORD e_cparhdr;     <span class="regexp">//</span> Size of header <span class="keyword">in</span> paragraphs</span><br><span class="line">    WORD e_minalloc;    <span class="regexp">//</span> Minimum extra paragraphs needed</span><br><span class="line">    WORD e_maxalloc;    <span class="regexp">//</span> Maximum extra paragraphs needed</span><br><span class="line">    WORD e_ss;          <span class="regexp">//</span> Initial (relative) SS value</span><br><span class="line">    WORD e_sp;          <span class="regexp">//</span> Checksum</span><br><span class="line">    WORD e_ip;          <span class="regexp">//</span> Initital IP value</span><br><span class="line">    WORD e_cs;          <span class="regexp">//</span> Initial (relative) CS value</span><br><span class="line">    WORD e_lfarlc;      <span class="regexp">//</span> File address of relocation table</span><br><span class="line">    WORD e_ovno;        <span class="regexp">//</span> Overlay number</span><br><span class="line">    WORD e_res[<span class="number">4</span>];      <span class="regexp">//</span> Reserved words</span><br><span class="line">    WORD e_oemid;       <span class="regexp">//</span> OEM identifier (<span class="keyword">for</span> e_oeminfo)</span><br><span class="line">    WORD e_oeminfo;     <span class="regexp">//</span> OEM information; e_oemid specific</span><br><span class="line">    WORD e_res2[<span class="number">10</span>];    <span class="regexp">//</span> Reserved words</span><br><span class="line">    LONG e_lfanew;      <span class="regexp">//</span> File address of new exe header</span><br><span class="line">&#125; IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;</span><br></pre></td></tr></table></figure>

<p>IMAGE_DOS_HEADER 구조체는 64바이트로 구성되어 있어요.<br>PE 파일에서 0x0000003F 까지가 IMAGE_DOS_HEADER 구조체에요.<br>이 구조체에서 실제로 쓸모가 있는 것은 <strong>첫 번쨰 필드인 e_magic과 마지막 필드인 e_lfanew</strong> 이에요. 그 이외에 나머지는 사용되지 않아요.</p>
<br>

<h2 id="첫-번째-필드인-e-magic"><a href="#첫-번째-필드인-e-magic" class="headerlink" title="첫 번째 필드인 e_magic"></a>첫 번째 필드인 e_magic</h2><p>모든 PE 파일은 IMAGE_DOS_HEADER로 시작해요.<br>이때 e_magic은 <strong>ASCII “MZ”</strong> 로 고정되어 있어요. 위 구조체에서는 e_magic WORD 형으로 되어 있는데, “MZ”을 워드로 읽게 되면 <strong>0x5A4D</strong>가 되요.</p>
<p>여기서 0x5A=’Z’, 0x4D=’M’ 에 해당해요.<br>인텔 cpu 같은 경우에는 리틀 엔디번 방식으로 메모리를 정렬하기 때문에 0x5A4D로 값을 저장하게 되요.</p>
<p>이러한 “MZ”도 “WinNT.h” 헤더 파일에 매크로로 정의되어 있어요.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DOS_SIGNATURE 0x5A4D <span class="comment">// MZ</span></span></span><br></pre></td></tr></table></figure>

<br>

<h2 id="마지막-필드인-e-lfanew"><a href="#마지막-필드인-e-lfanew" class="headerlink" title="마지막 필드인 e_lfanew"></a>마지막 필드인 e_lfanew</h2><p>IMAGE_DOS_HEADER 구조체에서 <strong>e_flanew</strong> 필드에는 실제 PE 파일의 시작이라고 할 수 있는 <strong>IMAGE_NT_HEADER 시작 오프셋 값</strong>을 가진다고 해요.</p>
<p>예를 들어서 DWORD 형으로 정의된 e_flanew의 값이 0x000000F0 이라면, 실제 PE 파일의 시작은 0x000000F0 이고, 여기서 PE 파일의 시그니쳐인 “PE”를 볼 수 있어요.</p>
<br>

<h2 id="마지막으로…"><a href="#마지막으로…" class="headerlink" title="마지막으로…"></a>마지막으로…</h2><p>IMAGE_DOS_HEADER 와 DOS 스텁은 MS-DOS 시절의 유산물이에요. 우리는 여기서 PE 파일내에서 사용하지 않는 부분이 있다는 것을 알았어요. 앞으로도 PE 파일내에서 사용하지 않는 부분이 존재할거에요. 그리고 이러한 부분들을 이용해서 패커 같은 것을 구현해서 PE 파일의 크기를 줄이고, 리버싱을 하기 어렵게 만들었다고 해요!!</p>
<p>우리가 <strong>IMAGE_DOS_HEADER에서 e_magic의 값이 0x5A4D</strong> 이어야지 PE 파일이라는 것을 알 수 있다는 사실과 <strong>e_lfanew의 값에 따라서 IMAGE_NT_HEADER의 시작 오프셋 값</strong>을 알 수 있다는 것만 알면 되요.</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://777bareman777.github.io/2019/09/16/HamsterBreddingDiary/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="777bareman777">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="777bareman777 Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/09/16/HamsterBreddingDiary/" class="post-title-link" itemprop="url">햄스터 기르기 일지 - 기본편</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-09-16 01:50:23" itemprop="dateCreated datePublished" datetime="2019-09-16T01:50:23+09:00">2019-09-16</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-09-19 22:04:20" itemprop="dateModified" datetime="2019-09-19T22:04:20+09:00">2019-09-19</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/hamster/" itemprop="url" rel="index"><span itemprop="name">hamster</span></a></span>

                
                
              
            </span>
          

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
        
      
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2019/09/16/HamsterBreddingDiary/#comments" itemprop="discussionUrl"><span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/09/16/HamsterBreddingDiary/" itemprop="commentCount"></span></a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>어젯밤에 이마트에서 햄스터를 <strong>봤는데</strong>, 너무 귀여운거 있죠<br>그 중에서 가장 유독 눈이 띄는 아이가 있었어요.<br>다른 아이들은 친구들과 놀고 있는데, 펄 햄스터라고 불리는 아이 한명이 계속 잠만 자고 있는 거에요.<br>이 친구가 내 맘을 흔들더라고요.</p>
<p>지금 당장 데리고 가고 싶었는데, 지금은 분양 받을 수 없다고 하더라고요.<br>그 떄 시간이 오후 10시 30분이었으니까… ㅎㅎㅎ<br>데려갈 수 없었던게 당연한 걸지도 몰라요.<br>덕분에 햄스터를 키우는 데 필요한 용품들을 더 자세하게 찾아보게 되었어요.<br>천만다행이었죠!!<br>그때 햄스터를 데리고 왔다면, 햄스터는 좋은 환경에서 살지도 못하고, 스트레스를 받았을 거에요</p>
<p>아 그리고 다음날 데리고 왔는데, 아라찌(햄스터)가 은신처에서 잠을 자고 있는데, 관리 하시는 분이 오셔서 은신처에서 쉬고 있는 얘를 탁탁 털어서 꺼내더라고요. 순간 가슴이 철렁했답니다.</p>
<br>

<h2 id="햄스터에게-필요한-것들"><a href="#햄스터에게-필요한-것들" class="headerlink" title="햄스터에게 필요한 것들"></a>햄스터에게 필요한 것들</h2><p>너무 데리고 데리고 가고 싶어서, 필요한 것들을 이것저것 찾아 봤어요.<br>햄스터를 기르는데 필수적으로 있어야 하는 것들은<br><strong>햄스터 케이지</strong>, <strong>햄스터 집</strong>, <strong>쳇바퀴</strong>, <strong>급수기</strong>, <strong>급식기</strong>, <strong>베딩</strong>, <strong>밥</strong> 이라고 해요. 일단은 이렇게 7가지가 필수적으로 있어야 된다고 해요.</p>
<p>그 중 가장 중요한 것은 햄스터 케이지에요!</p>
<br>

<h3 id="햄스터-케이지"><a href="#햄스터-케이지" class="headerlink" title="햄스터 케이지"></a>햄스터 케이지</h3><p>햄스터한테 케이지는 가장 중요한 물품에 속해요.<br>케이지의 크기에 따라서 햄스터의 활동반경이 정해지는 지거든요.</p>
<p>케이지의 종류는 여러가지가 있어요.<br><strong>철장 케이지</strong>, <strong>채집통 케이지</strong>, <strong>수족관 케이지</strong>, <strong>터널형 케이지</strong>, <strong>리빙박스 케이지</strong>이 있어요.</p>
<p>옛날에는 햄스터를 유통될 때, 가장 손쉽게 구할 수 있는 철장 케이지를 많이 사용했다고 해요.<br>요즘은 철장 비스무리한 플라스틱 케이지도 많이 유통이 되는 것 같아요. 이마트에서 이런 비스무리한<br>플라스틱 철장 케이지를 판매를 하고 있어요.</p>
<p>채집통 케이지는 소,중,대 사이즈가 있다고해요.<br>보통 일반적으로 채팁통의 크기는 햄스터를 기르기에는 작다고 해요. 일반적으로 햄스터를 다른 곳으로 이동시킬 떄, 이동장 역할로 많이 사용한다고 해요.</p>
<p>수족관 케이지는 공간이 협소한 우리나라에서는 볼 수 없다고 해요. 보통 일반적으로 서양권에서 볼 수 있다고 해요. 기다란 수족관에다가 햄스터가 살 수 있는 환경을 구성한다고 해요.<br>햄스터들이 완전 기부니가 좋아서 방방 뛸 것 같아요 ㅎㅎ</p>
<p>터널형 케이지는 햄스터들이 굴속에서 삶을 사는 그 환경을 그대로 재현할 수 있다고 해요. 하지만 가격이 비싸고 청소하기도 힘들어서 터널형 케이지는 자주 볼수 없는 케이스라고 합니다.</p>
<p><strong>리빙박스 케이지</strong>는 우리나라에서 요즘에 흔히 볼 수 있는 햄스커 케이지라고 해요. 철장 케이지는 햄스터들이 다칠 수 있을 뿐만 아니라 크기가 커질 수록 가격이 상승하거든요. 수족관 케이스도 마찬가지죠.</p>
<p>그래서 저렴한 리빙박스를 이용해서 햄스터 케이지를 개조하는 경우가 많다고 해요.<br><strong>드워프 햄스터</strong>는 못해도 리빙박스 <strong>55L</strong> 짜리를 구매를 해야 한다고 하고요. <strong>골든 햄스터</strong>는 못해도 <strong>68L</strong> 짜리를 구매를 해야 한다고 해요.</p>
<p>그래서 아라찌(햄스터)를 데리고 올 때, 리빙박스 55L 짜리로 구매를 했어요. 빠르게 데려오고 싶은 마음 때문에 120L 짜리는 구매를 하지 못한게 아쉬워요.<br>대신 차후에 리빙박스에 구멍을 뚫어서 터널을 연결해서 더 큰 공간을 만들어줄 생각이에요!</p>
<br>

<h3 id="햄스터-집"><a href="#햄스터-집" class="headerlink" title="햄스터 집"></a>햄스터 집</h3><p>햄스터 집하고 햄스터 케이지는 다른 거에요. 햄스터를 키울 때, 햄스터의 넓은 활동반경을 조성을 할수가 없어요. 웬만한 부자가 아닌 이상은… 그래서 우리는 타협을 본거에요. 햄스터 케이지를 이만큼의 크기로 햄스터를 기르자. 즉, 햄스터 케이지의 크기는 햄스터의 활동반경의 크기에요.</p>
<p>햄스터 집은 말그대로 자신만의 영역인거에요! 우리도 엄청나게 넓은 지구에서 살아가고 있잖아요. 그리고 자기 자신만의 집이 존재하죠? 햄스터도 마찬가지에요. 햄스터도 집이 필요해요. 즉, 햄스터 집, 은신처를 만들어주는 거에요.</p>
<p>은신처는 2~3개 있으면 좋다고해요. 햄스터들이 번갈아가면서 사용한다고 해요. 은신처에다가 먹이를 보관하기도하고 그런다고 하네요 ㅎㅎ</p>
<br>

<h3 id="쳇바퀴"><a href="#쳇바퀴" class="headerlink" title="쳇바퀴"></a>쳇바퀴</h3><p>다른 햄스터를 키우는 분들이 말씀하시길, 햄스터에게 쳇바퀴를 제공하지 않으면 동물 학대라고 합니다. 무조건 쳇바퀴를 구매를 해야 한다고 하더라고요.</p>
<p>그래서 쳇바퀴에 대해서 찾아봤어요. 싼 가격부터 비싼 가격까지 다양하게 있어요. 당연히 비싼게 가장 좋겠죠? 그렇지만 언제나 비싸고 좋은 제품을 살 수가 없용. 우리도 비싼게 좋다는 것을 알지만 항상 비싼것만 사면서 살지는 않잖아요. 그래서 가성비를 본다고 해요.</p>
<p>쳇바퀴는 <strong>아크릴 쳇바퀴</strong>가 최고봉이라고 해요. 소리도 안나고, 햄스터들이 다칠 이유도 없다고 해요. 하지만 가격이 3만원 이상을 한다고 해요.</p>
<p>저의 개인적인 생각으로는 발빠짐 쳇바퀴류만 아니면 괜찮다고 생각해요. 저는 소음에 민감한 편이 아니라서 햄스터들이 쳇바퀴 돌리는 시간이 짜증이 나지 않거든요. 그리고 돈이 넉넉한 편은 아니라서 가성비를 생각해서 저같은 경우에는 <strong>사일런트 휠</strong>을 구매를 했어요. 이거 같은 경우에는 만원정도에 인터넷에서 구매를 할 수 있어요.</p>
<p>아직 쳇바퀴를 케이지 안에 배치를 못해서… 저는 햄스터를 학대하고 있답니다. ㅠㅠㅠ 쳇바퀴가 배송되자마자 바로 케이지에 넣어줄 거에요</p>
<br>

<h3 id="급수기와-급식기"><a href="#급수기와-급식기" class="headerlink" title="급수기와 급식기"></a>급수기와 급식기</h3><p>급식기 같은 경우에는 다이소에서 파는 자그마한 그릇으로 충분해요. 거기에다가 햄스터의 몸무게의 12% 해당하는 양만 배식하면 된다고 해요. 햄스터도 인간처럼 편식을 하는 동물이라고 해요. 그래서 원하는 것만 먹다보면, 쉽게 우리처럼 비만이 될 수 있다고 하니 음식 조절을 잘 해줘야 된다고 해요 ㅎㅎㅎ</p>
<p>그리고 편식을 하지 않는 햄스터 같은 경우에는 큰 그릇에 하루 분량이 아니라 며칠치 분량을 놓아도 된다고 해요. 햄스터의 습성중 하나가 먹을 것들을 은식처에 숨기는 거라고 해요. 급식기에 먹을 것이 있다면, 햄스터들이 그 자리에서 먹지 않고 볼주머니에 음식을 가득 담고 은신처로 파파팍 가는 모습을 볼 수 있을 거에요.</p>
<p>급수기는 그릇으로 해도 되고, 햄스터용으로 나온 전용 급수기를 사용해도 된다고 해요.<br>급수기는 종류가 여러가지라고 해요. <strong>볼 급수기</strong>, <strong>진공 급수기</strong> 하나 더 있었는데 기억이 안나네요. ㅎㅎ</p>
<p>볼 급수기는 물이 누수가 발생하기도 하는데, 그런 것을 방지하기 위해서 만든게 진공 급수기라고 해요. 그래서 진공 급수기가 볼 급수기보다 비싸죠. 그렇다고 하더라도 그렇게 비싼 금액은 아니에요 ㅎㅎ</p>
<p>그릇 같은 경우는 잘 사용하지 않는다고 해요. 그릇에 베딩이 들어갈 수도 있고, 햄스터들이 움직이면서 그릇에 이물질이 들어갈 수 있다고 해서 그릇은 깨끗하지 않다고 해요.그래서 그릇은 비추를 한다고 합니다.</p>
<p>저 같은 경우에는 아라찌(햄스터)에게 <strong>거치대형 볼 급수기</strong>를 줄거에요. 리빙박스를 벽면을 뚫어서 거는 것보다는 바닥에 배치할 생각이에요. 아직 급수기가 안와서 그릇을 사용하고 있지만, 살짝 미안해지네요 ㅠㅠㅠ</p>
<br>

<h3 id="베딩"><a href="#베딩" class="headerlink" title="베딩"></a>베딩</h3><p>햄스터에게 중요한 것이라고 해요. 햄스터의 잠자리가 될 수도 있고, 햄스터의 놀이터가 될 수도 있거든요. 햄스터들이 파묻힐 수 있을 정도로 베딩을 깔아줘야 된다고 해요.</p>
<p>베딩의 종류도 여러가지가 있어요. 톱밥도 있고, 종이 베딩도 있고, 천 베딩도 있어요. 톱밥 하고 종이 베딩은 햄스터의 면역력에 따라서 사용하면 된다고해요. 그 중에서도 끝판왕이 당연히 존재하겠죠? 그게 바로 <strong>아스펜 베딩</strong>이라고 해요. 다른 것들에 비해 가격이 비싸지만, 햄스터들에게 안전성이 보장된 베딩이라고 해요. 그리고 천 베딩은 웬만하면 사용하지 말라고 하네요. 천 베딩 같은 경우에는 꾸준히 갈아줘야 되서 여러 개를 구매할 뿐만 아니라 세탁을 하는 것도 귀찮고 햄스터들의 본능인 디깅을 하지 못한다는게 단점이에요. 물론 따로 디깅박스를 만들어준다고 하더라도 전 개인적으로 천 베딩을 하지 않을 것 같아요.</p>
<p>하지만 햄스터가 아프다면, 천 베딩을 할거나, 베딩을 아에 깔지 않을지도 몰라요. 햄스터가 아플 경우에는 의료목적으로 베딩을 깔지 않는다고 해요.</p>
<p>그리고 베딩에는 압축 베딩 비압축 베딩이 있다고해요. 압축 베딩은 말그대로 압축해서 베딩을 포장한 것이고요, 비압축 베딩은 압축하지 않은 상태로 베딩을 포장한 것이에요.<br>압축 베딩이 비압축 베딩에 비해 먼지가 많다고해요. 어찌됬든 압축 베딩과 비압축 베딩 둘다 먼지를 털어내고 사용하는 것이 좋다고 해요. 저도 알았다면, 먼지를 털어주고 깔아줬을 텐데… 먼저 데려오고 준비를 하다보니까… 미숙한 저의 모습이 보이는 것 같아요.</p>
<p>저 같은 경우네느 펫 리터의 종이 베딩을 사용하고 있어요. 이마트에서 9000원 주고 구입했어요 ㅎㅎ. 55L 짜리 리빙박스에 이것을 다 부으니까 햄스터가 굴도파고 푹 파고 들어갈 수 있더라고요</p>
<br>

<h3 id="밥"><a href="#밥" class="headerlink" title="밥"></a>밥</h3><p>사람에게 있어서 밥이 중요하듯이 햄스터한테도 밥이 중요해요. 사람들도 건강을 지키는 사람들은 영분을 따져가면서 밥을 먹듯이 햄스터도 건강을 지킬러면 영양분을 따져가면서 먹어야 해요.<br>마트에서 파는 일반적인 사료들은 햄스터의 영양분을 충족시키지 못하는 저급사료라고 해요.<br>여기서 저급 사료는 사료의 질이 좋지 않다는게 아니라, 햄스터에게 영양분을 골고루 주지 못한다는 의미에요.</p>
<p>그래서 좀더 찾아보면서 우리 햄스터에게 좋은게 뭐가 있을지 찾아볼 계획이에요 ㅎㅎ</p>
<br>

<h3 id="기타-등등"><a href="#기타-등등" class="headerlink" title="기타 등등"></a>기타 등등</h3><p>햄스터들은 일반적으로 대소변 훈련을 시킬수가 없다고 해요.<br>하지만 시킬수 있다고해요!!! 햄스터들은 소변을 볼 때, 가장자리에 소변을 보는 경향이 있는데, 그 부분을 잘 관찰해서 거기다가 화장실을 만들면, 거기서 소변을 보게 만들 수 있다고 해요.<br>똥 같은 경우에는 아무곳에서나 싸기 때문에 가릴수가 없다고 해요.</p>
<p>똥 같은 경우에는 햄스터들이 자기가 어느 한 곳에다가 모아두는 경향이 있기도 하지만, 웬만해서는 그냥 흩뿌리고 다닌다고 하네요 ㅎㅎ 우리 햄스터들 귀엽죵 ㅎㅎㅎ</p>
<p>저는 마트에서 파는 목욕용 모래를 가지고 왔어요. 근데 이게 알고보니까 엄청 햄스터들에게 안 좋다고 하더라고요. 그래서 햄스터들한테 좋은 사막모래로 바꿔줄 예정입니다. 안 좋은 이유는 목욕용 모래가 입자가 고와서 햄스터에 기관지에 들어가면 좋지 않다고 합니다. 사람도 마찬가지죠? </p>
<p>우리 아라찌(햄스터)가 목욕용 모래에서 소변을 봤어요!!! 그것도 처음 데려온 날 말이죠. 저는 이 목욕용 모래가 마법의 가루라고 생각해요. 어떤 사람들은 이런 모래를 마약이라고 해요. 대소변 못가리는 햄스터들이 마법처럼 대소변을 가리게 된다고 해서요 ㅎㅎ</p>
<br>

<h2 id="먹이를-집으로-feat-아라찌"><a href="#먹이를-집으로-feat-아라찌" class="headerlink" title="먹이를 집으로 feat. 아라찌"></a>먹이를 집으로 feat. 아라찌</h2><p>이제 포스팅을 끝났어요 ㅎㅎ 햄스터를 처음 데려왔을 때 일주일 동안은 햄스터에게 관심을 가지면 안된다고 해요. 근데 너무 귀여워서… 어쩔수 없이 동영상을 찍어버렸어요.<br>마지막으로 아라찌가 먹이를 집으로 가져가는 모습을 볼까요? ㅎㅎ</p>
<img src="/2019/09/16/HamsterBreddingDiary/hamster.gif" title="먹이를-집으로">

<p>ㅎㅎ 귀엽죠? 원래 베딩위에 아라찌 집이 있었는데, 제가 잠든 사이에 베딩을 열심히 옮겨서 은식처를 베딩안으로 파묻었어요. 우리 아라찌가 집이 엄청 맘에 드나봐요. 근데 이렇게 아라찌가 굴속에서만 살면, 저는 언제 아라찌를 볼 수 있을까요? ㅠㅠㅠㅠ</p>
<img src="/2019/09/16/HamsterBreddingDiary/bury-house.jpeg" title="파묻힌집">

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://777bareman777.github.io/2019/09/12/UnlinkVulnerability/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="777bareman777">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="777bareman777 Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/09/12/UnlinkVulnerability/" class="post-title-link" itemprop="url">Unlink 취약점?</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-09-12 22:09:52" itemprop="dateCreated datePublished" datetime="2019-09-12T22:09:52+09:00">2019-09-12</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-09-24 09:14:00" itemprop="dateModified" datetime="2019-09-24T09:14:00+09:00">2019-09-24</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/System-hacking/" itemprop="url" rel="index"><span itemprop="name">System hacking</span></a></span>

                
                
              
            </span>
          

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
        
      
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2019/09/12/UnlinkVulnerability/#comments" itemprop="discussionUrl"><span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/09/12/UnlinkVulnerability/" itemprop="commentCount"></span></a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>pwnable.kr unlink 문제를 풀어보기 위해서, unlink 취약점에 대해서 찾아 봤어요.<br>처음에 봤을 때는, 하나도 이해가 안 갔지만 ㅠㅠㅠ<br>그래도 계속 읽다보고 생각하다보니까 아주 조금 이해가 됬어요!!<br>조금이라도 더 기억하기 위해서 한번 끄적여 볼게요</p>
<br>

<h2 id="malloc의-동적할당"><a href="#malloc의-동적할당" class="headerlink" title="malloc의 동적할당?"></a>malloc의 동적할당?</h2><p>malloc을 통해서 32바이트만큼 동적할당을 한다고 생각해봐요.<br>실제로 heap 영역에는 32바이트만큼 메모리가 할당이 되어야할 것 같지만, <strong>실제로는 40바이트가 할당이 됩니다.</strong><br>왜 그럴까요? 바로, 할당된 메모리를 관리하기 위한 정보들이 포함되어 있기 때문이에요!<br>그러한 정보는 <strong>chunk</strong>라고 불리는 구조체를 통해 관리됩니다.</p>
<br>

<h2 id="chunk의-구조"><a href="#chunk의-구조" class="headerlink" title="chunk의 구조"></a>chunk의 구조</h2><p>아까 말했듯이 동적할당된 메모리는 chunk라고 불리는 구조체로 관리하고 있어요.<br>이 구조체는 다음과 같이 구성되어 있죠</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>&#123;</span></span><br><span class="line">    INTERNAL_SIZE_T mchnk_prev_size; <span class="comment">/* Size of previous chunk (if free). */</span></span><br><span class="line">    INTERNAL_SIZE_T mchnk_size; <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Only sued for large blocks: pointer to next larger size. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span></span><br><span class="line">    sutrct malloc_chunk* bk_nextsize;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">mchunkptr</span>;</span></span><br></pre></td></tr></table></figure>

<p>mchunk_prev_size: 해제가 되면, 이전 chunk의 크기를 가지게 되요.</p>
<p>mchunk_size: overhead를 포함해서,  현재 chunk의 크기를 가지게 되요. 여기서 overhead는 하위 3비트에 set되는 플래그를 말해요.</p>
<ul>
<li>P(PREV_INUSE): 이전의 chunk가 없으면 0으로 셋되는 데, 맨 처음 chunk에서는 free 됬을 때 합병되지 않도록 하기위해서 1로 셋이 되어 있어요.</li>
<li>M(IS_MMAPPED): mmap함수를 통해서 만들어진 chunk일 경우 1로 셋이 되요.</li>
<li>A(NON_MAIN_ARENA): main 쓰레드에서 만들어졌을 경우 0으로 셋이 되지만 그외의 쓰레드에서 만들어질 경우 1로 셋이 되요.</li>
</ul>
<p>fd, bk: 각각 forward pointer, back pointer 라고해서 다음의 chunk를 가리키고, 이전의 chunk를 가리켜요.</p>
<br>

<h3 id="할당된-메모리와-해제된-메모리의-차이"><a href="#할당된-메모리와-해제된-메모리의-차이" class="headerlink" title="할당된 메모리와 해제된 메모리의 차이?"></a>할당된 메모리와 해제된 메모리의 차이?</h3><p>이제 할당된 메모리와 해제된 메모리가 어떤 차이가 있는지 알아봅시다.</p>
<p><code>Allocated chunk</code></p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">            |             <span class="type">Size</span> of previous chunk, <span class="keyword">if</span> unallocated (P <span class="built_in">clear</span>)  |<span class="type"></span></span><br><span class="line"><span class="type">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="type">            |             Size</span> of chunk, <span class="built_in">in</span> bytes                     |<span class="type">A</span>|<span class="type">M</span>|<span class="type">P</span>|<span class="type"></span></span><br><span class="line"><span class="type">      mem</span>-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">            |             <span class="type">User</span> data starts here...                          .</span><br><span class="line">            .                                                               .</span><br><span class="line">            .             (malloc_usable_size() bytes)                      .</span><br><span class="line">            .                                                               |<span class="type"></span></span><br><span class="line"><span class="type">nextchunk</span>-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">            |             <span class="type">(size</span> of chunk, but used <span class="keyword">for</span> application data)    |<span class="type"></span></span><br><span class="line"><span class="type">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="type">            |             Size</span> of next chunk, <span class="built_in">in</span> bytes                |<span class="type">A</span>|<span class="type">0</span>|<span class="type">1</span>|<span class="type"></span></span><br><span class="line"><span class="type">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br></pre></td></tr></table></figure>

<p><code>Free chunk</code></p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">            |             <span class="type">Size</span> of previous chunk, <span class="keyword">if</span> unallocated (P <span class="built_in">clear</span>)  |<span class="type"></span></span><br><span class="line"><span class="type">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="type">    `head</span>:' |             <span class="type">Size</span> of chunk, <span class="built_in">in</span> bytes                     |<span class="type">A</span>|<span class="type">0</span>|<span class="type">P</span>|<span class="type"></span></span><br><span class="line"><span class="type">      mem</span>-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">            |             <span class="type">Forward</span> pointer to next chunk <span class="built_in">in</span> list             |<span class="type"></span></span><br><span class="line"><span class="type">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="type">            |             Back</span> pointer to previous chunk <span class="built_in">in</span> list            |<span class="type"></span></span><br><span class="line"><span class="type">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="type">            |             Unused</span> space (may be <span class="number">0</span> bytes long)                .</span><br><span class="line">            .                                                               .</span><br><span class="line">            .                                                               |<span class="type"></span></span><br><span class="line"><span class="type">nextchunk</span>-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">    `foot:' |             <span class="type">Size</span> of chunk, <span class="built_in">in</span> bytes                           |<span class="type"></span></span><br><span class="line"><span class="type">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="type">            |             Size</span> of next chunk, <span class="built_in">in</span> bytes                |<span class="type">A</span>|<span class="type">0</span>|<span class="type">0</span>|<span class="type"></span></span><br><span class="line"><span class="type">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br></pre></td></tr></table></figure>

<p>할당된 chunk와 해제된 chunk를 비교하시면 사용하고 있는 데이터 영역이 다르다는 것을 알수가 있어요.<br>할당된 chunk 같은 경우에는 저희가 입력한 데이터들이 들어가 있지만, 해제된 chunk에는 아까 말했던 FD와 BK가 들어가 있고, 나머지 영역은 사용하지 않는다는 것을 알 수가 있어요.</p>
<p>동적메모리가 어떻게 할당되는지 알았으니, 이러한 동적메모리가 여러 개가 존재를 한다고 생각해봐요.<br>그러면 이러한 동적메모리들을 한 곳에 모아서 보관하는 것이 편하겠죠?<br>그래서 <strong>bin</strong>이라는 자료구조가 존재해요!!</p>
<br>

<h2 id="bin-자료구조"><a href="#bin-자료구조" class="headerlink" title="bin 자료구조"></a>bin 자료구조</h2><p>bin 자료구조는 총 4가지가 있다고해요.<br>chunk의 크기에 따라서 사용되는 bin이 달라져요.</p>
<ul>
<li>Fast bin</li>
<li>Unsorted bin</li>
<li>Small bin</li>
<li>Large bin</li>
</ul>
<p><strong>Fast bin</strong>은 10개가 존재하고, 다른 bin들은 double linked list로 구성되어 있지만, Fast bin은 single linked list로 구성되어 있어요.<br>데이터를 삭제하거나 추가할 때 LIFO 방식으로 동작한다고 합니다.<br>그리고 각각의 bin들은 크기가 달라요. 16, 24, 32, 48, 56, 64, 72, 80, 88 순으로 구성되어 있죠.<br>당연히 여기에도 메타 데이터가 포함되요.</p>
<p><strong>Unsorted bin</strong>은 오직 한개만 존재하는데, 이 놈은 다른놈들과 달라요. 이 bin의 목적은 cache layer처럼 빠르게 할당과 해제를 할 수 있게 도와주는 녀석이에요. 즉, 같은 크기의 chunk가 있다면 해당 chunk를 재사용하는 거에요.<br>메모리를 동적할당하고 사용하고 나서 어떤 값을 입력하고 해제한 후, 똑같은 크기의 메모리를 재사용할 때, 메모리를 초기화 해주는 작업을 해주지 않으면 그 메모리 안에 쓰레기 값이 존재할 수도 있어요. 그리고 이를 이용해서 exploit도 가능하다고 합니다.!!</p>
<p><strong>Small bin</strong>은 62개가 존재하고, 16byte에서 시작해서 8byte씩 늘어낙서 504byte까지 존재한다고 해요. 추가하고 제거하는 방식은 FIFO 방식으로 관리 된다고 합니다.<br>그리고 small bin 같은 경우에는 해제된 후에, Unsorted bin에 의해 관리되기전에 서로서로가 합쳐질수도 있다고 합니다.</p>
<p><strong>Large bin</strong>은 63개가 존재하고, 처음 32개의 bin들은 64byte만큼 떨어져 있지만, 특정 large bin들은 크기가 다른 chunk들을 가질 수 있다고 합니다. 그리고 추가하고 제거하는 방식은 어떤 자리에서도 일어날 수 있다고 합니다.!</p>
<br>

<h2 id="동적할당-해제"><a href="#동적할당-해제" class="headerlink" title="동적할당 해제"></a>동적할당 해제</h2><p>이렇든 chunk들은 4가지의 bin을 통해서 관리가 되고, list를 이동해야할 일도 생긴다고 해요. 이때, free() 함수가 실행되는 과정중에 <strong>unlink</strong>라는 매크로 함수가 불릴 때 발생한다고 해요.</p>
<img src="/2019/09/12/UnlinkVulnerability/1.png" title="unlink"> 

<p>free된 chunk가 다시 malloc 되는 경우,<br>chunk의 크기가 증가해서 다른 bin으로 이동할 경우,<br>어떤 chunk가 free 되었을 때,<br>연속된 위치의 다른 chunk가 free 되었을 떄,<br>unlink 매크로 함수를 통해서 2개의 chunk를 합병을 해준다고 해요.</p>
<p>이렇게 chunk의 사이즈가 증가할 때는 원래 속해있던 bin 리스트에서 해당 chunk를 제거하고, 다시 적절한 bin에 넣어줘야 한다고 합니다.</p>
<br>

<p>이때 unlink corruption -&gt; Double Free Bug가 발생한다고 합니다.<br>맨 처음에 봤을 때는 무슨 이상한 줏자들과 함께 써져 있어서, 헷갈리고 이게 무슨 소리인지 이해되지 않았어요.<br><strong>fd와 bk를 조작해서 우리가 원하는 값을 쓸수 있다는 것만 알고 있으면 되요!!</strong></p>
<img src="/2019/09/12/UnlinkVulnerability/2.png" title="unlink-corruption">

<br>
<br>
<br>
<br>
<br>

<h2 id="참고자료"><a href="#참고자료" class="headerlink" title="참고자료"></a>참고자료</h2><hr>
<p><a href="https://heap-exploitation.dhavalkapil.com/diving_into_glibc_heap/malloc_chunk.html#" target="_blank" rel="noopener">Heap Exploitation</a><br><a href="https://bpsecblog.wordpress.com/2016/10/06/heap_vuln/" target="_blank" rel="noopener">Heap 영역에서 발생하는 취약점을 알아보자.</a></p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://777bareman777.github.io/2019/09/12/HowToCreateBlogUingHexo2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="777bareman777">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="777bareman777 Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/09/12/HowToCreateBlogUingHexo2/" class="post-title-link" itemprop="url">Hexo 블로그 만들기 삽질 일지 - 2</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-09-12 16:16:19" itemprop="dateCreated datePublished" datetime="2019-09-12T16:16:19+09:00">2019-09-12</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-09-19 22:07:54" itemprop="dateModified" datetime="2019-09-19T22:07:54+09:00">2019-09-19</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/hexo/" itemprop="url" rel="index"><span itemprop="name">hexo</span></a></span>

                
                
              
            </span>
          

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
        
      
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2019/09/12/HowToCreateBlogUingHexo2/#comments" itemprop="discussionUrl"><span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/09/12/HowToCreateBlogUingHexo2/" itemprop="commentCount"></span></a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>어떤 기기에서든 hexo 블로그를 업데이트 하기 위해서는 hexo 프로젝트와 hexo 테마를 백업을 해야 한다.</p>
<p>그 이유는 hexo 프로젝트를 통해서 배포를 할 때, 올라가는 데이터들은 웹사이트을 구동시킬 때 필요한 데이터들이 USERNAME.github.io 에 올라 가는 것이기 때문이다. </p>
<p>즉, hexo 블로그를 만들면서 포스팅 했던 데이터들은 github에 올라가지 않는다.<br>따라서 별도로 hexo 프로젝트를 백업할 필요가 있다.</p>
<br>

<h2 id="어디서-백업을-해야할까"><a href="#어디서-백업을-해야할까" class="headerlink" title="어디서 백업을 해야할까?"></a>어디서 백업을 해야할까?</h2><p>다시 한번 말하자면, hexo 프로젝트 안에 있는 데이터를 보관하기 위한 새로운 저장소를 만들어야 한다.</p>
<p>github 을 이용하든 gitlab을 이용하든 상관은 없다.<br>하지만 배포를 할 떄 github을 이용했고, github에서 현재 private도 무료로 서비스를 제공하기 때문에 github을 사용하는 것이 좋다.</p>
<p>저장소를 만들 때,<br>private를 선택하든, public를 선택하든 상관은 없다.<br>자신의 데이터를 공개하고 싶지 않다면, private를 선택하는 것이고, 자신의 데이터를 공개해도 좋다고 하면, public을 선택할 뿐이다.</p>
<br>

<h2 id="새로운-저장소-생성"><a href="#새로운-저장소-생성" class="headerlink" title="새로운 저장소 생성"></a>새로운 저장소 생성</h2><p>저장소는 총 2개가 필요하다. 하나는 테마를 보관할 곳, 또 다른 하나는 hexo 프로젝트를 보관할 곳이다.</p>
<p>저장소의 이름은 사용자가 구분하기 쉽고, 쉽게 이용할 수 있는 이름으로 정하면 된다.</p>
<p>나 같은 경우에는 설명하기 쉽게 hexo 프로젝트를 저장할 공간인 <em>blog</em> 테마를 저장할 공간인 <em>theme</em> 라는 이름으로 만들었다.</p>
<br>

<h3 id="hexo-프로젝트-백업하기"><a href="#hexo-프로젝트-백업하기" class="headerlink" title="hexo 프로젝트 백업하기"></a>hexo 프로젝트 백업하기</h3><p>hexo 프로젝트를 백업하는 방법은 간단하다.<br>다음처럼 git을 만들어 주기만 하면된다.</p>
<figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># initialize git</span></span><br><span class="line">git init</span><br><span class="line"></span><br><span class="line"><span class="meta"># add contents</span></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line"><span class="meta"># commit contents</span></span><br><span class="line">git commit -m <span class="string">"Initial commit"</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># change remote repository</span></span><br><span class="line">git remote add origin https:<span class="comment">//github.com/777bareman777/blog.git</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># push contents</span></span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>

<br>

<h3 id="테마-백업하기"><a href="#테마-백업하기" class="headerlink" title="테마 백업하기"></a>테마 백업하기</h3><p>직접 만든 경우에는 상관은 없지만, 다른 사람들이 만든 테마 같은 경우에는 백업하기가 힘들다.</p>
<p>fork를 하든, duplicate를 하든 상관이 없다.<br>어차피 원래의 테마 개발자가 업데이트를 하고, 우리가 그것을 따르고 싶다면, 우리가 설정했던 것들은 날라가기 때문이다.</p>
<p>-&gt; 그럴 경우에는 자신이 설정했던 파일들을 따로 백업을 하는 것이 좋음.</p>
<p>그렇지 않고, 그 테마를 가지고 스스로 수정하고 싶다면 fork를 하는 것이 좋을지도 모른다.</p>
<p>일단은 duplicate를 했을 때를 생각해보자.</p>
<p>원하는 테마를 고르고 duplicate를 하고, 저장소 위치를 우리가 theme를 만들고자 했던 곳으로 바꾸고,<br>안에 있는 데이터들을 올리기만 하면된다.</p>
<figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># clone theme</span></span><br><span class="line"><span class="string">git </span><span class="string">clone </span><span class="string">https:</span>//<span class="string">github.</span><span class="string">com/</span><span class="string">aircloud/</span><span class="string">hexo-theme-</span><span class="string">aircloud</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#</span> <span class="string">check </span><span class="string">remote </span><span class="string">repository</span></span><br><span class="line"><span class="string">git </span><span class="string">remote </span>-v</span><br><span class="line"></span><br><span class="line"><span class="comment"># change retmoe repository</span></span><br><span class="line"><span class="string">git </span><span class="string">remote </span><span class="built_in">set-url</span> <span class="string">origin </span><span class="string">https:</span>//<span class="string">github.</span><span class="string">com/</span><span class="string">777bareman777/</span><span class="string">theme</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#</span> <span class="string">add </span><span class="string">contents</span></span><br><span class="line"><span class="string">git </span><span class="string">add </span>.</span><br><span class="line"></span><br><span class="line"><span class="comment"># commit contents</span></span><br><span class="line"><span class="string">git </span><span class="string">commit </span>-m <span class="string">"Initial commit"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># push contents</span></span><br><span class="line"><span class="string">git </span><span class="string">push </span>-u <span class="string">origin </span><span class="string">master</span></span><br></pre></td></tr></table></figure>

<br>

<h2 id="서브모듈-추가하기"><a href="#서브모듈-추가하기" class="headerlink" title="서브모듈 추가하기"></a>서브모듈 추가하기</h2><p>테마 폴더를 hexo 프로젝트에 push 하기 전에 고려해야할 점이 있다. git안에 git이 있는 경우 서로의 독립성을 유지하면서 서로의 버전을 따로 관리 하기 위해서 서브모듈로 추가해서 관리하는 것이 필수이다.</p>
<p>서브모듈에 대한 자세한 설명은 아래의 블로그를 참고하기 바란다.</p>
<ul>
<li><a href="https://www.tuwlab.com/ece/26011" target="_blank" rel="noopener">서브모듈에 대해 이해하기</a></li>
</ul>
<p>그럼 서브모듈을 hexo 프로젝트에 추가해보자.</p>
<p>먼저 hexo 프로젝트로 이동을하고, hexo 프로젝트 안에 있는 themes 폴더에 테마를 서브모듈로 추가한다. 그 후에 제대로 변경이 되었는지 확인을 하고 변경된 내용을 push 하면 된다.</p>
<figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># add theme repository in hexo theme folder as submodule</span></span><br><span class="line">git submodule add https:<span class="comment">//github.com/777bareman777/theme themes/aircloud</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># check status</span></span><br><span class="line">git status</span><br><span class="line">git submodule status</span><br><span class="line"></span><br><span class="line"><span class="meta"># add contents</span></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line"><span class="meta"># commit contents</span></span><br><span class="line">git commit -m <span class="string">"Initial commit"</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># push contents</span></span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>

<br>

<h2 id="마지막으로…"><a href="#마지막으로…" class="headerlink" title="마지막으로…"></a>마지막으로…</h2><p>이러한 작업을 거치면 github에서 hexo 프로젝트와 테마를 관리해주기 때문에 데이터가 날라가도 다시 복구를 할 수가 있다.</p>
<p>데이터가 날라갔을 떄, 복구하는 방법은 다음과 같다.</p>
<p>먼저 hexo 프로젝트를 불러온다. 그 후에 서브모듈을 초기화 시키고 업데이트 시켜서 서브모듈의 데이터들을 가져온다. 서브모듈은 또 다른 git으로 이루어져 있기 때문에 그 독립성과 버전 관리를 위해서 데이터를 포함하고 있지 않기 때문이다. 마지막으로 local hexo를 다시 설치해줘야 한다.</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">git</span> clone https://github.com/<span class="number">777</span>bareman777/<span class="keyword">blog</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">git </span><span class="keyword">submodule </span>init</span><br><span class="line"></span><br><span class="line"><span class="symbol">git</span> <span class="keyword">submodule </span>update</span><br><span class="line"></span><br><span class="line"><span class="symbol">npm</span> install hexo --save</span><br></pre></td></tr></table></figure>

<br>

<h2 id="진짜-마지막으로…"><a href="#진짜-마지막으로…" class="headerlink" title="진짜 마지막으로…"></a>진짜 마지막으로…</h2><p>변경된 사항을 github에 push를 하기 전에 Slave(submodule) 먼저 push를 한후 Master(iriginal git)을 push를 해야 한다.</p>
<p>Master -&gt; Slave의 순서로 commit을 하게 되면, 다시 한번 더 Master에서 변경사항이 있다는 것을 알게 된다.</p>
<p>이렇게 작동 하는 이유는 Slave가 Master를 바라볼 때 Abstraction되는 방식으로 관리하기 때문이다.</p>
<p>Slave에서 변경된 사항은 Master에서 commit 할 때, 파일들을 Tracking 하는 것이 아니라 Slave의 HEAD가 무엇으로 변경되었는지에 대한 정보만 기록하기 때문이다.</p>
<br>
<br>
<br>
<br>
<br>

<h2 id="이전-포스팅"><a href="#이전-포스팅" class="headerlink" title="이전 포스팅"></a>이전 포스팅</h2><hr>
<p><a href="../HowToCreateBlogUingHexo">Hexo 블로그 만들기 삽질 일기 - 1</a></p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://777bareman777.github.io/2019/09/12/HowToCreateBlogUingHexo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="777bareman777">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="777bareman777 Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/09/12/HowToCreateBlogUingHexo/" class="post-title-link" itemprop="url">Hexo 블로그 만들기 삽질 일지 - 1</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-09-12 15:09:08" itemprop="dateCreated datePublished" datetime="2019-09-12T15:09:08+09:00">2019-09-12</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-12-03 21:09:35" itemprop="dateModified" datetime="2019-12-03T21:09:35+09:00">2019-12-03</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/hexo/" itemprop="url" rel="index"><span itemprop="name">hexo</span></a></span>

                
                
              
            </span>
          

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
        
      
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2019/09/12/HowToCreateBlogUingHexo/#comments" itemprop="discussionUrl"><span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/09/12/HowToCreateBlogUingHexo/" itemprop="commentCount"></span></a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>아는 형한테 github page와 hexo를 통해서 블로그를 만들 수 있다고 이야기를 들었다.<br>티스토리 보다는 간지나게 hexo로 블로그를 관리해보자라는 욕심으로 정보를 찾아봤다.<br>하지만 그 이야기를 들었으면 안됬다.</p>
<img src="/2019/09/12/HowToCreateBlogUingHexo/sibal.jpeg" title="오열"> 

<p>이제부터 시작이다 나의 hexo 삽질이 ….</p>
<br>

<h2 id="Git-Page로-정적-페이지-Hosting하기"><a href="#Git-Page로-정적-페이지-Hosting하기" class="headerlink" title="Git Page로 정적 페이지 Hosting하기"></a>Git Page로 정적 페이지 Hosting하기</h2><p>Git Page를 통해 USERNAME.github.io 도메인을 통해 정적 페이지를 호스팅할 수 있고, 자기 자신이 도메인을 가지고 있으면 커스텀 도메인할 수 있다. 이런거 필요 없다. 몰라도 좋다.</p>
<p>그냥 github에 들어가서 USERNAME.github.io를 생성하면 된다.<br>public 이든 private든 무엇이든 선택해도 좋다.</p>
<br>

<h2 id="Hexo-시작"><a href="#Hexo-시작" class="headerlink" title="Hexo 시작"></a>Hexo 시작</h2><p>자 이제 우리는 고통의 시간이 조금씩 다가왔다.<br>hexo를 사용하기 전에 필수적으로 설치해야 하는 것들이 있다.</p>
<ul>
<li><strong>Node.js</strong></li>
<li><strong>Git</strong></li>
</ul>
<p>위의 두가지만 설치를 하면 된다. 설치 되어 있으면 생략해도 씹가능이다.</p>
<br>

<h3 id="hexo-cli-설치-블로그-생성"><a href="#hexo-cli-설치-블로그-생성" class="headerlink" title="hexo cli 설치 + 블로그 생성"></a>hexo cli 설치 + 블로그 생성</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install </span>hexo-cli -g</span><br><span class="line">hexo init <span class="keyword">blog</span></span><br><span class="line"><span class="keyword">cd </span><span class="keyword">blog</span></span><br><span class="line"><span class="keyword">npm </span><span class="keyword">install</span></span><br></pre></td></tr></table></figure>

<br>

<h3 id="설정파일-바꾸기"><a href="#설정파일-바꾸기" class="headerlink" title="설정파일 바꾸기"></a>설정파일 바꾸기</h3><p>위와 같은 방식으로 Hexo 프로젝트를 만들 수 있는데, Hexo 프로젝트 안에 _config.yml 이라는 설정파일이 존재한다. 이 설정 파일을 가지고 블로그에 대한 설정을 할 수 있는데, 나중에 테마를 설정하게 되면 테마 폴더에 있는 _config.yml 도 건드려야 한다.<br>설정파일안에 주석도 달려있고, 공식 문서도 존재하고, 다른 블로그에서도 설명이 되있으니 생략한다.</p>
<p>-&gt; 이 부분이 좀 많이 짜증난다.</p>
<ul>
<li>공식 사이트 : <a href="https://hexo.io/docs/" target="_blank" rel="noopener">https://hexo.io/docs/</a></li>
</ul>
<p>하지만 그 설정 파일 중에서 필수적으로 바꿔야 하는 것이 있다.<br>블로그 URL을 바꾸는 부분과 Github 정보를 바꾸는 부분이다.</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># blod url</span></span><br><span class="line"><span class="symbol">url:</span> https:<span class="comment">//USERNAME.github.io</span></span><br><span class="line"><span class="symbol">root:</span> /</span><br><span class="line"><span class="symbol">permalink:</span> :year/:month/:day/:title/</span><br><span class="line"><span class="symbol">permalink_defaults:</span></span><br></pre></td></tr></table></figure>

<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># Deployment</span></span><br><span class="line"><span class="symbol">deploy:</span></span><br><span class="line"><span class="symbol">  type:</span> git</span><br><span class="line"><span class="symbol">  repo:</span> https:<span class="comment">//USERNAME@github.com/USERNAME/USERNAME.github.io</span></span><br><span class="line"><span class="symbol">  branch:</span> master</span><br></pre></td></tr></table></figure>

<p>위와 같이 자신의 github 아이디를 USERNAME에 넣어주기만 하면 배포를 할 수 있게된다.</p>
<br>

<h3 id="로컬에서-테스트하기"><a href="#로컬에서-테스트하기" class="headerlink" title="로컬에서 테스트하기"></a>로컬에서 테스트하기</h3><p>설정을 완료하면 아래의 명령어를 통해 로컬에서 서버를 구동할 수 있다.</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo <span class="keyword">server</span></span><br></pre></td></tr></table></figure>

<p>서버가 구동이 되면 브라우저에서 <a href="https://localhost:4000" target="_blank" rel="noopener">https://localhost:4000</a> 을 통해 hexo로 만든 블로그에 접속할 수 있다.</p>
<br>

<h2 id="Github에-배포하기"><a href="#Github에-배포하기" class="headerlink" title="Github에 배포하기"></a>Github에 배포하기</h2><p>로컬에서 정상적으로 블로그가 동작한다는 것을 확인 한후에 github을 통해 배포가 가능하다.</p>
<p>먼저 hexo 설정을 가지고 리소스를 생성하고 배포하면된다.</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo <span class="keyword">generate</span></span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>

<p>생성과 배포를 동시에 할 수도 있다.</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo <span class="keyword">generate</span> --deploy</span><br></pre></td></tr></table></figure>

<p>하지만 배포를 하기 전에 hexo에서 github에 push 할 수 있도록 플러그인을 다운로드 받아야한다.</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm instgall hexo-deployer-git <span class="comment">--save</span></span><br></pre></td></tr></table></figure>

<p>플러그인을 받은 후에 _config.yml에 플러그인 설정을 해주기만 하면된다.</p>
<p>-&gt; 설정을 하지 않아도 동작하기는 한다.</p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">plugins:</span></span><br><span class="line">    - hexo-deployer-git</span><br></pre></td></tr></table></figure>

<br>

<h2 id="기타-등등"><a href="#기타-등등" class="headerlink" title="기타 등등"></a>기타 등등</h2><p>포스팅을 하고, 이미지를 넣고, 하는 방법은 다른 블로그에도 많으니 다른 곳을 참고하길 바란다.<br>다음 글에서는 hexo 프로젝트를 백업하고, 테마를 설정하고, 테마를 백업하는 방법에 대해 설명하고자 한다.</p>
<p>hexo blog를 백업하는 부분에서 많은 시간이 소모가 된다. github을 자주 사용하지 않아서 이 부분에서 깊은 빡침을 느꼈다.</p>
<p>다음 포스팅에서 보자.</p>
<br>
<br>
<br>
<br>
<br>

<h2 id="다음-포스팅"><a href="#다음-포스팅" class="headerlink" title="다음 포스팅"></a>다음 포스팅</h2><hr>
<p><a href="../HowToCreateBlogUingHexo2">Hexo 블로그 만들기 삽질 일기 - 2</a></p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">777bareman777</p>
  <div class="site-description" itemprop="description"></div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">20</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">categories</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">tags</span>
        </a>
      </div>
    
  </nav>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">777bareman777</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.4.0</div>

        












        
      </div>
    </footer>
  </div>

  


  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.4.0"></script><script src="/js/motion.js?v=7.4.0"></script>
<script src="/js/schemes/muse.js?v=7.4.0"></script>
<script src="/js/next-boot.js?v=7.4.0"></script>



  





















  

  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://777bareman777.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>

</body>
</html>
