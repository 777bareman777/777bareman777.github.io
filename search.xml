<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>HowToUsePragma</title>
      <link href="/2020/01/16/HowToUsePragma/"/>
      <url>/2020/01/16/HowToUsePragma/</url>
      
        <content type="html"><![CDATA[<p>해당 포스팅은 전처리 구문 중 하나인 #Pragma를 사용하는 방식에 대한 정리 글입니다.</p><h2 id="Prama"><a href="#Prama" class="headerlink" title="Prama??"></a>Prama??</h2><p>#Prama는 define 이나 include와 같이 #으로 시작하는 전처리 구문(Precompipler)의 하나라고 합니다.</p><p>MSVC(컴파일러)에만 존재하는 종송적인 명령어이므로, 컴파일러에 직접 정보를 전하기 위해서 사용된다고 합니다. 그래서 컴파일러를 변경했을 경우 실행을 보장을 하지 못한다고 합니다.</p><h3 id="1-pragma-once"><a href="#1-pragma-once" class="headerlink" title="1. #pragma once"></a>1. #pragma once</h3><p>#pragma once는 컴파일러에게 한번만 컴파일 하라고 알려주는 전처리 구문이다. #define으로 각 헤더에 최소 값을 정의 해서 한번만 컴파일 되도록 했다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// #pragma once 방법</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// #define 방법</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _HEADER_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _HEADER_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="2-pragma-comment"><a href="#2-pragma-comment" class="headerlink" title="2. #pragma comment()"></a>2. #pragma comment()</h3><p>#prgma comment(comment-type, comment string?) [] 안의 구문은 comment-type에 따라 필요한 경우에 사용한다고 합니다. comment-type에는 compiler, exestr, lib, linker, user 등이 올 수 있습니다.</p><ul><li>subsystem 설정</li></ul><p>프로젝트 관리에서 직접 서브 시스템을 바꿀 수도 있지만 #prgma comment() 방식을 이용해서도 변경이 가능하다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(linker, <span class="meta-string">"/subsystem:windows"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(linker, <span class="meta-string">"/subsystem:console"</span>)</span></span><br></pre></td></tr></table></figure><ul><li>section 설정</li></ul><p>코드 섹션, 데이터 섹션, init 섹션 등 다양한 섹션을 설정할 수 있습니다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(linker, <span class="meta-string">"SECTION:.SHARE,RWS"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> data_seg(<span class="meta-string">".SHARE"</span>)</span></span><br><span class="line">...</span><br><span class="line">공유하고 싶은 변수 목록 작성</span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> data_seg()</span></span><br></pre></td></tr></table></figure><ul><li>명시적(explicit) 라이브러리 링크 설정</li></ul><p>명시적으로 라이브러리 링크를 설정하고 싶을 때, 원래대로 라면 프로젝트 관리 들어가서 링크 탭에서 링크 하고 싶은 라이브러리를 적어야 하지만, #pragma를 통해서 편하게 처리할 수 있습니다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">"Mylib.lib"</span>)</span></span><br></pre></td></tr></table></figure><br><p>이것 이외에도 많은 방식으로 사용될 수 있다고 합니다. <a href="http://www.silverwolf.co.kr/cplusplus/4724" target="_blank" rel="noopener">해당 문서</a>와 <a href="https://docs.microsoft.com/ko-kr/cpp/preprocessor/pragma-directives-and-the-pragma-keyword?view=vs-2019" target="_blank" rel="noopener">MSDN</a>을 참고하면 됩니다.</p>]]></content>
      
      
      <categories>
          
          <category> Windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
            <tag> Windows Reversing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ProcessSearch</title>
      <link href="/2020/01/16/ProcessSearch/"/>
      <url>/2020/01/16/ProcessSearch/</url>
      
        <content type="html"><![CDATA[<p>CreateToolhelp32Snapshot() API 와 EnumProcesses() API를 통해서 시스템에 실행 중인 모든 프로세스를 검색하는 방법을 정리했습니다.</p><h2 id="CreateToolhelp32Snapshot"><a href="#CreateToolhelp32Snapshot" class="headerlink" title="CreateToolhelp32Snapshot()"></a>CreateToolhelp32Snapshot()</h2><p>CreateToolhelp32Snapshot() API를 이용해서 프로세스에서 사용되는 힙, 모듈, 및 스레드의 스냅샷을 찍어서 프로세스에 대한 정보를 추출할 때 사용하는 함수입니다. 프로세스와 관련된 모든 부분을 검색할 수도 있고, 일부분만 검색 할 수도 있습니다.</p><p>CreateToolhelp32Snapshot() API는 Tlhelp32.h 헤더 파일에 정의되어 있습니다. 정의는 다음과 같습니다.</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HANDLE CreateToolhelp32Snapshot(</span><br><span class="line">  DWORD dwFlags,</span><br><span class="line">  DWORD th32ProcessID</span><br><span class="line">)<span class="comment">;</span></span><br></pre></td></tr></table></figure><ul><li>dwFlags</li></ul><p>dwFlags 파라미터는 스냅샷을 찍을 때 어떻게 찍을지를 정합니다. 시스템의 모든 프로세스와 스레드의 정보를 가져올지, 아니면 프로세스만 가져올지, 아니면 모듈만 가져올지, 아니면 스레드만 가져올지 그러한 것들을 지정할 수 있읍니다.</p><p>해당 값에 자세한 정보는 <a href="https://docs.microsoft.com/en-us/windows/win32/api/tlhelp32/nf-tlhelp32-createtoolhelp32snapshot" target="_blank" rel="noopener">MSDN</a>에서 확인할 수 있습니다.</p><ul><li>th32ProcessID</li></ul><p>th32ProcessID 파라미터는 스냅샷에 포함될 프로세스의 식별자를 정합니다. 현재 프로세스를 나타낼 때는 NULL을 입력하면 됩니다. 만약에 TH32CS_SNAPHEAPLIST, TH32CS_SNAPMODULE, TH32CS_SNAPMODULE32, TH32CS_SNAPALL 값이 dwFlasgs 파라미터에 지정된 경우에는 th32ProcessID 파라미터를 사용하지만 그외의 경우에는 사용하지 않습니다.</p><h3 id="예제"><a href="#예제" class="headerlink" title="예제"></a>예제</h3><p>CreateToolhelp32Snapshot() API를 사용해봅시다. 해당 API를 사용해서 얻고 싶은 정보에 따라서 Heap32First(), Heap32Next(), Module32First(), Module32Next(), Process32First(), Process32Next() 들중 한가지를 골라서 사용을 해야 합니다. 여기 있는 것만이 다가 아니고, MSDN에 들어가면 사용할 수 있는 API들이 더 있습니다.</p><p>해당 예제에서는 Process에 대한 정보를 추출하고 싶은 것이기 때문에 <strong>Process32First() 와 Process32Next()</strong>를 선택했습니다.</p><p>Process32First()와 Process32Next()의 구조체 정의는 다음과 같습니다.</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BOOL Process32First(</span><br><span class="line">  HANDLE           hSnapshot,</span><br><span class="line">  LPPROCESSENTRY32 lppe</span><br><span class="line">)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">BOOL Process32Next(</span><br><span class="line">  HANDLE           hSnapshot,</span><br><span class="line">  LPPROCESSENTRY32 lppe</span><br><span class="line">)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>파라미터로 CreateToolhelp32Snapshot() 함수를 통해서 얻은 스냅샷 핸들과 PROCESSENTRY32 구조체의 주소를 넘겨주면 됩니다. Process32First()와 Process32Next() 통해서 얻을 수 있는 정보는 PROCESSENTRY32 라는 구조체에 들어있는 데이터입니다. PROCESSENTRY32 구조체에서는 실행 파일 이름, 프로세스 ID, 부모 프로세스 ID와 같은 프로세스 정보들을 얻을 수 있습니다.</p><p>PROCESSENTRY32 구조체는 정의는 다음과 같습니다.</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typedef struct tagPROCESSENTRY32 &#123;</span><br><span class="line">  <span class="type">DWORD</span>     dwSize;</span><br><span class="line">  <span class="type">DWORD</span>     cntUsage;</span><br><span class="line">  <span class="type">DWORD</span>     th32ProcessID;</span><br><span class="line">  <span class="type">ULONG_PTR</span> th32DefaultHeapID;</span><br><span class="line">  <span class="type">DWORD</span>     th32ModuleID;</span><br><span class="line">  <span class="type">DWORD</span>     cntThreads;</span><br><span class="line">  <span class="type">DWORD</span>     th32ParentProcessID;</span><br><span class="line">  <span class="type">LONG</span>      pcPriClassBase;</span><br><span class="line">  <span class="type">DWORD</span>     dwFlags;</span><br><span class="line">  <span class="type">CHAR</span>      szExeFile[<span class="type">MAX_PATH</span>];</span><br><span class="line">&#125; <span class="type">PROCESSENTRY32</span>;</span><br></pre></td></tr></table></figure><ul><li><p>dwSize</p><p>  <strong>구조체의 크기입니다. Process32First 함수를 호출하기 전에 sizeof(PROCESSENTRY32)으로 초기화 시켜줘야합니다.</strong> 초기화 시키지 않으면 Process32First 함수 호출을 실패합니다.</p></li><li><p>cntUsage</p><p>  이 멤버는 더 이상 사용하지 않으며 항상 0으로 설정됩니다.</p></li><li><p>th32ProcessID</p><p>  프로세스 ID</p></li><li><p>th32DefaultHeapID</p><p>  이 멤버는 더 이상 사용하지 않으며 항상 0으로 설정됩니다.</p></li><li><p>th32ModuleID</p><p>  이 멤버는 더 이상 사용하지 않으며 항상 0으로 설정됩니다.</p></li><li><p>cntThreads</p><p>  프로세스가 시작한 실행 스레드 개수</p></li><li><p>th32ParentProcessID</p><p>  이 프로세스를 생성한 프로세스의 ID(부모 프로세스)</p></li><li><p>pcPriClassBase</p><p>  이 프로세스에서 작성된 스레드의 기본 우선 순위</p></li><li><p>dwFlags</p><p>  이 멤버는 더 이상 사용되지 않으며 항상 0으로 설정됩니다.</p></li><li><p>szExeFile</p><p>  프로세스의 실행 파일 이름입니다. 실행 파일의 전체 경로를 검색하려면 Module32First 함수를 호출하고 리턴 되는 MODULEENTRY32 구조 의 szExePath 멤버를 확인하십시오 . 그러나 호출 프로세스가 32 비트 프로세스 인 경우 QueryFullProcessImageName 함수를 호출하여 64 비트 프로세스에 대한 실행 파일의 전체 경로를 검색 해야합니다.</p></li></ul><br><h4 id="소스코드"><a href="#소스코드" class="headerlink" title="소스코드"></a>소스코드</h4><p>이렇게 CreateToolhelp32Snapshot() API, Process32First() API, Process32Next() API를 적절하게 사용하면 프로세스 ID와 프로세스 이름을 구할 수 있습니다. 아래의 코드는 프로세스 ID와 프로세스 이름을 구하는 소스코드 입니다.</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"windows.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"tlhelp32.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"tchar.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> main(<span class="built_in">int</span> argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">HANDLEhSnapShot<span class="comment">;</span></span><br><span class="line">PROCESSENTRY32pe<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">pe.dwSize = sizeof(PROCESSENTRY32)<span class="comment">;</span></span><br><span class="line">hSnapShot = CreateToolhelp32Snapshot(TH32CS_SNAPALL, <span class="literal">NULL</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">Process32First(hSnapShot, &amp;pe)<span class="comment">;</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">_tprintf(_T(<span class="string">"PID: %u  \tProcess Name : %s\n"</span>), pe.th32ProcessID, pe.szExeFile)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!Process32Next(hSnapShot, &amp;pe))</span><br><span class="line">&#123;</span><br><span class="line">CloseHandle(hSnapShot)<span class="comment">;</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h2 id="EnumProcesses"><a href="#EnumProcesses" class="headerlink" title="EnumProcesses()"></a>EnumProcesses()</h2><p>EnumProcesses() API 이용해서 프로세스 ID의 정보를 얻어낼 수 있습니다. 이를 통해서 프로세스의 정보를 알아낼 수 있습니다.</p><p>EnumProcesses() API는 Psapi.h 헤더 파일에 정의되어 있습니다. 정의는 다음과 같습니다.</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BOOL </span>EnumProcesses(</span><br><span class="line">  DWORD   *lpidProcess,</span><br><span class="line">  DWORD   cb,</span><br><span class="line">  LPDWORD lpcbNeeded</span><br><span class="line">)<span class="comment">;</span></span><br></pre></td></tr></table></figure><ul><li>lpidProcess</li></ul><p>lpidProcess 파라미터는 프로세스 ID 목록을 받는 배열에 대한 포인터를 지정하면 됩니다.</p><ul><li>cb</li></ul><p>lpidProcess 배열의 크기를 지정하면 됩니다.</p><ul><li>lpcbNeeded</li></ul><p>lpidProcess 배열에 반환된 바이트 수입니다.</p><br><p>EnumProcess() API를 호출 할 때 얼마나 많은 프로세스가 있을지 예측하기 어렵기 때문에 큰 배열을 사용해서 프로세스의 ID를 구하는 것이 바람직합니다.</p><p>프로세스 목록을 확인하려면 lpcbNeeded 파라미터에 입력된 변수의 값을 sizeof(DWORD)로 나누면 프로세스의 개수를 얻을 수 있습니다. 만약에 버퍼가 작아서 모든 프로세스를 식별을 하지 못했다면, 더 큰 배열로 다시 시도하면 됩니다.</p><p>배열에는 함수의 프로세스의 ID를 얻었으면, 프로세스 ID가 들어가게 됩니다. 배열안에 프로세스 ID가 있다는 것을 확인했으면, OpenProcess 함수를 호출해서 프로세스 핸들을 얻고, 프로세스의 정보를 추출하면 됩니다.<br>프로세스 정보를 추출할 수 있는 API들은 <a href="https://docs.microsoft.com/en-us/windows/win32/api/psapi/" target="_blank" rel="noopener">psapi.h 헤더 파일</a>을 참고 하시면 됩니다. </p><br><h3 id="예제-1"><a href="#예제-1" class="headerlink" title="예제"></a>예제</h3><p>이때, 프로세스의 이름을 얻기 위해 사용된 API는 EnumProcessModules() 과 GetModuleBaseName() 입니다. <a href="https://docs.microsoft.com/en-us/windows/win32/api/psapi/nf-psapi-enumprocessmodules" target="_blank" rel="noopener">EnumProcessModule()</a>을 이용해서 프로세스에서 사용되는 모듈 핸들을 얻고, <a href="https://docs.microsoft.com/en-us/windows/win32/api/psapi/nf-psapi-getmodulebasenamea" target="_blank" rel="noopener">GetModuleBaseName()</a>을 이용해서 프로세스 이름을 얻는 방식입니다. 자세한 정보는 MSDN에서 검색하면 됩니다.</p><h4 id="소스코드-1"><a href="#소스코드-1" class="headerlink" title="소스코드"></a>소스코드</h4><p>아래의 코드는 EnumProcesses() API, EnumProcessModule() API, GetModuleBaseName() API를 이용해서 프로세스의 ID와 프로세스 이름을 얻는 소스 코드입니다. 해당 코드는 MSDN의 <a href="https://docs.microsoft.com/ko-kr/windows/win32/psapi/enumerating-all-processes?redirectedfrom=MSDN" target="_blank" rel="noopener">예제 소스 코드</a>입니다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"windows.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"tchar.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"psapi.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ProcessSearch</span><span class="params">(DWORD dwPID)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">TCHAR szProcName[MAX_PATH] = _T(<span class="string">"&lt;unknown&gt;"</span>);</span><br><span class="line">HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, dwPID);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> != hProcess)</span><br><span class="line">&#123;</span><br><span class="line">HMODULE hMod;</span><br><span class="line">DWORD cbNeeded;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (EnumProcessModules(hProcess, &amp;hMod, <span class="keyword">sizeof</span>(hMod), &amp;cbNeeded))</span><br><span class="line">&#123;</span><br><span class="line">GetModuleBaseName(hProcess, hMod, szProcName, <span class="keyword">sizeof</span>(szProcName) / <span class="keyword">sizeof</span>(TCHAR));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">_tprintf(_T(<span class="string">"PID: %u  \tProcess Name : %s\n"</span>), dwPID, szProcName);</span><br><span class="line"></span><br><span class="line">CloseHandle(hProcess);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DWORD Processes[<span class="number">1024</span>], cbNeeded, cProcesses;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!EnumProcesses(Processes, <span class="keyword">sizeof</span>(Processes), &amp;cbNeeded))</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">cProcesses = cbNeeded / <span class="keyword">sizeof</span>(DWORD);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cProcesses; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (Processes[i] != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">ProcessSearch(Processes[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h2 id="참고자료"><a href="#참고자료" class="headerlink" title="참고자료"></a>참고자료</h2><p><a href="https://docs.microsoft.com/en-us/windows/win32/api/tlhelp32/nf-tlhelp32-createtoolhelp32snapshot" target="_blank" rel="noopener">CreateToolhelp32Snapshot()</a></p><p><a href="https://docs.microsoft.com/en-us/windows/win32/api/tlhelp32/ns-tlhelp32-processentry32" target="_blank" rel="noopener">PROCESSENTRY32 구조체</a></p><p><a href="https://docs.microsoft.com/en-us/windows/win32/api/psapi/nf-psapi-enumprocesses" target="_blank" rel="noopener">EnumProcess()</a></p><p><a href="https://docs.microsoft.com/en-us/windows/win32/api/psapi/nf-psapi-enumprocessmodules" target="_blank" rel="noopener">EnumProcessModule()</a></p><p><a href="https://docs.microsoft.com/en-us/windows/win32/api/psapi/nf-psapi-getmodulebasenamea" target="_blank" rel="noopener">GetModuleBaseName()</a></p><p><a href="https://docs.microsoft.com/ko-kr/windows/win32/psapi/enumerating-all-processes?redirectedfrom=MSDN" target="_blank" rel="noopener">Process Search using EnumProcess</a></p>]]></content>
      
      
      <categories>
          
          <category> Windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
            <tag> Windows Reversing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>스텔스 프로세스, 코드 패치 기법을 이용해서 -1</title>
      <link href="/2020/01/16/WindowsAPIHookingStealthProcess-1/"/>
      <url>/2020/01/16/WindowsAPIHookingStealthProcess-1/</url>
      
        <content type="html"><![CDATA[<p>일명 나뭇잎 책이라고 불리는 리버싱 핵심 원리 책을 보면서, 배운 내용을 정리하는 포스팅입니다.</p><p>해당 포스팅에서는 API 후킹 방법을 이용해서 유저 모드에서 StealthProcess를 만드는 기법을 배웁니다.</p><br><h2 id="들어가기에-앞서"><a href="#들어가기에-앞서" class="headerlink" title="들어가기에 앞서"></a>들어가기에 앞서</h2><p>스텔스 프로세스를 만드는 방법을 알기전에 API 후킹 방법중 코드 패치를 이용하는 방식에 대해 알아야 합니다. 핵심 부분을 말하자면 프로세스 메모리에 로딩된 라이브러리 이미지에서 후킹을 원하는 API 코드를 수정하는 방법입니다. 해당 내용에 대해 더 자세히 알고 싶다면, <a href="../../15/WindowsAPIHookingUsingCodePatch">Windows API Hooking - Code Patch</a> 참고하시면 됩니다.</p><br><h2 id="스텔스-프로세스"><a href="#스텔스-프로세스" class="headerlink" title="스텔스 프로세스"></a>스텔스 프로세스</h2><p>특정 프로세스를 은폐시키기 위해서는 다른 모든 프로세스의 메모리에 침투하여 API를 후킹하는 것이 유저 모드에서 구현 가능한 스텔스 프로세스라고 합니다. 작업 대상은 자기 자신이 아니라 다른 프로세스입니다.</p><p>프로세스는 커널 객체이기 때문에 유저 모드 프로그램에서는 직접적으로 접근할 수 있는 방법이 없습니다. 따라서 API를 통해서만 검색 및 접근을 할 수 있다. 일반적으로 유저 모드에서 프로세스를 검색하기 위한 API가 2종류가 있다고 합니다.</p><ul><li><ol><li>CreateToolhelp32Snapshot() &amp; EnumProcesses()</li></ol></li></ul><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HANDLE CreateToolhelp32Snapshot(</span><br><span class="line">  <span class="built_in">DWORD</span> dwFlags,</span><br><span class="line">  <span class="built_in">DWORD</span> th32ProcessID</span><br><span class="line">)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">BOOL EnumProcesses(</span><br><span class="line">  <span class="built_in">DWORD</span>   *lpidProcess,</span><br><span class="line">  <span class="built_in">DWORD</span>   cb,</span><br><span class="line">  LPDWORD lpcbNeeded</span><br><span class="line">)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p><strong>CreateToolhelp32Snapshot</strong>() API 같은 경우에는 프로세스에서 사용되는 힙, 모듈, 및 스레드의 스냅샷을 찍어서 프로세스에 대한 정보를 추출할 떄 사용하는 함수입니다. 프로세스와 관련된 모든 부분을 검색할 수도 있고, 일부분만 검색을 할 수 있습니다. 자세한 사항은 <a href="https://docs.microsoft.com/en-us/windows/win32/api/tlhelp32/nf-tlhelp32-createtoolhelp32snapshot" target="_blank" rel="noopener">MSDN</a>에서 검색해보시면 알 수 있습니다.</p><p><strong>EnumProcesses</strong>() API 같은 경우에는 프로세스 ID의 정보를 넘겨 받을 수 있는 함수이다. 이를 이용해서 MSDN에서 제공해주는 <a href="https://docs.microsoft.com/ko-kr/windows/win32/psapi/enumerating-all-processes?redirectedfrom=MSDN" target="_blank" rel="noopener">예제</a>처럼 프로세스 이름과 ID를 알아낼 수 있습니다.</p><p>-&gt; <a href="../ProcessSearch">해당 예제 실습은 여기서 확인.</a></p><p>위 2가지 API들은 모두 내부적으로 ntdll.ZwQuerySystemInformation() API를 호출한다고 합니다.</p><ul><li><ol start="2"><li>ZwQuerySystemInformation()</li></ol></li></ul><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS WINAPI ZwQuerySystemInformation(</span><br><span class="line">  <span class="variable">_In_</span>      SYSTEM_INFORMATION_CLASS SystemInformationClass,</span><br><span class="line">  <span class="variable">_Inout_</span>   PVOID                    SystemInformation,</span><br><span class="line">  <span class="variable">_In_</span>      ULONG                    SystemInformationLength,</span><br><span class="line">  <span class="variable">_Out_opt_</span> PULONG                   ReturnLength</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>ZwQuerySystemInformation</strong>() API를 이용하면 실행 중인 모든 프로세스의 구조체를 연결 리스트 형태로 얻을 수 있다고 합니다. 그 연결 리스트를 조작하면 해당 프로세스를 은폐 시킬 수 있게 됩니다.</p><p>그렇기에 유저 모드에서는 CreateToolhelp32Snpshort() 또는 EnumProcesses() API를 따로 후킹할 필요 없이 ZwQuerySystemInformation() API 하나만 후킹하면 확실하게 원하는 프로세스를 은폐 시킬 수 있다고 합니다.</p><br><h2 id="해당-기법의-문제점"><a href="#해당-기법의-문제점" class="headerlink" title="해당 기법의 문제점"></a>해당 기법의 문제점</h2><p>해당 기법을 통해서 하고 싶은 행위는 procexp.exe(프로세스 익스플로러), taskmgr.exe(윈도우 작업 관리자) 같은 프로세스 검색 유틸리티한테서 특정 프로세스를 숨기고 싶은 것입니다.</p><p>하지만 프로세스 검색 유틸리티는 이 두가지만 있는 것이 아닙니다. 수많은 프로세스 검색 유틸리티가 존재할 수도 있고, 사용자가 직접 만든 유틸리티도 있을 수 있습니다. 따라서<br><strong>시스템에 실행 중인 모든 프로세스를 후킹해야만 특정 프로세스가 은폐되었다고 볼 수 있습니다.</strong> 또한, 후킹을 하고 난후에 나중에 프로세스 검색 유틸리티가 실행이 되었다면, 나중에 실행된 유틸리티는 후킹되지 않았으므로 특정 프로세스를 검색할 수 있습니다. 따라서 <strong>나중에 실행되는 프로세스 검색 유틸리티 또한 자동으로 후킹될 수 있도록 작성해야지 특정 프로세스가 은폐되었다고 볼 수 있습니다.</strong></p><p>이러한 문제점을 가지고 있기 때문에 글로벌 후킹의 개념이 생겨났습니다. 시스템에 실행 중인 모든 프로세스를 후킹하고, 나중에 실행되는 모든 프로세스에 대해서도 후킹을 하는 것이 글로벌 후킹입니다.</p><p>먼저, 단순한 코드 패치를 통해서 스텔스 프로세스를 만드는 방법을 익히고, 다음 포스팅에서 글로벌 후킹을 통해서 문제점을 해결하는 방법을 익힐 예정입니다.</p><br><h2 id="분석"><a href="#분석" class="headerlink" title="분석"></a>분석</h2><p>나뭇잎 책에서 실습할 수 있도록, DLL을 인젝션할 수 있는 HideProc.exe 와 Stealth.dll 파일을 제공을 했습니다. Stealth.dll은 인젝션된 프로세스의 ntdll.ZwQuerySystemInformation() API를 후킹하는 역할을 합니다.</p><br><h3 id="HideProc-exe-gt-HookProc-cpp"><a href="#HideProc-exe-gt-HookProc-cpp" class="headerlink" title="HideProc.exe -&gt; HookProc.cpp"></a>HideProc.exe -&gt; HookProc.cpp</h3><p>HideProc.exe은 DLL을 인젝션 할 수 있는 인젝터입니다. 나뭇잎책에서 제공되어진 인젝터랑 다른 점은 InjectAllProcess() 함수 부분입니다.</p><p>InjectAllProcess() 함수에서 CreateTool32SnapShot() API를 이용해서 시스템에 실행 중인 모든 프로레스 리스트를 얻어내고, Process32First()와 Process32Next() API를 이용해서 프로세스 PID를 구하는 것을 확인할 수 있습니다.</p><p>이렇게 구해진 프로세스 PID를 가지고, 모든 프로세스한테 DLL을 인젝션합니다. 이때, 시스템 PID가 100 미만 프로세스들은 인젝션을 수행하지 않는데, 시스템 안정성 떄문에 그렇습니다. 실습 환경에 따라서 해당 부분은 적절하게 조절하면 됩니다.</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BOOL</span> <span class="built_in">InjectAllProcess</span>(int nMode, LPCTSTR szDllPath)</span><br><span class="line">&#123;</span><br><span class="line">DWORD                   dwPID = <span class="number">0</span>;</span><br><span class="line">HANDLE                  hSnapShot = INVALID_HANDLE_VALUE;</span><br><span class="line">PROCESSENTRY32          pe;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the snapshot of the system</span></span><br><span class="line">pe.dwSize = <span class="built_in">sizeof</span>(PROCESSENTRY32);</span><br><span class="line">hSnapShot = <span class="built_in">CreateToolhelp32Snapshot</span>(TH32CS_SNAPALL, <span class="built_in">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// find process</span></span><br><span class="line"><span class="built_in">Process32First</span>(hSnapShot, &amp;pe);</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">dwPID = pe.th32ProcessID;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 시스템의 안정성을 위해서</span></span><br><span class="line"><span class="comment">// PID 가 100 보다 작은 시스템 프로세스에 대해서는</span></span><br><span class="line"><span class="comment">// DLL Injection 을 수행하지 않는다.</span></span><br><span class="line"><span class="keyword">if</span> (dwPID &lt; <span class="number">100</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nMode == INJECTION_MODE)</span><br><span class="line"><span class="built_in">InjectDll</span>(dwPID, szDllPath);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">EjectDll</span>(dwPID, szDllPath);</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="built_in">Process32Next</span>(hSnapShot, &amp;pe));</span><br><span class="line"></span><br><span class="line"><span class="built_in">CloseHandle</span>(hSnapShot);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>하지만 Windows10 64bit 환경에서 인젝터가 중간에 멈추는 현상을 발견을 했습니다. 해당 코드를 확인 해보니 InjectDll() 함수내의 코드중 WaitForSingleObject()에서 쓰레드가 종료될 떄까지 무한히 기다리고 있다는 것을 알게 되었습니다. 그래서 시스템에서 실행 되고 있는 프로세스 중에서 CreateRemoteThread() API를 이용해서 DLL 인젝션이 되지 않는 프로세스가 있구나를 알게 되었습니다. 여기서의 목적은 프로세스 검색 유틸리티에 Stealth.dll을 인젝션해서 은폐 프로세스를 못보게 하는 것이라서 WaitForSingleObject(hThread,INFINITE); 를 WaitForSingleObject(hThread,1000); 으로 바꿨습니다. 이때, DLL 인젝션이 되지 않는 프로세스가 프로세스 검색 유틸리티가 아니라서 가능한 방법이었습니다.</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BOOL </span>InjectDll(DWORD dwPID, LPCTSTR szDllPath)</span><br><span class="line">&#123;</span><br><span class="line">HANDLE                  hProcess, hThread<span class="comment">;</span></span><br><span class="line">LPVOID                  pRemoteBuf<span class="comment">;</span></span><br><span class="line">DWORD                   dwBufSize = (DWORD)(_tcslen(szDllPath) + <span class="number">1</span>) * sizeof(TCHAR)<span class="comment">;</span></span><br><span class="line">LPTHREAD_START_ROUTINE  pThreadProc<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">if (!(hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID)))</span><br><span class="line">&#123;</span><br><span class="line">printf(<span class="string">"OpenProcess(%d) failed!!!\n"</span>, dwPID)<span class="comment">;</span></span><br><span class="line">return FALSE<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pRemoteBuf = VirtualAllocEx(hProcess, NULL, dwBufSize,</span><br><span class="line">MEM_COMMIT, PAGE_READWRITE)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">WriteProcessMemory(hProcess, pRemoteBuf,</span><br><span class="line">(LPVOID)szDllPath, dwBufSize, NULL)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">pThreadProc = (LPTHREAD_START_ROUTINE)</span><br><span class="line">GetProcAddress(GetModuleHandle(L<span class="string">"kernel32.dll"</span>),</span><br><span class="line"><span class="string">"LoadLibraryW"</span>)<span class="comment">;</span></span><br><span class="line">hThread = CreateRemoteThread(hProcess, NULL, <span class="number">0</span>,</span><br><span class="line">pThreadProc, pRemoteBuf, <span class="number">0</span>, NULL)<span class="comment">;</span></span><br><span class="line"><span class="keyword">WaitForSingleObject(hThread, </span><span class="number">1000</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">VirtualFreeEx(hProcess, pRemoteBuf, <span class="number">0</span>, MEM_RELEASE)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CloseHandle(hThread);</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">CloseHandle(hProcess);</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword"></span>return TRUE<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그리고, 그전에 HideProc.exe 프로세스의 권한을 상승시켜 놓아야지 전체 프로세스의 리스트를 정확하게 얻을 수 있습니다. 해당 코드에서 SetPrivilege() 함수를 보면, 내부적으로 AdjustTokenPrivileges() API 호출을 이용하여 프로세스의 권한을 상승시키는 것을 볼 수 있습니다. 하지만 프로세스의 권한을 상승시키지 않아도 프로세스의 리스트를 어느정도 뽑을 수 있고, DLL 인젝션도 정상적으로 동작합니다.</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">BOOL</span> SetPrivilege(LPCTSTR lpszPrivilege, <span class="built_in">BOOL</span> bEnablePrivilege)</span><br><span class="line">&#123;</span><br><span class="line">TOKEN_PRIVILEGES tp;</span><br><span class="line">HANDLE hToken;</span><br><span class="line">LUID luid;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!OpenProcessToken(GetCurrentProcess(),</span><br><span class="line">TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,</span><br><span class="line">&amp;hToken))</span><br><span class="line">&#123;</span><br><span class="line">printf(<span class="string">"OpenProcessToken error: %u\n"</span>, GetLastError());</span><br><span class="line"><span class="keyword">return</span> <span class="literal">FALSE</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!LookupPrivilegeValue(<span class="literal">NULL</span>,            <span class="comment">// lookup privilege on local system</span></span><br><span class="line">lpszPrivilege,   <span class="comment">// privilege to lookup </span></span><br><span class="line">&amp;luid))        <span class="comment">// receives LUID of privilege</span></span><br><span class="line">&#123;</span><br><span class="line">printf(<span class="string">"LookupPrivilegeValue error: %u\n"</span>, GetLastError());</span><br><span class="line"><span class="keyword">return</span> <span class="literal">FALSE</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tp.PrivilegeCount = <span class="number">1</span>;</span><br><span class="line">tp.Privileges[<span class="number">0</span>].Luid = luid;</span><br><span class="line"><span class="keyword">if</span> (bEnablePrivilege)</span><br><span class="line">tp.Privileges[<span class="number">0</span>].Attributes = SE_PRIVILEGE_ENABLED;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">tp.Privileges[<span class="number">0</span>].Attributes = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Enable the privilege or disable all privileges.</span></span><br><span class="line"><span class="keyword">if</span> (!AdjustTokenPrivileges(hToken,</span><br><span class="line"><span class="literal">FALSE</span>,</span><br><span class="line">&amp;tp,</span><br><span class="line"><span class="keyword">sizeof</span>(TOKEN_PRIVILEGES),</span><br><span class="line">(PTOKEN_PRIVILEGES)<span class="literal">NULL</span>,</span><br><span class="line">(PDWORD)<span class="literal">NULL</span>))</span><br><span class="line">&#123;</span><br><span class="line">printf(<span class="string">"AdjustTokenPrivileges error: %u\n"</span>, GetLastError());</span><br><span class="line"><span class="keyword">return</span> <span class="literal">FALSE</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (GetLastError() == ERROR_NOT_ALL_ASSIGNED)</span><br><span class="line">&#123;</span><br><span class="line">printf(<span class="string">"The token does not have the specified privilege. \n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">FALSE</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">TRUE</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h3 id="전체-소스-코드"><a href="#전체-소스-코드" class="headerlink" title="전체 소스 코드"></a>전체 소스 코드</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#include <span class="meta-string">"windows.h"</span></span></span><br><span class="line"><span class="meta">#include <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#include <span class="meta-string">"tlhelp32.h"</span></span></span><br><span class="line"><span class="meta">#include <span class="meta-string">"tchar.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (*PFN_SetProcName)(LPCTSTR szProcName);</span><br><span class="line"><span class="keyword">enum</span> &#123; INJECTION_MODE = <span class="number">0</span>, EJECTION_MODE &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">BOOL</span> SetPrivilege(LPCTSTR lpszPrivilege, <span class="built_in">BOOL</span> bEnablePrivilege)</span><br><span class="line">&#123;</span><br><span class="line">TOKEN_PRIVILEGES tp;</span><br><span class="line">HANDLE hToken;</span><br><span class="line">LUID luid;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!OpenProcessToken(GetCurrentProcess(),</span><br><span class="line">TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,</span><br><span class="line">&amp;hToken))</span><br><span class="line">&#123;</span><br><span class="line">printf(<span class="string">"OpenProcessToken error: %u\n"</span>, GetLastError());</span><br><span class="line"><span class="keyword">return</span> <span class="literal">FALSE</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!LookupPrivilegeValue(<span class="literal">NULL</span>,            <span class="comment">// lookup privilege on local system</span></span><br><span class="line">lpszPrivilege,   <span class="comment">// privilege to lookup </span></span><br><span class="line">&amp;luid))        <span class="comment">// receives LUID of privilege</span></span><br><span class="line">&#123;</span><br><span class="line">printf(<span class="string">"LookupPrivilegeValue error: %u\n"</span>, GetLastError());</span><br><span class="line"><span class="keyword">return</span> <span class="literal">FALSE</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tp.PrivilegeCount = <span class="number">1</span>;</span><br><span class="line">tp.Privileges[<span class="number">0</span>].Luid = luid;</span><br><span class="line"><span class="keyword">if</span> (bEnablePrivilege)</span><br><span class="line">tp.Privileges[<span class="number">0</span>].Attributes = SE_PRIVILEGE_ENABLED;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">tp.Privileges[<span class="number">0</span>].Attributes = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Enable the privilege or disable all privileges.</span></span><br><span class="line"><span class="keyword">if</span> (!AdjustTokenPrivileges(hToken,</span><br><span class="line"><span class="literal">FALSE</span>,</span><br><span class="line">&amp;tp,</span><br><span class="line"><span class="keyword">sizeof</span>(TOKEN_PRIVILEGES),</span><br><span class="line">(PTOKEN_PRIVILEGES)<span class="literal">NULL</span>,</span><br><span class="line">(PDWORD)<span class="literal">NULL</span>))</span><br><span class="line">&#123;</span><br><span class="line">printf(<span class="string">"AdjustTokenPrivileges error: %u\n"</span>, GetLastError());</span><br><span class="line"><span class="keyword">return</span> <span class="literal">FALSE</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (GetLastError() == ERROR_NOT_ALL_ASSIGNED)</span><br><span class="line">&#123;</span><br><span class="line">printf(<span class="string">"The token does not have the specified privilege. \n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">FALSE</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">TRUE</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">BOOL</span> InjectDll(DWORD dwPID, LPCTSTR szDllPath)</span><br><span class="line">&#123;</span><br><span class="line">HANDLE                  hProcess, hThread;</span><br><span class="line">LPVOID                  pRemoteBuf;</span><br><span class="line">DWORD                   dwBufSize = (DWORD)(_tcslen(szDllPath) + <span class="number">1</span>) * <span class="keyword">sizeof</span>(TCHAR);</span><br><span class="line">LPTHREAD_START_ROUTINE  pThreadProc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!(hProcess = OpenProcess(PROCESS_ALL_ACCESS, <span class="literal">FALSE</span>, dwPID)))</span><br><span class="line">&#123;</span><br><span class="line">printf(<span class="string">"OpenProcess(%d) failed!!!\n"</span>, dwPID);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">FALSE</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pRemoteBuf = VirtualAllocEx(hProcess, <span class="literal">NULL</span>, dwBufSize,</span><br><span class="line">MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line"></span><br><span class="line">WriteProcessMemory(hProcess, pRemoteBuf,</span><br><span class="line">(LPVOID)szDllPath, dwBufSize, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">pThreadProc = (LPTHREAD_START_ROUTINE)</span><br><span class="line">GetProcAddress(GetModuleHandle(L<span class="string">"kernel32.dll"</span>),</span><br><span class="line"><span class="string">"LoadLibraryW"</span>);</span><br><span class="line">hThread = CreateRemoteThread(hProcess, <span class="literal">NULL</span>, <span class="number">0</span>,</span><br><span class="line">pThreadProc, pRemoteBuf, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">WaitForSingleObject(hThread, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">VirtualFreeEx(hProcess, pRemoteBuf, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line"></span><br><span class="line">CloseHandle(hThread);</span><br><span class="line">CloseHandle(hProcess);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">TRUE</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">BOOL</span> EjectDll(DWORD dwPID, LPCTSTR szDllPath)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">BOOL</span>                    bMore = <span class="literal">FALSE</span>, bFound = <span class="literal">FALSE</span>;</span><br><span class="line">HANDLE                  hSnapshot, hProcess, hThread;</span><br><span class="line">MODULEENTRY32           me = &#123; <span class="keyword">sizeof</span>(me) &#125;;</span><br><span class="line">LPTHREAD_START_ROUTINE  pThreadProc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (INVALID_HANDLE_VALUE ==</span><br><span class="line">(hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, dwPID)))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">FALSE</span>;</span><br><span class="line"></span><br><span class="line">bMore = Module32First(hSnapshot, &amp;me);</span><br><span class="line"><span class="keyword">for</span> (; bMore; bMore = Module32Next(hSnapshot, &amp;me))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!_tcsicmp(me.szModule, szDllPath) ||</span><br><span class="line">!_tcsicmp(me.szExePath, szDllPath))</span><br><span class="line">&#123;</span><br><span class="line">bFound = <span class="literal">TRUE</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!bFound)</span><br><span class="line">&#123;</span><br><span class="line">CloseHandle(hSnapshot);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">FALSE</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!(hProcess = OpenProcess(PROCESS_ALL_ACCESS, <span class="literal">FALSE</span>, dwPID)))</span><br><span class="line">&#123;</span><br><span class="line">CloseHandle(hSnapshot);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">FALSE</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pThreadProc = (LPTHREAD_START_ROUTINE)</span><br><span class="line">GetProcAddress(GetModuleHandle(L<span class="string">"kernel32.dll"</span>),</span><br><span class="line"><span class="string">"FreeLibrary"</span>);</span><br><span class="line">hThread = CreateRemoteThread(hProcess, <span class="literal">NULL</span>, <span class="number">0</span>,</span><br><span class="line">pThreadProc, me.modBaseAddr, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">WaitForSingleObject(hThread, INFINITE);</span><br><span class="line"></span><br><span class="line">CloseHandle(hThread);</span><br><span class="line">CloseHandle(hProcess);</span><br><span class="line">CloseHandle(hSnapshot);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">TRUE</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">BOOL</span> InjectAllProcess(<span class="keyword">int</span> nMode, LPCTSTR szDllPath)</span><br><span class="line">&#123;</span><br><span class="line">DWORD                   dwPID = <span class="number">0</span>;</span><br><span class="line">HANDLE                  hSnapShot = INVALID_HANDLE_VALUE;</span><br><span class="line">PROCESSENTRY32          pe;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the snapshot of the system</span></span><br><span class="line">pe.dwSize = <span class="keyword">sizeof</span>(PROCESSENTRY32);</span><br><span class="line">hSnapShot = CreateToolhelp32Snapshot(TH32CS_SNAPALL, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// find process</span></span><br><span class="line">Process32First(hSnapShot, &amp;pe);</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">dwPID = pe.th32ProcessID;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 시스템의 안정성을 위해서</span></span><br><span class="line"><span class="comment">// PID 가 100 보다 작은 시스템 프로세스에 대해서는</span></span><br><span class="line"><span class="comment">// DLL Injection 을 수행하지 않는다.</span></span><br><span class="line"><span class="keyword">if</span> (dwPID &lt; <span class="number">100</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nMode == INJECTION_MODE)</span><br><span class="line">InjectDll(dwPID, szDllPath);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">EjectDll(dwPID, szDllPath);</span><br><span class="line">&#125; <span class="keyword">while</span> (Process32Next(hSnapShot, &amp;pe));</span><br><span class="line"></span><br><span class="line">CloseHandle(hSnapShot);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">TRUE</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span>                     nMode = INJECTION_MODE;</span><br><span class="line">HMODULE                 hLib = <span class="literal">NULL</span>;</span><br><span class="line">PFN_SetProcName         SetProcName = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (argc != <span class="number">4</span>)</span><br><span class="line">&#123;</span><br><span class="line">printf(<span class="string">"\n Usage  : HideProc.exe &lt;-hide|-show&gt; "</span>\</span><br><span class="line"><span class="string">"&lt;process name&gt; &lt;dll path&gt;\n\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// change privilege</span></span><br><span class="line">SetPrivilege(SE_DEBUG_NAME, <span class="literal">TRUE</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// load library</span></span><br><span class="line">hLib = LoadLibrary(argv[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// set process name to hide</span></span><br><span class="line">SetProcName = (PFN_SetProcName)GetProcAddress(hLib, <span class="string">"SetProcName"</span>);</span><br><span class="line">SetProcName(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Inject(Eject) Dll to all process</span></span><br><span class="line"><span class="keyword">if</span> (!_tcsicmp(argv[<span class="number">1</span>], L<span class="string">"-show"</span>))</span><br><span class="line">nMode = EJECTION_MODE;</span><br><span class="line"></span><br><span class="line">InjectAllProcess(nMode, argv[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// free library</span></span><br><span class="line">FreeLibrary(hLib);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h3 id="Stealth-dll-gt-stealth-cpp"><a href="#Stealth-dll-gt-stealth-cpp" class="headerlink" title="Stealth.dll -&gt; stealth.cpp"></a>Stealth.dll -&gt; stealth.cpp</h3><p>실제 API 후킹을 당담하는 DLL 파일입니다.</p><br><h4 id="SetProcName"><a href="#SetProcName" class="headerlink" title="SetProcName()"></a>SetProcName()</h4><p>SetProcName 함수는 export 함수이다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// global variable (in sharing memory)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(linker, <span class="meta-string">"/SECTION:.SHARE,RWS"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> data_seg(<span class="meta-string">".SHARE"</span>)</span></span><br><span class="line">TCHAR g_szProcName[MAX_PATH] = &#123; <span class="number">0</span>, &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> data_seg()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// export function</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">__declspec(dllexport) <span class="function"><span class="keyword">void</span> <span class="title">SetProcName</span><span class="params">(LPCTSTR szProcName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_tcscpy_s(g_szProcName, szProcName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>소스 코드를 보면, #pragma comment(linker, “/SECTION:.SHARE,RWS”) 전처리 구문을 통해서 “.SHARE”라는 데이터가 공유 가능한 메모리 섹션을 만들고, g_szProcName 버퍼를 생성을 한다는 것을 알 수 있습니다. 즉, 읽기, 쓰기, 공유 권한을 가진 데이터 섹션인 .SHARE를 만들어서 DLL 에 있는 데이터들을 공유할 때 사용하는 기법입니다. 이를 통해서 Stealth.dll이 모든 프로세스에 인젝션될 때 은폐 프로세스의 이름을 쉽게 공유할 수 있습니다.</p><p>#pragma comment() 전처리 구문을 통해서는 여러가지 일을 할 수 있습니다. 서브시스템을 설정한다거나 섹션을 설정한다거나 명시적으로 라이브러리를 링크한다거나 등을 할 수 있습니다. 프로젝트 관리에 들어가서 설정을 통해서 할 수 있는 부분들을 #pragma comment()를 통해서 편하게 설정을 할 수 있게 한 것입니다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(linker, <span class="meta-string">"/SECTION:.SHARE,RWS"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> data_seg(<span class="meta-string">".SHARE"</span>)</span></span><br><span class="line">TCHAR g_szProcName[MAX_PATH] = &#123; <span class="number">0</span>, &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> data_seg()</span></span><br></pre></td></tr></table></figure><p>다음 부분은 export 함수를 만드는 부분이다. C++과 C는 네임맹글링(Name Mangling) 많은 차이가 있습니다. C언어의 네임맹글링은 <em>cdecl 방식으로 컴파일 되었을 경우 단순히 함수 이름 앞에 “</em>“를 붙여주거나, <em>stdcall 방식으로 컴파일 되었을 경우 함수 이름 앞에 “</em>“을 붙여주고 함수 이름 마지막에 “@ordinal”을 붙여주는 방식으로 컴파일이 됩니다. 그에 반면 C++은 컴파일마다 네임맹글링 하는 방식이 다르며, 네임맹글링 하는 방식이 다르면 DLL을 만들 때, 링킹을 할 수 없는 상황이 벌어지기도 합니다. 따라서 C++을 이용해서 DLL을 만들었다고 하더라도 C module과 C++ module의 호환성을 위해서 extern “C” 키워를 사용을 하는 것입니다.</p><p>해당 관련 문서는 <a href="https://blueskywithyou.tistory.com/48" target="_blank" rel="noopener">이곳</a>을 찾아보면 된다. </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">__declspec(dllexport) <span class="function"><span class="keyword">void</span> <span class="title">SetProcName</span><span class="params">(LPCTSTR szProcName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_tcscpy_s(g_szProcName, szProcName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h4 id="DllMain"><a href="#DllMain" class="headerlink" title="DllMain()"></a>DllMain()</h4><p>다음은 DllMain() 함수이다.</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BOOL</span> WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span>            szCurProc[MAX_PATH] = &#123;<span class="number">0</span>,&#125;;</span><br><span class="line">    <span class="keyword">char</span>            *p = <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// #1. 예외처리</span></span><br><span class="line">    <span class="comment">// 현재 프로세스가 HookProc.exe 라면 후킹하지 않고 종료</span></span><br><span class="line">    GetModuleFileNameA(<span class="keyword">NULL</span>, szCurProc, MAX_PATH);</span><br><span class="line">    p = strrchr(szCurProc, <span class="string">'\\'</span>);</span><br><span class="line">    <span class="keyword">if</span>( (p != <span class="keyword">NULL</span>) &amp;&amp; !_stricmp(p+<span class="number">1</span>, <span class="string">"HideProc.exe"</span>) )</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">TRUE</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>( fdwReason )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// #2. API Hooking</span></span><br><span class="line">        <span class="keyword">case</span> DLL_PROCESS_ATTACH : </span><br><span class="line">        hook_by_code(DEF_NTDLL, DEF_ZWQUERYSYSTEMINFORMATION, </span><br><span class="line">                     (PROC)NewZwQuerySystemInformation, g_pOrgBytes);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// #3. API Unhooking </span></span><br><span class="line">        <span class="keyword">case</span> DLL_PROCESS_DETACH :</span><br><span class="line">        unhook_by_code(DEF_NTDLL, DEF_ZWQUERYSYSTEMINFORMATION, </span><br><span class="line">                       g_pOrgBytes);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">TRUE</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>코드를 보면, 문자열 비교를 통해 프로세스 이름이 “HookProc.exe” 인젝터라면 API 후킹하지 않도록 예외 처리를 하는 것을 알 수 있습니다. 그리고 DLL_PROCESS_ATACH 이벤트를 통해 hook_by_code() 함수로 API 후킹을 하고, unhook_by_code() 홤수를 통해 API 후킹을 해제하는 것을 볼 수 있습니다.</p><h4 id="hook-by-code"><a href="#hook-by-code" class="headerlink" title="hook_by_code()"></a>hook_by_code()</h4><p>다음은 코드 패치 기법을 이용해서 API 후킹하는 함수입니다. x86비트에서 후킹 하는 방법은 [Windows API Hooking - Code Patch](../15/Windows API Hooking - Code Patch) 글을 보면 된다. 현재 여기서는 코드를 살짝 수정해서 x64비트에서 API 후킹을 했습니다.</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">BYTE g_pOrgBytes[<span class="number">14</span>] = &#123; <span class="number">0</span>, &#125;;</span><br><span class="line">BOOL hook_by_code(LPCSTR szDllName, LPCSTR szFuncName, PROC pfnNew, PBYTE pOrgBytes)</span><br><span class="line">&#123;</span><br><span class="line">    FARPROC pfnOrg;</span><br><span class="line">    DWORD dwOldProtect;</span><br><span class="line">    BYTE pBuf1[<span class="number">6</span>] = &#123; <span class="number">0xFF</span>, <span class="number">0x25</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span> &#125;;</span><br><span class="line">    BYTE pBuf2[<span class="number">8</span>] = &#123; <span class="number">0</span>, &#125;;</span><br><span class="line">    PBYTE pByte;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 후킹 대상 API 주소를 구한다</span></span><br><span class="line">    pfnOrg = (FARPROC)GetProcAddress(GetModuleHandleA(szDllName), szFuncName);</span><br><span class="line">    pByte = (PBYTE)pfnOrg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 만약 후킹되어 있다면 return FALSE</span></span><br><span class="line">    if (pByte[<span class="number">0</span>] == <span class="number">0xFF</span> &amp;&amp; pByte[<span class="number">1</span>] == <span class="number">0x25</span>)</span><br><span class="line">        return <span class="literal">FALSE</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 기존코드 14바이트 백업 및 후킹 함수 시작 주소 구하기</span></span><br><span class="line">    memcpy(pOrgBytes, pfnOrg, <span class="number">14</span>);</span><br><span class="line">    memcpy(pBuf2, &amp;pfnNew, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 14바이트 패치를 위하여 메모리에 Write 속성 추가</span></span><br><span class="line">    VirtualProtect((LPVOID)pfnOrg, <span class="number">14</span>, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Hook: 14바이트 패치</span></span><br><span class="line">    memcpy(pfnOrg, pBuf1, <span class="number">6</span>);</span><br><span class="line">    memcpy((LPVOID)((DWORD_PTR)pfnOrg + <span class="number">6</span>), pBuf2, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 메모리에 속성 복원</span></span><br><span class="line">    VirtualProtect((LPVOID)pfnOrg, <span class="number">14</span>, dwOldProtect, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line">    return <span class="literal">TRUE</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Code Patch를 통해서 API 후킹할 떄, 32bit 환경에서는 JMP 명령어중 “E9 XXXXXXXX”를 사용 했었으면 되었습니다. 하지만 64bit 환경에서는 32bit 환경보다 가상메모리 공간이 훨씬 더 커지면서 해당 JMP 명령어를 통해서 후킹을 할 수가 없게 되었습니다. (32bit 가상메모리공간 -&gt; 4GB, 64bit 가상메모리공간 -&gt; 16TB)</p><p>따라서 새로운 방법을 찾아야 했는데, 그 중 한가지가 JMP 명령어중 <strong>“FF 25 XXXXXXXX”</strong>을 이용해서 패치하는 방식입니다. 이를 이용하면 8Byte 크기의 주소 공간을 이동할 수가 있습니다.</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x00007FFF</span> <span class="number">00000001</span> <span class="string">'FF 25 00000000'</span> <span class="keyword">JMP</span> <span class="built_in">QWORD</span> <span class="built_in">PTR</span> <span class="built_in">ds</span>:[7FFF00000007] # <span class="keyword">JMP</span> <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">RIP</span>+addr0]</span><br><span class="line"><span class="number">0x00007FFF</span> <span class="number">00000007</span> <span class="string">'XXXXXXXX XXXXXXXX'</span> # 후킹 함수 주소</span><br></pre></td></tr></table></figure><p>FF25로 시작하는 JMP 명령어는 레지스터 RIP + offset(XXXXXXXX)을 더한 주소로 이동하는 방식입니다. 이를 통해서 RIP+offset(XXXXXXXX) 주소에다가 후킹 함수 주소를 넣음으로써, 후킹 함수로 이동하게 되는 테크닉입니다.</p><p>이외에도 여러가지 방법이 존재하는데, 다른 방법은 <a href="../../15/WindowsX64Hooking">WindowsX64Hooking</a> 글을 참고하면 됩니다.</p><br><h5 id="unhook-by-code"><a href="#unhook-by-code" class="headerlink" title="unhook_by_code()"></a>unhook_by_code()</h5><p>다음은 후킹을 해제하는 unhook_by_code() 함수입니다.</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">BOOL unhook_by_code(LPCSTR szDllName, LPCSTR szFuncName, PBYTE pOrgBytes)</span><br><span class="line">&#123;</span><br><span class="line">    FARPROC pfnOrg;</span><br><span class="line">    DWORD dwOldProtect;</span><br><span class="line">    PBYTE pByte;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// API 주소를 구한다.</span></span><br><span class="line">    pfnOrg = GetProcAddress(GetModuleHandleA(szDllName), szFuncName);</span><br><span class="line">    pByte = (PBYTE)pfnOrg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 만약 이미 언후킹되어 있다면 FALSE</span></span><br><span class="line">    if (pByte[<span class="number">0</span>] != <span class="number">0xFF</span> &amp;&amp; pByte[<span class="number">1</span>] != <span class="number">0x25</span>)</span><br><span class="line">        return <span class="literal">FALSE</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 기존 코드 14바이트를 덮어쓰기 위헤 메모리에 WRITE 속성 추가</span></span><br><span class="line">    VirtualProtect((LPVOID)pfnOrg, <span class="number">14</span>, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// unHook: 14바이트 패치</span></span><br><span class="line">    memcpy(pfnOrg, pOrgBytes, <span class="number">14</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 메모리 속성 복원</span></span><br><span class="line">    VirtualProtect((LPVOID)pfnOrg, <span class="number">14</span>, dwOldProtect, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line">    return <span class="literal">TRUE</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>언훅의 동작 원리는 원래 코드의 14바이트를 복원을 하는 것입니다.</p><br><h4 id="NewZwQuerySystemInformation"><a href="#NewZwQuerySystemInformation" class="headerlink" title="NewZwQuerySystemInformation()"></a>NewZwQuerySystemInformation()</h4><p>다음은 후킹 함수 NewZwQuerySystemInformation() 입니다. 해당 함수의 동작원리를 알기 위해서는 ntdll.ZwQuerySystemInformation() API에 대해 먼저 알아야 합니다.</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS WINAPI ZwQuerySystemInformation(</span><br><span class="line">  <span class="variable">_In_</span>      SYSTEM_INFORMATION_CLASS SystemInformationClass,</span><br><span class="line">  <span class="variable">_Inout_</span>   PVOID                    SystemInformation,</span><br><span class="line">  <span class="variable">_In_</span>      ULONG                    SystemInformationLength,</span><br><span class="line">  <span class="variable">_Out_opt_</span> PULONG                   ReturnLength</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>ntdll.ZwQuerySystemInformation() 은 지정된 시스템 정보를 검색하는데 사용하는 API 라고 합니다. 근데 Windows 8부터는 사용할 수 없다고 합니다. 하지만 Windows 10 64bit에서도 사용이 가능했습니다. 그 이유는 …? 새롭게 Windows 10 64bit에서 사용할 수 있게 하고 MSDN을 업데이트 하지 않은 것인가?</p><p>그리고 ntdll.ZwQuerySystemInformation() API의 MSDN 보다 ntdll.NtQuerySystemInformation() API의 MSDN에 내용이 더 자세합니다. 따라서 해당 함수를 이용할 때,<br><a href="https://docs.microsoft.com/en-us/windows/win32/api/winternl/nf-winternl-ntquerysysteminformation" target="_blank" rel="noopener">NtQuerySystemInformation - MSDN</a>글 또한 참고하는 것이 좋은 것 같습니다.</p><p>Nt와 Zw의 차이점을 검색을 해보니 둘다 똑같은 커널 모드에서 동작하도록 설계된 루틴들의 집합체라고 합니다. 시스템콜, 즉 커널함수 라고 볼 수 있습니다. 예를 들어, CreateFile()을 호출을 하면, NtCreateFile() 또는 ZwCreateFile()을 내부적으로 호출을 하는 것입니다.</p><p>이러한 Native Service API들은 거의 동일한 동작을 수행한다고 합니다. 하지만, 커널 모드에서 파라미터들을 다루는 방식이 다르다고 합니다. 커널 모드에서 Zw루틴이 호출되면, 파라미터들이 이미 검증된 파라미터라고 생각하고 파라미터 검증과정을 건더뛰고 수행된다고 합니따 반면에 Nt루틴이 호출되면, 유저모드이건 커널모드이건 Nt루틴 내부적으로 파리미터를 검증한느 과정을 거치고 호출이 되는 방식이라고 합니다.</p><p>참고한 부분은 <a href="https://sone.tistory.com/235" target="_blank" rel="noopener">참고 자료</a>에도 링크를 걸었습니다. 다음은 함수 파라미터에 대한 설명입니다.</p><ul><li>SystemInformationClass</li></ul><p>검색 할 시스템 정보의 종류를 나타내는 SYSTEM_INFORMATION_CLASS에 열겨된 값중 하나를 지정합니다. SystemBasicInformation, SystemCodeIntegrityInformation, SystemProcessInformation 등 여러가지가 있다. 더 자세한 사항은 MSDN을 참고 하면 됩니다.</p><p>여기서 사용할 값은 <strong>SystmeProcessInformation</strong> 입니다. 해당 값을 지정하면, 시스템에서 실행중인 각 프로세스마다 하나씩 <strong>SYSTEM_PROCESS_INFORMATION 구조체 배열을 리턴</strong>합니다. 해당 구조체에는 프로세스에 사용된 스레드 및 핸들 수,  peak 페이지 파일 사용량 및 프로세스가 할당 한 메모리 페이지 수를 포함하여 각 <strong>프로세스의 자원 사용량에 대한 정보</strong>가 포함된다고 합니다.</p><ul><li>SystemInformation</li></ul><p>요청된 정보를 받는 버퍼에 대한 포인터를 지정합니다. 해당 파라미터는 SystemInformationClass 파라미터에서 어떤 시스템 종류를 나타낼지 선택한 거에 따라서 달라집니다. </p><p>SystemProcessInformation을 선택했다면, 해당 파리미터는 각각의 프로세스를 위한 프로세스 정보를 가지고 있는 SYSTEM_PROCESS_INFORMATION 구조체를 가지고 있다고 합니다. 또한 SYSTEM_THREAD_INFORMATION 구조체 메모리로 이어질 수 있다고 합니다. 즉, 프로세스 정보 뿐만 아니라 쓰레드 정보 뿐만 얻을 수 있습니다.</p><p>그리고, SystemInformation 파라미터가 가라키는 버퍼가 실행중인 프로세스 및 스레드 만큼 많은 SYSTEM_PROCESS_INFORMATION 및 SYSTEM_THREAD_INFORMATION 구조체를 포함하는 배열을 보유할 수 있을 정도로 커야한다는 점에서 SystemInformation 파라미터에 SYSTEM_PROCESS_INFORMATION 구조체가 배열처럼 쭈욱 기다랗게 연결되어 있다는 것을 알 수 있습니다.</p><p>ZwQuerySystemInformation 과 NtQuerySystemInformation에서의 SYSTEM_PROCESS_INFORMATION의 레이아웃이 다르므로 MSDN을 참고하셔야 합니다. ZwQuerySystemInformation의 SYSTEM_PROCESS_INFORMATION 은 다음과 같습니다.</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _SYSTEM_PROCESS_INFORMATION &#123;</span><br><span class="line">    <span class="type">ULONG</span> <span class="type">NextEntryOffset</span>;</span><br><span class="line">    <span class="type">ULONG</span> <span class="type">NumberOfThreads</span>;</span><br><span class="line">    <span class="type">BYTE</span> <span class="type">Reserved1</span>[48];</span><br><span class="line">    <span class="type">PVOID</span> <span class="type">Reserved2</span>[3];</span><br><span class="line">    <span class="type">HANDLE</span> <span class="type">UniqueProcessId</span>;</span><br><span class="line">    <span class="type">PVOID</span> <span class="type">Reserved3</span>;</span><br><span class="line">    <span class="type">ULONG</span> <span class="type">HandleCount</span>;</span><br><span class="line">    <span class="type">BYTE</span> <span class="type">Reserved4</span>[4];</span><br><span class="line">    <span class="type">PVOID</span> <span class="type">Reserved5</span>[11];</span><br><span class="line">    <span class="type">SIZE_T</span> <span class="type">PeakPagefileUsage</span>;</span><br><span class="line">    <span class="type">SIZE_T</span> <span class="type">PrivatePageCount</span>;</span><br><span class="line">    <span class="type">LARGE_INTEGER</span> <span class="type">Reserved6</span>[6];</span><br><span class="line">&#125; <span class="type">SYSTEM_PROCESS_INFORMATION</span>, *<span class="type">PSYSTEM_PROCESS_INFORMATION</span>;</span><br></pre></td></tr></table></figure><ul><li>SystemInformationLength</li></ul><p>해당 파라미터는 SystemInformation 파라미터가 가리키는 버퍼 크기를 지정하면 됩니다.</p><ul><li>ReturnLength</li></ul><p>요정된 정보의 실제 크기를 반환 받고 싶을 때, 선택적으로 사용하는 파라미터입니다. 반환 값이 SystemInformationLength 파라미터 보다 작거나 같은 경우, 데이터를 SystemInformation 버퍼에 복사를 하고, 그렇지 않을 경우 NTSTATUS 오류 코드를 반환하고 요청된 데이터를 받는데 필요한 크기를 ReturnLength에 반환을 한다고 합니다.</p><br><p>즉, 책에서 설명했던 것처럼 ZwQuerySystemInformation() API를 호출할 때, SystemInformationClass 파라미터를 SystemProcessInformation(enum 값 : 5) 과 SystemInformationLength 파라미터에 충분한 크기를 입력하면, SystemInformation[inout] 파라미터에 SYSTEM_PROCESS_INFORMATION 구조체 싱글 링크드 리스트의 시작 주소가 저장된다는 것이 이해가 됩니다. 근데 해당 구조체내의 다음 구조체를 가리키는 값이 포인터가 아니고 NextEntryOffset 더해서 다음 구조체를 가리키는 것을 보아 연결 리스트가 아니라 배열 형태로 이루어진게 아닐까 생각이 듭니다. 배열 형태로 이루어진 것을 연결 리스트로 구현한 것처럼 다루는 느낌이 들었다. 그리고 해당 구조체 연결 리스트에 실행 중인 모든 프로세스의 정보가 담겨 있다는 것도 이해가 됩니다.</p><p>그래서 은폐하고 싶은 프로세스에 해당 하는 리스트 멤버를 찾아서 연결을 끊어버리면, 해당 항목이 유실되어있기 때문에 프로세스 검색 유틸리티가 CreateToolhelp32Snapshot() 또는 EnumProcesses() API를 통해서 은폐 프로세스에 대한 정보를 검색할 수 없게 되어서 자기 자신을 숨길 수 있게 되는 것입니다.</p><p>다음은 NewZwQuerySystemInformation() 소스 코드입니다.</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS WINAPI NewZwQuerySystemInformation(</span><br><span class="line">    SYSTEM_INFORMATION_CLASS SystemInformationClass,</span><br><span class="line">    PVOID SystemInformation,</span><br><span class="line">    <span class="keyword">ULONG</span> SystemInformationLength,</span><br><span class="line">    PULONG ReturnLength)</span><br><span class="line">&#123;</span><br><span class="line">    NTSTATUS status;</span><br><span class="line">    FARPROC pFunc;</span><br><span class="line">    PSYSTEM_PROCESS_INFORMATION pCur, pPrev = &#123; <span class="number">0</span>, &#125;;</span><br><span class="line">    <span class="keyword">char</span> szProcName[MAX_PATH] = &#123; <span class="number">0</span>, &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 작업 전에 unhook</span></span><br><span class="line">    unhook_by_code(DEF_NTDLL, DEF_ZWQUERYSYSTEMINFORMATION, g_pOrgBytes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// original API 호출</span></span><br><span class="line">    pFunc = GetProcAddress(GetModuleHandleA(DEF_NTDLL),</span><br><span class="line">        DEF_ZWQUERYSYSTEMINFORMATION);</span><br><span class="line">    status = ((PFZWQUERYSYSTEMINFORMATION)pFunc)</span><br><span class="line">        (SystemInformationClass, SystemInformation,</span><br><span class="line">            SystemInformationLength, ReturnLength);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (status != STATUS_SUCCESS)</span><br><span class="line">        <span class="keyword">goto</span> __NTQUERYSYSTEMINFORMATION_END;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// SystemProcessInformation 인 경우만 작업함</span></span><br><span class="line">    <span class="keyword">if</span> (SystemInformationClass == SystemProcessInformation)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// SYSTEM_PROCESS_INFORMATION 타입 캐스팅</span></span><br><span class="line">        <span class="comment">// pCur 는 single linked list 의 head</span></span><br><span class="line">        pCur = (PSYSTEM_PROCESS_INFORMATION)SystemInformation;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">TRUE</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 프로세스 이름 비교</span></span><br><span class="line">            <span class="comment">// g_szProcName = 은폐하려는 프로세스 이름</span></span><br><span class="line">            <span class="comment">// (=&gt; SetProcName() 에서 세팅됨)</span></span><br><span class="line">            <span class="keyword">if</span> (pCur-&gt;Reserved2[<span class="number">1</span>] != <span class="keyword">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!_tcsicmp((PWSTR)pCur-&gt;Reserved2[<span class="number">1</span>], g_szProcName))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 연결 리스트에서 은폐 프로세스 제거</span></span><br><span class="line">                    <span class="keyword">if</span> (pCur-&gt;NextEntryOffset == <span class="number">0</span>)</span><br><span class="line">                        pPrev-&gt;NextEntryOffset = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        pPrev-&gt;NextEntryOffset += pCur-&gt;NextEntryOffset;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    pPrev = pCur;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (pCur-&gt;NextEntryOffset == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 연결 리스트의 다음 항목</span></span><br><span class="line">            pCur = (PSYSTEM_PROCESS_INFORMATION)</span><br><span class="line">                ((DWORD_PTR)pCur + pCur-&gt;NextEntryOffset);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">__NTQUERYSYSTEMINFORMATION_END:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 함수 종료 전에 다시 API Hooking</span></span><br><span class="line">    hook_by_code(DEF_NTDLL, DEF_ZWQUERYSYSTEMINFORMATION,</span><br><span class="line">        (PROC)NewZwQuerySystemInformation, g_pOrgBytes);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>후킹 함수 NewZwQuerySystemInformation()의 로직은 주석 처리가 되있어서 알아보기 쉽게 되어 있습니다. 또한 자료구조 연결 리스트를 구현해본 경험이 있다면, 그렇게 어렵지 않은 코드인 것 같습니다.</p><p>먼저, 언훅을 통해서 원본 ZwQuerySystemInformation() API로 돌려놓고, 해당 API를 호출을 합니다. 호출을 통해서 얻은 SystemProcessInformation 구조체를 연결 리스트 형식으로 검사하면서 은폐 시키고 싶은 프로세스 이름을 찾습니다. 찾았다면 SystemProcessInformation 구조체 연결을 끊어버립니다. 그리고 나서 후킹을 다시 걸고 status(NTSTATUS) 값을 반환해주면 됩니다. </p><br><h4 id="Stealth-cpp-소스코드"><a href="#Stealth-cpp-소스코드" class="headerlink" title="Stealth.cpp 소스코드"></a>Stealth.cpp 소스코드</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"windows.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"tchar.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STATUS_SUCCESS                      (0x00000000L) </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> LONG NTSTATUS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> _SYSTEM_INFORMATION_CLASS &#123;</span><br><span class="line">    SystemBasicInformation = <span class="number">0</span>,</span><br><span class="line">    SystemPerformanceInformation = <span class="number">2</span>,</span><br><span class="line">    SystemTimeOfDayInformation = <span class="number">3</span>,</span><br><span class="line">    SystemProcessInformation = <span class="number">5</span>,</span><br><span class="line">    SystemProcessorPerformanceInformation = <span class="number">8</span>,</span><br><span class="line">    SystemInterruptInformation = <span class="number">23</span>,</span><br><span class="line">    SystemExceptionInformation = <span class="number">33</span>,</span><br><span class="line">    SystemRegistryQuotaInformation = <span class="number">37</span>,</span><br><span class="line">    SystemLookasideInformation = <span class="number">45</span></span><br><span class="line">&#125; SYSTEM_INFORMATION_CLASS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SYSTEM_PROCESS_INFORMATION</span> &#123;</span></span><br><span class="line">    ULONG NextEntryOffset;</span><br><span class="line">    ULONG NumberOfThreads;</span><br><span class="line">    BYTE Reserved1[<span class="number">48</span>];</span><br><span class="line">    PVOID Reserved2[<span class="number">3</span>];</span><br><span class="line">    HANDLE UniqueProcessId;</span><br><span class="line">    PVOID Reserved3;</span><br><span class="line">    ULONG HandleCount;</span><br><span class="line">    BYTE Reserved4[<span class="number">4</span>];</span><br><span class="line">    PVOID Reserved5[<span class="number">11</span>];</span><br><span class="line">    SIZE_T PeakPagefileUsage;</span><br><span class="line">    SIZE_T PrivatePageCount;</span><br><span class="line">    LARGE_INTEGER Reserved6[<span class="number">6</span>];</span><br><span class="line">&#125; SYSTEM_PROCESS_INFORMATION, * PSYSTEM_PROCESS_INFORMATION;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NTSTATUS</span><span class="params">(WINAPI* PFZWQUERYSYSTEMINFORMATION)</span></span></span><br><span class="line"><span class="function"><span class="params">(SYSTEM_INFORMATION_CLASS SystemInformationClass,</span></span></span><br><span class="line"><span class="function"><span class="params">    PVOID SystemInformation,</span></span></span><br><span class="line"><span class="function"><span class="params">    ULONG SystemInformationLength,</span></span></span><br><span class="line"><span class="function"><span class="params">    PULONG ReturnLength)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEF_NTDLL                       (<span class="meta-string">"ntdll.dll"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEF_ZWQUERYSYSTEMINFORMATION    (<span class="meta-string">"ZwQuerySystemInformation"</span>)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// global variable (in sharing memory)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(linker, <span class="meta-string">"/SECTION:.SHARE,RWS"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> data_seg(<span class="meta-string">".SHARE"</span>)</span></span><br><span class="line">TCHAR g_szProcName[MAX_PATH] = &#123; <span class="number">0</span>, &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> data_seg()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// global variable</span></span><br><span class="line">BYTE g_pOrgBytes[<span class="number">14</span>] = &#123; <span class="number">0</span>, &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">hook_by_code</span><span class="params">(LPCSTR szDllName, LPCSTR szFuncName, PROC pfnNew, PBYTE pOrgBytes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FARPROC pfnOrg;</span><br><span class="line">    DWORD dwOldProtect;</span><br><span class="line">    BYTE pBuf1[<span class="number">6</span>] = &#123; <span class="number">0xFF</span>, <span class="number">0x25</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span> &#125;;</span><br><span class="line">    BYTE pBuf2[<span class="number">8</span>] = &#123; <span class="number">0</span>, &#125;;</span><br><span class="line">    PBYTE pByte;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 후킹 대상 API 주소를 구한다</span></span><br><span class="line">    pfnOrg = (FARPROC)GetProcAddress(GetModuleHandleA(szDllName), szFuncName);</span><br><span class="line">    pByte = (PBYTE)pfnOrg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 만약 후킹되어 있다면 return FALSE</span></span><br><span class="line">    <span class="keyword">if</span> (pByte[<span class="number">0</span>] == <span class="number">0xFF</span> &amp;&amp; pByte[<span class="number">1</span>] == <span class="number">0x25</span>)</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 기존코드 14바이트 백업 및 후킹 함수 시작 주소 구하기</span></span><br><span class="line">    <span class="built_in">memcpy</span>(pOrgBytes, pfnOrg, <span class="number">14</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(pBuf2, &amp;pfnNew, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 14바이트 패치를 위하여 메모리에 Write 속성 추가</span></span><br><span class="line">    VirtualProtect((LPVOID)pfnOrg, <span class="number">14</span>, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Hook: 14바이트 패치</span></span><br><span class="line">    <span class="built_in">memcpy</span>(pfnOrg, pBuf1, <span class="number">6</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>((LPVOID)((DWORD_PTR)pfnOrg + <span class="number">6</span>), pBuf2, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 메모리에 속성 복원</span></span><br><span class="line">    VirtualProtect((LPVOID)pfnOrg, <span class="number">14</span>, dwOldProtect, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">unhook_by_code</span><span class="params">(LPCSTR szDllName, LPCSTR szFuncName, PBYTE pOrgBytes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FARPROC pfnOrg;</span><br><span class="line">    DWORD dwOldProtect;</span><br><span class="line">    PBYTE pByte;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// API 주소를 구한다.</span></span><br><span class="line">    pfnOrg = GetProcAddress(GetModuleHandleA(szDllName), szFuncName);</span><br><span class="line">    pByte = (PBYTE)pfnOrg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 만약 이미 언후킹되어 있다면 FALSE</span></span><br><span class="line">    <span class="keyword">if</span> (pByte[<span class="number">0</span>] != <span class="number">0xFF</span> &amp;&amp; pByte[<span class="number">1</span>] != <span class="number">0x25</span>)</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 기존 코드 14바이트를 덮어쓰기 위헤 메모리에 WRITE 속성 추가</span></span><br><span class="line">    VirtualProtect((LPVOID)pfnOrg, <span class="number">14</span>, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// unHook: 14바이트 패치</span></span><br><span class="line">    <span class="built_in">memcpy</span>(pfnOrg, pOrgBytes, <span class="number">14</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 메모리 속성 복원</span></span><br><span class="line">    VirtualProtect((LPVOID)pfnOrg, <span class="number">14</span>, dwOldProtect, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS WINAPI <span class="title">NewZwQuerySystemInformation</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    SYSTEM_INFORMATION_CLASS SystemInformationClass,</span></span></span><br><span class="line"><span class="function"><span class="params">    PVOID SystemInformation,</span></span></span><br><span class="line"><span class="function"><span class="params">    ULONG SystemInformationLength,</span></span></span><br><span class="line"><span class="function"><span class="params">    PULONG ReturnLength)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NTSTATUS status;</span><br><span class="line">    FARPROC pFunc;</span><br><span class="line">    PSYSTEM_PROCESS_INFORMATION pCur, pPrev = &#123; <span class="number">0</span>, &#125;;</span><br><span class="line">    <span class="keyword">char</span> szProcName[MAX_PATH] = &#123; <span class="number">0</span>, &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 작업 전에 unhook</span></span><br><span class="line">    unhook_by_code(DEF_NTDLL, DEF_ZWQUERYSYSTEMINFORMATION, g_pOrgBytes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// original API 호출</span></span><br><span class="line">    pFunc = GetProcAddress(GetModuleHandleA(DEF_NTDLL),</span><br><span class="line">        DEF_ZWQUERYSYSTEMINFORMATION);</span><br><span class="line">    status = ((PFZWQUERYSYSTEMINFORMATION)pFunc)</span><br><span class="line">        (SystemInformationClass, SystemInformation,</span><br><span class="line">            SystemInformationLength, ReturnLength);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (status != STATUS_SUCCESS)</span><br><span class="line">        <span class="keyword">goto</span> __NTQUERYSYSTEMINFORMATION_END;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// SystemProcessInformation 인 경우만 작업함</span></span><br><span class="line">    <span class="keyword">if</span> (SystemInformationClass == SystemProcessInformation)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// SYSTEM_PROCESS_INFORMATION 타입 캐스팅</span></span><br><span class="line">        <span class="comment">// pCur 는 single linked list 의 head</span></span><br><span class="line">        pCur = (PSYSTEM_PROCESS_INFORMATION)SystemInformation;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (TRUE)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 프로세스 이름 비교</span></span><br><span class="line">            <span class="comment">// g_szProcName = 은폐하려는 프로세스 이름</span></span><br><span class="line">            <span class="comment">// (=&gt; SetProcName() 에서 세팅됨)</span></span><br><span class="line">            <span class="keyword">if</span> (pCur-&gt;Reserved2[<span class="number">1</span>] != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!_tcsicmp((PWSTR)pCur-&gt;Reserved2[<span class="number">1</span>], g_szProcName))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 연결 리스트에서 은폐 프로세스 제거</span></span><br><span class="line">                    <span class="keyword">if</span> (pCur-&gt;NextEntryOffset == <span class="number">0</span>)</span><br><span class="line">                        pPrev-&gt;NextEntryOffset = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        pPrev-&gt;NextEntryOffset += pCur-&gt;NextEntryOffset;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    pPrev = pCur;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (pCur-&gt;NextEntryOffset == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 연결 리스트의 다음 항목</span></span><br><span class="line">            pCur = (PSYSTEM_PROCESS_INFORMATION)</span><br><span class="line">                ((DWORD_PTR)pCur + pCur-&gt;NextEntryOffset);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">__NTQUERYSYSTEMINFORMATION_END:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 함수 종료 전에 다시 API Hooking</span></span><br><span class="line">    hook_by_code(DEF_NTDLL, DEF_ZWQUERYSYSTEMINFORMATION,</span><br><span class="line">        (PROC)NewZwQuerySystemInformation, g_pOrgBytes);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL WINAPI <span class="title">DllMain</span><span class="params">(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>            szCurProc[MAX_PATH] = &#123; <span class="number">0</span>, &#125;;</span><br><span class="line">    <span class="keyword">char</span>* p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// #1. 예외처리</span></span><br><span class="line">    <span class="comment">// 현재 프로세스가 HookProc.exe 라면 후킹하지 않고 종료</span></span><br><span class="line">    GetModuleFileNameA(<span class="literal">NULL</span>, szCurProc, MAX_PATH);</span><br><span class="line">    p = <span class="built_in">strrchr</span>(szCurProc, <span class="string">'\\'</span>);</span><br><span class="line">    <span class="keyword">if</span> ((p != <span class="literal">NULL</span>) &amp;&amp; !_stricmp(p + <span class="number">1</span>, <span class="string">"HideProc.exe"</span>))</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (fdwReason)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// #2. API Hooking</span></span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">        hook_by_code(DEF_NTDLL, DEF_ZWQUERYSYSTEMINFORMATION,</span><br><span class="line">            (PROC)NewZwQuerySystemInformation, g_pOrgBytes);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// #3. API Unhooking </span></span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">        unhook_by_code(DEF_NTDLL, DEF_ZWQUERYSYSTEMINFORMATION,</span><br><span class="line">            g_pOrgBytes);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    __declspec(dllexport) <span class="function"><span class="keyword">void</span> <span class="title">SetProcName</span><span class="params">(LPCTSTR szProcName)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _tcscpy_s(g_szProcName, szProcName);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><br><h2 id="실행-결과"><a href="#실행-결과" class="headerlink" title="실행 결과"></a>실행 결과</h2><img src="/2020/01/16/WindowsAPIHookingStealthProcess-1/1.png" title="후킹1"><img src="/2020/01/16/WindowsAPIHookingStealthProcess-1/2.png" title="후킹2"><br><h2 id="마지막으로"><a href="#마지막으로" class="headerlink" title="마지막으로.."></a>마지막으로..</h2><p>여기까지가 코드 패치를 통한 스텔스 프로세스를 구현하는 기법에 대한 내용이었습니다. 다음번 포스팅에서는 글로벙 API 후킹을 통해서 앞서 언급했던 문제점을 해결할 것입니다.</p><br><h2 id="참고자료"><a href="#참고자료" class="headerlink" title="참고자료"></a>참고자료</h2><p><a href="https://docs.microsoft.com/en-us/windows/win32/api/tlhelp32/nf-tlhelp32-createtoolhelp32snapshot" target="_blank" rel="noopener">CreateToolhelp32Snapshot()</a></p><p><a href="https://docs.microsoft.com/ko-kr/windows/win32/psapi/enumerating-all-processes?redirectedfrom=MSDN" target="_blank" rel="noopener">EnumProcesses()</a></p><p><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject</a>]</p><p><a href="https://blueskywithyou.tistory.com/48" target="_blank" rel="noopener">extern “C”</a></p><p><a href="https://sone.tistory.com/235" target="_blank" rel="noopener">Nt와 Zw Native Routine의 차이점</a></p><p><a href="https://jeep-shoes.tistory.com/66" target="_blank" rel="noopener">Nt/Zw Native API의 차이점</a></p>]]></content>
      
      
      <categories>
          
          <category> Windows Reversing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
            <tag> Windows Reversing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WindowsX64Hooking</title>
      <link href="/2020/01/15/WindowsX64Hooking/"/>
      <url>/2020/01/15/WindowsX64Hooking/</url>
      
        <content type="html"><![CDATA[<p>Code Patch를 통해서 API 후킹을 할 떄, 32bit 환경에서는 JMP Instruction 중 “E9 XXXXXXXX”를 사용하면 됬었다. 하지만 64bit 환경에서는 32bit 환경보다 가상메모리 공간이 훨씬더 커지면서 “E9 XXXXXXXX”을 이용해서는 안정적으로 후킹을 할 수가 없게 되었다. (32bit 가상메모리공간 -&gt; 4GB, 64bit 가상메모리공간 -&gt; 16TB)</p><p>따라서 64bit 환경에서는 32bit 환경에서 했던 것처럼 Code Patch를 하지 못한다. 다른 방법을 사용을 해야 한다. 64bit 환경에서 후킹 할 수 있는 방법을 찾는대로 계속 꾸준히 업데이트를 할 계획이다. 하지만 찾은 방법들이 안정적인지는 잘 모르겠다.</p><h2 id="후킹-방법-목록"><a href="#후킹-방법-목록" class="headerlink" title="후킹 방법 목록"></a>후킹 방법 목록</h2><p>다음 항목들은 64bit에서 후킹할 수 있는 방법들이다.</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 첫번째 방법 -&gt; <span class="number">14</span> 바이트</span><br><span class="line"><span class="number">0x00007FFF</span> <span class="number">00000001</span> <span class="string">'FF 25 00000000'</span> <span class="keyword">JMP</span> <span class="built_in">QWORD</span> <span class="built_in">PTR</span> <span class="built_in">ds</span>:[7FFF00000007] # <span class="keyword">JMP</span> <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">RIP</span>+addr0]</span><br><span class="line"><span class="number">0x00007FFF</span> <span class="number">00000007</span> <span class="string">'XXXXXXXX XXXXXXXX'</span> # 후킹 함수 주소</span><br><span class="line"></span><br><span class="line"># 두번째 방법 -&gt; <span class="number">12</span> 바이트</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">rax</span>, address # <span class="string">"48 b8 000000 000000"</span></span><br><span class="line"><span class="keyword">jmp</span> <span class="built_in">rax</span>          # <span class="string">"ff e0"</span></span><br><span class="line"></span><br><span class="line"># 세번째 방법 -&gt; <span class="number">14</span> 바이트</span><br><span class="line"><span class="keyword">push</span> 4byte_low_address</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">dword</span> <span class="built_in">ptr</span>[<span class="built_in">rsp</span>+<span class="number">4</span>], 4byte_high_address</span><br><span class="line"><span class="keyword">ret</span></span><br><span class="line"></span><br><span class="line"># 네번째 방법 -&gt; ?? 추후 업데이트</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">rax</span>, address</span><br><span class="line"><span class="keyword">call</span> <span class="built_in">rax</span></span><br></pre></td></tr></table></figure><br><h3 id="1-JMP-Instruction-“FF-25”"><a href="#1-JMP-Instruction-“FF-25”" class="headerlink" title="1. JMP Instruction “FF 25”"></a>1. JMP Instruction “FF 25”</h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x00007FFF</span> <span class="number">00000001</span> <span class="string">'FF 25 00000000'</span> <span class="keyword">JMP</span> <span class="built_in">QWORD</span> <span class="built_in">PTR</span> <span class="built_in">ds</span>:[7FFF00000007] # <span class="keyword">JMP</span> <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">RIP</span>+addr0]</span><br><span class="line"><span class="number">0x00007FFF</span> <span class="number">00000007</span> <span class="string">'XXXXXXXX XXXXXXXX'</span> # 후킹 함수 주소</span><br></pre></td></tr></table></figure><p>JMP Instruction 중에서 <strong>“FF 25 XXXXXXXX”</strong>를 이용하는 방법이다. FF25로 시작하는 JMP 명령어는 레지스터 RIP + offset(XXXXXXXX)을 더한 주소로 이동한다. 이를 통해서 RIP+offset(XXXXXXXX) 주소에다가 후킹 함수 주소를 넣으면, 후킹 함수로 이동할 수 있는 기법이다.</p><br><h4 id="테스트-코드"><a href="#테스트-코드" class="headerlink" title="테스트 코드"></a>테스트 코드</h4><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">#include <span class="string">"Windows.h"</span></span><br><span class="line">#include <span class="string">"stdio.h"</span></span><br><span class="line"></span><br><span class="line">BYTE g_pOrgBytes[<span class="number">14</span>] = &#123; <span class="number">0</span>, &#125;;</span><br><span class="line"></span><br><span class="line">BOOL hook(LPCSTR szDllName, LPCSTR szFuncName, PROC pfnNew, PBYTE pOrgBytes)</span><br><span class="line">&#123;</span><br><span class="line">FARPROC pfnOrg;</span><br><span class="line">DWORD dwOldProtect;</span><br><span class="line">BYTE pBuf1[<span class="number">6</span>] = &#123; <span class="number">0xFF</span>, <span class="number">0x25</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span> &#125;;</span><br><span class="line">BYTE pBuf2[<span class="number">8</span>] = &#123; <span class="number">0</span>, &#125;;</span><br><span class="line">PBYTE pByte;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 후킹 대상 API 주소를 구한다</span></span><br><span class="line">pfnOrg = (FARPROC)GetProcAddress(GetModuleHandleA(szDllName), szFuncName);</span><br><span class="line">pByte = (PBYTE)pfnOrg;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 만약 후킹되어 있다면 return FALSE</span></span><br><span class="line">if (pByte[<span class="number">0</span>] == <span class="number">0xFF</span> &amp;&amp; pByte[<span class="number">1</span>] == <span class="number">0x25</span>)</span><br><span class="line">return <span class="literal">FALSE</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 기존코드 14바이트 백업 및 후킹 함수 시작 주소 구하기</span></span><br><span class="line">memcpy(pOrgBytes, pfnOrg, <span class="number">14</span>);</span><br><span class="line">memcpy(pBuf2, &amp;pfnNew, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 14바이트 패치를 위하여 메모리에 Write 속성 추가</span></span><br><span class="line">VirtualProtect((LPVOID)pfnOrg, <span class="number">14</span>, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hook: 14바이트 패치</span></span><br><span class="line">memcpy(pfnOrg, pBuf1, <span class="number">6</span>);</span><br><span class="line">memcpy((LPVOID)((DWORD_PTR)pfnOrg + <span class="number">6</span>), pBuf2, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 메모리에 속성 복원</span></span><br><span class="line">VirtualProtect((LPVOID)pfnOrg, <span class="number">14</span>, dwOldProtect, &amp;dwOldProtect);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOL unhook(LPCSTR szDllName, LPCSTR szFuncName, PBYTE pOrgBytes)</span><br><span class="line">&#123;</span><br><span class="line">FARPROC pfnOrg;</span><br><span class="line">DWORD dwOldProtect;</span><br><span class="line">PBYTE pByte;</span><br><span class="line"></span><br><span class="line"><span class="comment">// API 주소를 구한다.</span></span><br><span class="line">pfnOrg = GetProcAddress(GetModuleHandleA(szDllName), szFuncName);</span><br><span class="line">pByte = (PBYTE)pfnOrg;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 만약 이미 언후킹되어 있다면 FALSE</span></span><br><span class="line">if (pByte[<span class="number">0</span>] != <span class="number">0xFF</span> &amp;&amp; pByte[<span class="number">1</span>] != <span class="number">0x25</span>)</span><br><span class="line">return <span class="literal">FALSE</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 기존 코드 14바이트를 덮어쓰기 위헤 메모리에 WRITE 속성 추가</span></span><br><span class="line">VirtualProtect((LPVOID)pfnOrg, <span class="number">14</span>, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line"><span class="comment">// unHook: 14바이트 패치</span></span><br><span class="line">memcpy(pfnOrg, pOrgBytes, <span class="number">14</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 메모리 속성 복원</span></span><br><span class="line">VirtualProtect((LPVOID)pfnOrg, <span class="number">14</span>, dwOldProtect, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line">return <span class="literal">TRUE</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MyMessageBox(HWND hWnd, LPCTSTR lpText, LPCTSTR lpCaption, UINT uType)</span><br><span class="line">&#123;</span><br><span class="line">unhook(<span class="string">"user32.dll"</span>, <span class="string">"MessageBoxA"</span>, g_pOrgBytes);</span><br><span class="line">MessageBoxA(NULL, <span class="string">"Code Patch API Hooking"</span>, <span class="string">"Hook"</span>, MB_OK);</span><br><span class="line">hook(<span class="string">"user32.dll"</span>, <span class="string">"MessageBoxA"</span>, (PROC)MyMessageBox, g_pOrgBytes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">HMODULE module = LoadLibraryA(<span class="string">"user32.dll"</span>);</span><br><span class="line"></span><br><span class="line">hook(<span class="string">"user32.dll"</span>, <span class="string">"MessageBoxA"</span>, (PROC)MyMessageBox, g_pOrgBytes);</span><br><span class="line">MessageBEoxA(NULL, <span class="string">"Hello, World!"</span>, <span class="string">"Earth"</span>, MB_OK);</span><br><span class="line">unhook(<span class="string">"user32.dll"</span>, <span class="string">"MessageBoxA"</span>, g_pOrgBytes);</span><br><span class="line">MessageBoxA(NULL, <span class="string">"Hello, World!"</span>, <span class="string">"Earth"</span>, MB_OK);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">FreeLibrary(module);</span><br><span class="line">return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h3 id="2-mov-amp-jmp-instruction"><a href="#2-mov-amp-jmp-instruction" class="headerlink" title="2. mov &amp; jmp instruction"></a>2. mov &amp; jmp instruction</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov rax,<span class="built_in"> address </span># <span class="string">"48 b8 000000 000000"</span></span><br><span class="line">jmp rax          # <span class="string">"ff e0"</span></span><br></pre></td></tr></table></figure><p>64bit 값을 가질 수 있는 레지스터를 이용해서 레지스터에 후킹 함수 주소값을 집어넣고, JMP 명령어를 통해서 후킹 함수쪽으로 실행흐름을 바꾸는 방법이다.</p><p>어떤 레지스터를 사용할 것인지에 따라서 machine code는 달라질 수 있다. mov 명령어를 통해 immu64 값을 rax의 집어 넣는 machine code 는 “48 b8 XXXXXXXX XXXXXXXX” 이고, rax 레지스터 값으로 이동하는 JMP의 machine code는 “ff e0” 이다.</p><br><h4 id="테스트-코드-1"><a href="#테스트-코드-1" class="headerlink" title="테스트 코드"></a>테스트 코드</h4><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">#include <span class="string">"Windows.h"</span></span><br><span class="line">#include <span class="string">"stdio.h"</span></span><br><span class="line"></span><br><span class="line">BYTE g_pOrgBytes[<span class="number">12</span>] = &#123; <span class="number">0</span>, &#125;;</span><br><span class="line"></span><br><span class="line">BOOL hook(LPCSTR szDllName, LPCSTR szFuncName, PROC pfnNew, PBYTE pOrgBytes)</span><br><span class="line">&#123;</span><br><span class="line">FARPROC pfnOrg;</span><br><span class="line">DWORD dwOldProtect;</span><br><span class="line">BYTE pBuf1[<span class="number">10</span>] = &#123; <span class="number">0x48</span>, <span class="number">0xb8</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span> &#125;;</span><br><span class="line">BYTE pBuf2[<span class="number">2</span>] = &#123; <span class="number">0xff</span>, <span class="number">0xe0</span>&#125;;</span><br><span class="line">PBYTE pByte;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 후킹 대상 API 주소를 구한다</span></span><br><span class="line">GetModuleHandleA(szDllName);</span><br><span class="line">pfnOrg = (FARPROC)GetProcAddress(GetModuleHandleA(szDllName), szFuncName);</span><br><span class="line">pByte = (PBYTE)pfnOrg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 만약 후킹되어 있다면 return FALSE</span></span><br><span class="line">if (pByte[<span class="number">0</span>] == <span class="number">0x48</span> &amp;&amp; pByte[<span class="number">1</span>] == <span class="number">0xb8</span>)</span><br><span class="line">return <span class="literal">FALSE</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 기존코드 12바이트 백업 및 후킹 함수 시작 주소 구하기</span></span><br><span class="line">memcpy(pOrgBytes, pfnOrg, <span class="number">12</span>);</span><br><span class="line">memcpy(pBuf1+<span class="number">2</span>, &amp;pfnNew, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 12바이트 패치를 위하여 메모리에 Write 속성 추가</span></span><br><span class="line">VirtualProtect((LPVOID)pfnOrg, <span class="number">12</span>, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hook: 12바이트 패치</span></span><br><span class="line">memcpy(pfnOrg, pBuf1, <span class="number">10</span>);</span><br><span class="line">memcpy((LPVOID)((DWORD_PTR)pfnOrg + <span class="number">10</span>), pBuf2, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 메모리에 속성 복원</span></span><br><span class="line">VirtualProtect((LPVOID)pfnOrg, <span class="number">12</span>, dwOldProtect, &amp;dwOldProtect);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOL unhook(LPCSTR szDllName, LPCSTR szFuncName, PBYTE pOrgBytes)</span><br><span class="line">&#123;</span><br><span class="line">FARPROC pfnOrg;</span><br><span class="line">DWORD dwOldProtect;</span><br><span class="line">PBYTE pByte;</span><br><span class="line"></span><br><span class="line"><span class="comment">// API 주소를 구한다.</span></span><br><span class="line">pfnOrg = GetProcAddress(GetModuleHandleA(szDllName), szFuncName);</span><br><span class="line">pByte = (PBYTE)pfnOrg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 만약 이미 언후킹되어 있다면 FALSE</span></span><br><span class="line">if (pByte[<span class="number">0</span>] != <span class="number">0x48</span> &amp;&amp; pByte[<span class="number">1</span>] != <span class="number">0xb8</span>)</span><br><span class="line">return <span class="literal">FALSE</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 기존 코드 12바이트를 덮어쓰기 위헤 메모리에 WRITE 속성 추가</span></span><br><span class="line">VirtualProtect((LPVOID)pfnOrg, <span class="number">12</span>, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line"><span class="comment">// unHook: 12바이트 패치</span></span><br><span class="line">memcpy(pfnOrg, pOrgBytes, <span class="number">12</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 메모리 속성 복원</span></span><br><span class="line">VirtualProtect((LPVOID)pfnOrg, <span class="number">12</span>, dwOldProtect, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MyMessageBox(HWND hWnd, LPCTSTR lpText, LPCTSTR lpCaption, UINT uType)</span><br><span class="line">&#123;</span><br><span class="line">unhook(<span class="string">"user32.dll"</span>, <span class="string">"MessageBoxA"</span>, g_pOrgBytes);</span><br><span class="line">MessageBoxA(NULL, <span class="string">"Code Patch API Hooking"</span>, <span class="string">"Hook"</span>, MB_OK);</span><br><span class="line">hook(<span class="string">"user32.dll"</span>, <span class="string">"MessageBoxA"</span>, (PROC)MyMessageBox, g_pOrgBytes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">HMODULE module = LoadLibraryA(<span class="string">"user32.dll"</span>);</span><br><span class="line"></span><br><span class="line">hook(<span class="string">"user32.dll"</span>, <span class="string">"MessageBoxA"</span>, (PROC)MyMessageBox, g_pOrgBytes);</span><br><span class="line">MessageBoxA(NULL, <span class="string">"Hello, World!"</span>, <span class="string">"Earth"</span>, MB_OK);</span><br><span class="line">unhook(<span class="string">"user32.dll"</span>, <span class="string">"MessageBoxA"</span>, g_pOrgBytes);</span><br><span class="line">MessageBoxA(NULL, <span class="string">"Hello, World!"</span>, <span class="string">"Earth"</span>, MB_OK);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">FreeLibrary(module);</span><br><span class="line">return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h3 id="3-push-amp-mov-amp-ret-instruction"><a href="#3-push-amp-mov-amp-ret-instruction" class="headerlink" title="3. push &amp; mov &amp; ret instruction"></a>3. push &amp; mov &amp; ret instruction</h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">push</span> 4byte_low_address</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">dword</span> <span class="built_in">ptr</span>[<span class="built_in">rsp</span>+<span class="number">4</span>], 4byte_high_address</span><br><span class="line"><span class="keyword">ret</span></span><br></pre></td></tr></table></figure><p>64bit에서는 64bit 레지스터 값을 push할 수 있는 명령어는 있지만, immu64 값을 push 할수 있는 명령어가 없다. 따라서 스택에 후킹 함수를 주소를 집어 넣으러면 push 4byte_low_address를 넣고, mov dword ptr[rsp+4], 4byte_high_address를 통해서 rsp값에 후킹 함수 주소를 설정해야 한다. 그 이후 ret 명령어를 통해서 후킹 함수쪽으로 실행흐름을 바꾸는 기법이다.</p><br><h4 id="테스트-코드-2"><a href="#테스트-코드-2" class="headerlink" title="테스트 코드"></a>테스트 코드</h4><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">#include <span class="string">"Windows.h"</span></span><br><span class="line">#include <span class="string">"stdio.h"</span></span><br><span class="line"></span><br><span class="line">BYTE g_pOrgBytes[<span class="number">14</span>] = &#123; <span class="number">0</span>, &#125;;</span><br><span class="line"></span><br><span class="line">void hook(LPCSTR szDllName, LPCSTR szFuncName, PROC pfnNew, PBYTE pOrgBytes)</span><br><span class="line">&#123;</span><br><span class="line">FARPROC pfnOrg;</span><br><span class="line">DWORD dwOldProtect;</span><br><span class="line">BYTE pBuf1[<span class="number">5</span>] = &#123; <span class="number">0x68</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>&#125;;</span><br><span class="line">BYTE pBuf2[<span class="number">8</span>] = &#123; <span class="number">0xc7</span>, <span class="number">0x44</span>, <span class="number">0x24</span> ,<span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span> &#125;;</span><br><span class="line">BYTE pBuf3[<span class="number">1</span>] = &#123; <span class="number">0xc3</span> &#125;;</span><br><span class="line"><span class="comment">//PBYTE pByte;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 후킹 대상 API 주소를 구한다</span></span><br><span class="line">GetModuleHandleA(szDllName);</span><br><span class="line">pfnOrg = (FARPROC)GetProcAddress(GetModuleHandleA(szDllName), szFuncName);</span><br><span class="line"><span class="comment">//pByte = (PBYTE)pfnOrg;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 기존코드 14바이트 백업 및 후킹 함수 시작 주소 구하기</span></span><br><span class="line">memcpy(pOrgBytes, pfnOrg, <span class="number">14</span>);</span><br><span class="line">memcpy(pBuf1 + <span class="number">1</span>, &amp;pfnNew, <span class="number">4</span>);</span><br><span class="line">for (int i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">pBuf2[i + <span class="number">4</span>] = (BYTE)((DWORD_PTR)pfnNew &gt;&gt; <span class="number">32</span> + i * <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 14바이트 패치를 위하여 메모리에 Write 속성 추가</span></span><br><span class="line">VirtualProtect((LPVOID)pfnOrg, <span class="number">14</span>, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hook: 14바이트 패치</span></span><br><span class="line">memcpy(pfnOrg, pBuf1, <span class="number">5</span>);</span><br><span class="line">memcpy((LPVOID)((DWORD_PTR)pfnOrg + <span class="number">5</span>), pBuf2, <span class="number">8</span>);</span><br><span class="line">memcpy((LPVOID)((DWORD_PTR)pfnOrg + <span class="number">13</span>), pBuf3, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 메모리에 속성 복원</span></span><br><span class="line">VirtualProtect((LPVOID)pfnOrg, <span class="number">14</span>, dwOldProtect, &amp;dwOldProtect);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void unhook(LPCSTR szDllName, LPCSTR szFuncName, PBYTE pOrgBytes)</span><br><span class="line">&#123;</span><br><span class="line">FARPROC pfnOrg;</span><br><span class="line">DWORD dwOldProtect;</span><br><span class="line">PBYTE pByte;</span><br><span class="line"></span><br><span class="line"><span class="comment">// API 주소를 구한다.</span></span><br><span class="line">pfnOrg = GetProcAddress(GetModuleHandleA(szDllName), szFuncName);</span><br><span class="line">pByte = (PBYTE)pfnOrg;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 기존 코드 14바이트를 덮어쓰기 위헤 메모리에 WRITE 속성 추가</span></span><br><span class="line">VirtualProtect((LPVOID)pfnOrg, <span class="number">14</span>, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line"><span class="comment">// unHook: 14바이트 패치</span></span><br><span class="line">memcpy(pfnOrg, pOrgBytes, <span class="number">14</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 메모리 속성 복원</span></span><br><span class="line">VirtualProtect((LPVOID)pfnOrg, <span class="number">14</span>, dwOldProtect, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MyMessageBox(HWND hWnd, LPCTSTR lpText, LPCTSTR lpCaption, UINT uType)</span><br><span class="line">&#123;</span><br><span class="line">unhook(<span class="string">"user32.dll"</span>, <span class="string">"MessageBoxA"</span>, g_pOrgBytes);</span><br><span class="line">MessageBoxA(NULL, <span class="string">"Code Patch API Hooking"</span>, <span class="string">"Hook"</span>, MB_OK);</span><br><span class="line">hook(<span class="string">"user32.dll"</span>, <span class="string">"MessageBoxA"</span>, (PROC)MyMessageBox, g_pOrgBytes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">HMODULE module = LoadLibraryA(<span class="string">"user32.dll"</span>);</span><br><span class="line"></span><br><span class="line">hook(<span class="string">"user32.dll"</span>, <span class="string">"MessageBoxA"</span>, (PROC)MyMessageBox, g_pOrgBytes);</span><br><span class="line">MessageBoxA(NULL, <span class="string">"Hello, World!"</span>, <span class="string">"Earth"</span>, MB_OK);</span><br><span class="line">unhook(<span class="string">"user32.dll"</span>, <span class="string">"MessageBoxA"</span>, g_pOrgBytes);</span><br><span class="line">MessageBoxA(NULL, <span class="string">"Hello, World!"</span>, <span class="string">"Earth"</span>, MB_OK);</span><br><span class="line"></span><br><span class="line">FreeLibrary(module);</span><br><span class="line">return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h2 id="참고자료"><a href="#참고자료" class="headerlink" title="참고자료"></a>참고자료</h2><p><a href="https://www.felixcloutier.com/x86/call" target="_blank" rel="noopener">CALL - Call Procedure</a></p><p><a href="https://www.felixcloutier.com/x86/jmp" target="_blank" rel="noopener">JMP - Jump</a></p><p><a href="https://www.felixcloutier.com/x86/push" target="_blank" rel="noopener">PUSH instruction</a></p><p><a href="https://eram.tistory.com/entry/API-Hooking-x86?category=564239" target="_blank" rel="noopener">API Hooking x86 x64</a></p><p><a href="https://shhoya.github.io/2019/03/27/64bitHook.html" target="_blank" rel="noopener">x64 Hooking</a></p><p><a href="https://5kyc1ad.tistory.com/354" target="_blank" rel="noopener">x86, x64 API HOOKING</a></p><p><a href="https://www.sysnet.pe.kr/2/0/1231" target="_blank" rel="noopener">Win32 API 후킹 - Trampoline API Hooking</a></p><p><a href="https://ezbeat.tistory.com/453" target="_blank" rel="noopener">Windows x64 binary 모듈 단위 이동</a></p><p><a href="http://sandsprite.com/blogs/index.php?uid=7&pid=235" target="_blank" rel="noopener">x64 Hooks</a></p><p><a href="https://rayanfam.com/topics/assembly-challenge-jump-to-a-non-relative-address-without-using-registers/" target="_blank" rel="noopener">Assembly Challenge : Jump to a non-relative address without using registers</a></p>]]></content>
      
      
      <categories>
          
          <category> Windows Reversing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
            <tag> Windows Reversing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows API Hooking - Code Patch</title>
      <link href="/2020/01/15/WindowsAPIHookingUsingCodePatch/"/>
      <url>/2020/01/15/WindowsAPIHookingUsingCodePatch/</url>
      
        <content type="html"><![CDATA[<p>일명 나뭇잎 책이라고 불리는 리버싱 핵심 원리 책을 보면서, 배운 내용을 정리하는 포스팅입니다.</p><p>해당 포스팅에서는 API 후킹 방법중 하나인 코드 패치 내용 정리입니다.</p><br><h2 id="API-코드-패치"><a href="#API-코드-패치" class="headerlink" title="API 코드 패치"></a>API 코드 패치</h2><p>API 코드 패치 기법은 프로세스 메모리에 로딩된 라이브러리 이미지에서 후킹을 원하는 API 코드 자체를 수정하는 방법을 말합니다. 이 기법은 API 후킹에서 널리 사용된다고 하는데, 그 이유가 대부분의 API를 후킹할 수 있기 때문이라고 합니다.</p><p>하지만 후킹하려면 API의 코드의 길이가 최소 5바이트보다 커야 한다고 합니다. 하지만 대부분의 모든 API의 코드 크기는 5바이트보다 크기 때문에 사실상 제한이 없다고 보면 됩니다.</p><br><h2 id="API-코드-패치-동작-원리"><a href="#API-코드-패치-동작-원리" class="headerlink" title="API 코드 패치 동작 원리"></a>API 코드 패치 동작 원리</h2><p>IAT 후킹 방식이 프로세스의 특정 IAT 값을 조작해서 후킹하는 방식이라면, 코드 패치 방식은 실제 API 코드 시작 바이트가 JMP 명령어로 패치합니다. 후킹된 API가 호출되면 JMP 명령어가 실행되어 후킹 함수로 제어가 넘어오는 방식입니다.</p><p>이때, 사용되는 JMP 명령어의 Instruction을 살펴보면, “E9 XXXXXXXX” 형태라는 것을 알 수 있습니다. 해당 기법을 통해서는 32bit에서는 통하지만, 64bit에서는 통하지가 않습니다.</p><p>그 이유는 32bit에서는 가상메모리 공간이 4GB로서, 2GB는 커널 영역이 사용하고, 2GB는 유저 영역이 사용합니다. 이때, 32비트의 크기로는 2GB정도되는 영역을 왔다갔다 할 수 있습니다. 따라서 “E9 XXXXXXXX” 명령어로는 32bit에서는 충분히 사용을 할 수가 있습니다.</p><p>하지만 64bit에서는 가상메모리 공간이 일반적으로 16TB를 사용하고 있으며 최대 16EB 까지 사용이 가능합니다. 따라서 JMP 명령어의 Instruction “E9 XXXXXXXX” 으로는 커버를 할 수가 없습니다.</p><p>64bit에서는 이를 해결 하기 위해서 Instruction을 섞어서 사용하는 요령이 필요합니다. 해당 부분은 따로 포스팅 해서 업데이트를 할 예정입니다. 해당 부분은 <a href="../WindowsX64Hooking">x64 hooking - code patch</a> 에서 보시면 됩니다.</p><br><h2 id="분석"><a href="#분석" class="headerlink" title="분석"></a>분석</h2><p>기본적으로 DLL 인젝션을 통해 API 후킹을 하기 위해서는 DLL Injector는 필요합니다. 어떤 DLL Injector를 사용해도 상관없습니다. 여기서 사용한 DLL Injector는 나뭇잎 책에서 제공하는 것을 사용했습니다.</p><p>여기서 후킹할 API는 MessageBox 입니다.  MyMessageBox 를 만들어서 MeesageBox 후킹해서 MyMeesageBox로 실행흐름을 바꿔서 원하는 메시지 박스를 표시하도록 할 것입니다. </p><p>소스 코드를 보면서, 실습을 진행해봅시다.</p><br><h3 id="DllMain"><a href="#DllMain" class="headerlink" title="DllMain()"></a>DllMain()</h3><p>실행 파일에서 늘 작성하던 main() 함수처럼 DLL 파일에서도 마찬가지로 늘 작성해야하는 DllMain() 함수가 있습니다. DllMain() 함수에서 늘 시작한다고 보면 됩니다.</p><p>후킹 하고자 하는 함수는 ExitProcess 입니다. 모든 프로세스에서 종료할 때, 이 함수를 이용합니다. 프로그램 종료만으로도 후킹 성공 여부를 확실하게 알 수 있기 때문에 해당 API를 선택했습니다.</p><p>제가 제작한 후킹 함수는 MyExitProcess 입니다. 해당 함수에서는 후킹 되었다는 메시지 박스를 표시하고 ExitProcess API가 정상적으로 호출되도록 작성을 했습니다.</p><p>DllMain() 함수에서는 DLL이 인젝션이 되면, Code Patch 기법을 이용해서  API의 실행흐름을 MyExitProcess 로 바꿉니다. DLL이 이젝션되면 ExitProcess의 본래의 실행흐름으로 복원합니다.</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">switch</span> (fdwReason)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">DLL_PROCESS_ATTACH:</span></span><br><span class="line">hook(<span class="string">"kernel32.dll"</span>, <span class="string">"ExitProcess"</span>, (PROC)MyExitProcess, g_pOrgBytes);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">DLL_PROCESS_DETACH:</span></span><br><span class="line">unhook(<span class="string">"kernel32.dll"</span>, <span class="string">"ExitProcess"</span>, g_pOrgBytes);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>코드를 보시면, DLL이 로딩될 때, kernel32.dll에서 ExitProcess API를 후킹 한다는 것을 볼 수 있고, DLL이 언로딩될 때 본래의 실행흐름으로 바꾸는 것을 볼 수 있습니다.</p><br><h3 id="MyExitProcess-후킹-함수-구현"><a href="#MyExitProcess-후킹-함수-구현" class="headerlink" title="MyExitProcess 후킹 함수 구현"></a>MyExitProcess 후킹 함수 구현</h3><p>ExitProcess API를 대신 사용할 MyExitProcess 함수를 구현을 해야 합니다. 본래 ExitProcess API 대신 호출이 되는 것이기 때문에 함수 인자 같은 경우에는 동일하게 해줘야 합니다. 그래야지 MyExitProcess 함수를 호출하고 나서 정상적으로 ExitProcess API를 호출할 수 있습니다.</p><p>MyExitProcess 후킹 함수는 다음과 같습니다.</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">void</span> <span class="selector-tag">WINAPI</span> <span class="selector-tag">MyExitProcess</span>(UINT uExitCode)</span><br><span class="line">&#123;</span><br><span class="line"><span class="selector-tag">MessageBoxA</span>(NULL, <span class="string">"API hooking - code patch"</span>, <span class="string">"hook"</span>, MB_OK);</span><br><span class="line"><span class="selector-tag">unhook</span>(<span class="string">"kernel32.dll"</span>, <span class="string">"ExitProcess"</span>, g_pOrgBytes);</span><br><span class="line"><span class="selector-tag">ExitProcess</span>(uExitCode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h3 id="후킹-로직-구현"><a href="#후킹-로직-구현" class="headerlink" title="후킹 로직 구현"></a>후킹 로직 구현</h3><p>다음 부분은 코드 패치 기법을 이용하여 API를 후킹하는 hook() 함수입니다.</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">BOOL hook(LPCSTR szDllName, LPCSTR szFuncName, PROC pfnNew, PBYTE pOrgBytes)</span><br><span class="line">&#123;</span><br><span class="line">FARPROC pfnOrg;</span><br><span class="line">DWORD dwOldProtect, dwAddress;</span><br><span class="line">BYTE pBuf[<span class="number">5</span>] = &#123; <span class="number">0xE9</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span> &#125;;</span><br><span class="line">PBYTE pByte;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 후킹 대상 API 주소를 구한다</span></span><br><span class="line">pfnOrg = (FARPROC)GetProcAddress(GetModuleHandleA(szDllName), szFuncName);</span><br><span class="line">pByte = (PBYTE)pfnOrg;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 만약 이미 후킹되어 있다면 return FALSE</span></span><br><span class="line">if (pByte[<span class="number">0</span>] == <span class="number">0xE9</span>)</span><br><span class="line">return <span class="literal">FALSE</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5바이트 패치를 위하여 메모리에 WRITE 속성 추가</span></span><br><span class="line">VirtualProtect((LPVOID)pfnOrg, <span class="number">5</span>, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 원본코드(5바이트) 백업</span></span><br><span class="line">memcpy(pOrgBytes, pfnOrg, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// JMP 주소 계산(E9 XXXXXXXX)</span></span><br><span class="line"><span class="comment">// XXXXXXXX = (DWORD)pfnNew - (DWORD)pfnOrg - 5;</span></span><br><span class="line">dwAddress = (DWORD)pfnNew - (DWORD)pfnOrg - <span class="number">5</span>;</span><br><span class="line">memcpy(&amp;pBuf[<span class="number">1</span>], &amp;dwAddress, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hook: 5바이트 패치(JMP XXXXXXXX)</span></span><br><span class="line">memcpy(pfnOrg, pBuf, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 메모리 속성 복원</span></span><br><span class="line">VirtualProtect((LPVOID)pfnOrg, <span class="number">5</span>, dwOldProtect, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line">return <span class="literal">TRUE</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>hook() 함수의 기능은 원본 코드 시작부분의 5바이트를 “JMP XXXXXXXX”명령어로 변경시켜서 코드의 실행 흐름을 바꿔서 후킹하는 것입니다. 후킹은 다음의 순서로 동작이 됩니다.</p><ul><li><p>후킹 대상 API 주소(ExitProcess)를 구한다. </p></li><li><p>만약 이미 후킹이되었다면, 후킹을 하지 않는다. </p></li><li><p>후킹 대상 API 메모리에 5바이트 패치를 위하여 메모리에 WRITE 속성을 추가한다.</p></li><li><p>언훅을 할 때, 원본 코드를 복원하기 위해서 5바이트를 백업한다.</p></li><li><p>JMP 주소를 계산한다.</p></li><li><p>후킹 대상 API 메모리에 5바이트 패치를 한다.(JMP XXXXXXXX)</p></li><li><p>메모리 속성을 원래대로 복원한다.</p></li></ul><br><p>여기서 중요한 부분은 JMP 명령어에 사용할 상대 주소 값을 어떻게 구하는 것 입니다. 점프할 위치 까지의 상대 거리 주소 값은 다음같은 방식으로 구할 수 있습니다.</p><blockquote><p>XXXXXXXX = 다음 명령어 주소 - 현재 명령어 주소 - 현재 명령어 길이</p></blockquote><p>여기서 명령어의 길이를 빼주는 이유는 CPU가 명령어 주소를 계산할 떄 다음같은 방식으로 구하기 때문입니다.</p><blockquote><p>다음 명령어주소(IP) = 현재 명령어주소(IP) + relative_offset + 현재 명령어 길이</p></blockquote><p>따라서 점프할 위치 까지의 상대 거리 주소 값을 구하기 위해서는 다음 명령어 주소 값에서 현재 명령어 주소 값을 뺴주고 현재 명령어 길이(5바이트)를 빼줘야합니다.</p><p>이러한 방식 말고도 절대주소로도 점프할 수 있습니다. (ex. “PUSH+RET”, “MOV+JMP”) 하지만 이러한 방식을 이용할 경우 명령어 길이가 늘어납니다. 64비트에서는 상대 거리 주소값을 이용해서 점프할 수 없기 때문에 어쩔 수 없이 절대주소로 점프하는 기법을 이용합니다.</p><br><h3 id="언훅-동작-원리"><a href="#언훅-동작-원리" class="headerlink" title="언훅 동작 원리"></a>언훅 동작 원리</h3><p>다음 부분은 언훅을 하는 unhook() 함수입니다. 해당 함수에서는 원래 코드의 5바이트를 복원하는 것입니다. 아까전에 원본 코드의 5바이트를 저장한 것을 이용해서 후킹 대상 API의 주소에서 패치한 5바이트를 복원을 하면 됩니다.</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">BOOL unhook(LPCSTR szDllName, LPCSTR szFuncName, PBYTE pOrgBytes)</span><br><span class="line">&#123;</span><br><span class="line">FARPROC pFunc;</span><br><span class="line">DWORD dwOldProtect;</span><br><span class="line">PBYTE pByte;</span><br><span class="line"></span><br><span class="line"><span class="comment">// API 주소를 구한다 </span></span><br><span class="line">pFunc = GetProcAddress(GetModuleHandleA(szDllName), szFuncName);</span><br><span class="line">pByte = (PBYTE)pFunc;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 만약 이미 언후킹 되어있다면 return FALSE</span></span><br><span class="line">if (pByte[<span class="number">0</span>] != <span class="number">0xE9</span>)</span><br><span class="line">return <span class="literal">FALSE</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 원래 코드(5바이트) 패치를 하기 위해서 메모리에 Write 속성 추가</span></span><br><span class="line">VirtualProtect((LPVOID)pFunc, <span class="number">5</span>, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line"><span class="comment">// unhook</span></span><br><span class="line">memcpy(pFunc, g_pOrgBytes, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 메모리 속성 복원</span></span><br><span class="line">VirtualProtect((LPVOID)pFunc, <span class="number">5</span>, dwOldProtect, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h3 id="실행"><a href="#실행" class="headerlink" title="실행"></a>실행</h3><img src="/2020/01/15/WindowsAPIHookingUsingCodePatch/1.png" title="후킹"><br><h3 id="전체-소스-코드"><a href="#전체-소스-코드" class="headerlink" title="전체 소스 코드"></a>전체 소스 코드</h3><pre><code>#include &quot;Windows.h&quot;#include &quot;stdio.h&quot;BYTE g_pOrgBytes[5] = { 0, };BOOL hook(LPCSTR szDllName, LPCSTR szFuncName, PROC pfnNew, PBYTE pOrgBytes){    FARPROC pfnOrg;    DWORD dwOldProtect, dwAddress;    BYTE pBuf[5] = { 0xE9, 0x00, 0x00, 0x00, 0x00 };    PBYTE pByte;    // 후킹 대상 API 주소를 구한다    pfnOrg = (FARPROC)GetProcAddress(GetModuleHandleA(szDllName), szFuncName);    pByte = (PBYTE)pfnOrg;    // 만약 이미 후킹되어 있다면 return FALSE    if (pByte[0] == 0xE9)        return FALSE;    // 5바이트 패치를 위하여 메모리에 WRITE 속성 추가    VirtualProtect((LPVOID)pfnOrg, 5, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);    // 원본코드(5바이트) 백업    memcpy(pOrgBytes, pfnOrg, 5);    // JMP 주소 계산(E9 XXXXXXXX)    // XXXXXXXX = (DWORD)pfnNew - (DWORD)pfnOrg - 5;    dwAddress = (DWORD)pfnNew - (DWORD)pfnOrg - 5;    memcpy(&amp;pBuf[1], &amp;dwAddress, 4);    // Hook: 5바이트 패치(JMP XXXXXXXX)    memcpy(pfnOrg, pBuf, 5);    // 메모리 속성 복원    VirtualProtect((LPVOID)pfnOrg, 5, dwOldProtect, &amp;dwOldProtect);    return TRUE;}BOOL unhook(LPCSTR szDllName, LPCSTR szFuncName, PBYTE pOrgBytes){    FARPROC pFunc;    DWORD dwOldProtect;    PBYTE pByte;    // API 주소를 구한다     pFunc = GetProcAddress(GetModuleHandleA(szDllName), szFuncName);    pByte = (PBYTE)pFunc;    // 만약 이미 언후킹 되어있다면 return FALSE    if (pByte[0] != 0xE9)        return FALSE;    // 원래 코드(5바이트) 패치를 하기 위해서 메모리에 Write 속성 추가    VirtualProtect((LPVOID)pFunc, 5, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);    // unhook    memcpy(pFunc, g_pOrgBytes, 5);    // 메모리 속성 복원    VirtualProtect((LPVOID)pFunc, 5, dwOldProtect, &amp;dwOldProtect);}void WINAPI MyExitProcess(UINT uExitCode){    MessageBoxA(NULL, &quot;API hooking - code patch&quot;, &quot;hook&quot;, MB_OK);    unhook(&quot;kernel32.dll&quot;, &quot;ExitProcess&quot;, g_pOrgBytes);    ExitProcess(uExitCode);}BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved){    switch (fdwReason)    {    case DLL_PROCESS_ATTACH:        hook(&quot;kernel32.dll&quot;, &quot;ExitProcess&quot;, (PROC)MyExitProcess, g_pOrgBytes);        break;    case DLL_PROCESS_DETACH:        unhook(&quot;kernel32.dll&quot;, &quot;ExitProcess&quot;, g_pOrgBytes);        break;    }    return TRUE;}## 참고자료[CALL - Call Procedure](https://www.felixcloutier.com/x86/call)[JMP - Jump](https://www.felixcloutier.com/x86/jmp)[API Hooking x86 x64](https://eram.tistory.com/entry/API-Hooking-x86?category=564239)[x64 Hooking](https://shhoya.github.io/2019/03/27/64bitHook.html)[x86, x64 API HOOKING](https://5kyc1ad.tistory.com/354)[Win32 API 후킹 - Trampoline API Hooking](https://www.sysnet.pe.kr/2/0/1231)[Windows x64 binary 모듈 단위 이동](https://ezbeat.tistory.com/453)[x64 Hooks](http://sandsprite.com/blogs/index.php?uid=7&amp;pid=235)[Assembly Challenge : Jump to a non-relative address without using registers](https://rayanfam.com/topics/assembly-challenge-jump-to-a-non-relative-address-without-using-registers/)</code></pre>]]></content>
      
      
      <categories>
          
          <category> Windows Reversing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
            <tag> Windows Reversing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DifferenceBetweenFarCallandNearCAll</title>
      <link href="/2020/01/15/DifferenceBetweenFarCallandNearCAll/"/>
      <url>/2020/01/15/DifferenceBetweenFarCallandNearCAll/</url>
      
        <content type="html"><![CDATA[<h1 id="FAR-CALL-NEAR-CALL"><a href="#FAR-CALL-NEAR-CALL" class="headerlink" title="FAR CALL, NEAR CALL ??"></a>FAR CALL, NEAR CALL ??</h1><p>프로그래밍에서 CALL 이란 서브루틴 또는 서브 프로그램에 프로그램의 실행을 넘기는 것 또는 그 조작을 위해서 사용되는 명령어로서 생각을 하면 됩니다.</p><p>세그먼트 영역이 생겨나면서, 코드, 데이터등을 분리시켜서, 샌드박스화를 시켰을 때, 현재 세그먼트 영역을 벗어난 JUMP, CALL 명령어를 하기 위해서 생겨난 개념이라고 합니다.</p><p>여기서 세그먼트란 프로그램이나 메모리의 부분을 말하며, 프로그램의 경우는 주기억에 탑재하는 단위를 세그먼트라고 생각하시면 됩니다. 메모리의 경우는 하나의 주소 레지스터로 지정되는 메모리 영역을 말합니다.</p><p><strong>세그먼트 외부의 세그먼트를 호출할 때는 FAR CALL</strong>을 사용하고, <strong>세그먼트 내부에서 호출 할 때는 NEAR CALL</strong>을 사용합니다.</p><h2 id="FAR-CALL-과-NEAR-CALL의-차이점"><a href="#FAR-CALL-과-NEAR-CALL의-차이점" class="headerlink" title="FAR CALL 과 NEAR CALL의 차이점"></a>FAR CALL 과 NEAR CALL의 차이점</h2><p>FAR CALL 과 NEAR CALL의 차이점은 CS(Code Segment Register)의 저장여부에 있습니다.</p><p>예를 들어, Kernel 구현시 CALL 0x0900:offset으로 넘기면, CS에 0x0900이 들어가게 됩니다. 그리고 CS에 들어간 주소가 복귀 주소가 되는데, 이 경우 FAR CALL을 뜻합니다. 반대로 CALL 0x0900 으로 하면 NEAR CALL을 뜻합니다.</p><p>즉, <strong>FAR CALL은 Stack에 CS:IP 값을 저장하고 지정된 곳으로 분기하는 상대 주소 지정 방식(Relative Address Mode)</strong> 입니다.</p><p>그리고 <strong>NEAR CALL은 Stack에 IP 값을 저장하고 지정된 곳으로 분기하는 간접 주소 지정 방식(Indirect Address Mode)</strong> 입니다.</p><br><h3 id="참고문헌"><a href="#참고문헌" class="headerlink" title="참고문헌"></a>참고문헌</h3><p><a href="https://m.blog.naver.com/PostView.nhn?blogId=eom913&amp;logNo=113939652&amp;proxyReferer=https%3A%2F%2Fwww.google.com%2F" target="_blank" rel="noopener">https://m.blog.naver.com/PostView.nhn?blogId=eom913&amp;logNo=113939652&amp;proxyReferer=https%3A%2F%2Fwww.google.com%2F</a></p>]]></content>
      
      
      <categories>
          
          <category> Windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
            <tag> Windows Reversing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows API Hooking - IAT hooking</title>
      <link href="/2020/01/14/WindowsAPIHookingUsingIAT/"/>
      <url>/2020/01/14/WindowsAPIHookingUsingIAT/</url>
      
        <content type="html"><![CDATA[<p>일명 나뭇잎 책이라고 불리는 리버싱 핵심 원리 책을 보면서, 배운 내용을 정리하는 포스팅입니다.</p><p>해당 포스팅에서는 API 후킹중 IAT 후킹에 대한 내용 정리입니다.</p><br><h2 id="IAT-Hooking"><a href="#IAT-Hooking" class="headerlink" title="IAT Hooking"></a>IAT Hooking</h2><p>이번 포스팅에서는 DLL 인젝션을 이용해서 IAT를 후킹해서 프로세스에서 호출되는 특정 API의 기능을 변경을 해보는 것을 할 것입니다.</p><p>API 후킹중에서 IAT 후킹 기법은 동작 원리와 비교적 구현이 간단한 것이 특징이라고 합니다. 단순히 후킹 하고 싶은 API를 사용자 DLL에 재정의하고 프로세스에 인젝션하면 끝입니다. 하지만, IAT에 실제 함수의 주소를 조작해서 함수 실행 흐름을 바꾸는 것이니 후킹을 원하는 API 대상 프로세스의 IAT에 존재하지 않다면 사용할 수 없습니다. 즉, 동적으로 DLL을 로딩해서 사용하는 API의 경우에는 해당 방법으로는 후킹을 할 수가 없다는 것입니다.</p><br><h3 id="후킹-API-선정"><a href="#후킹-API-선정" class="headerlink" title="후킹 API 선정"></a>후킹 API 선정</h3><p>어떤 작업을 할건지에 따라서 후킹 대상 API를 선정을 해야 합니다. 하지만 이것은 만만치 않은 작업입니다. 내가 조작하고 싶은 부분이 어떤 API를 통해서 작동되는지, 어떤 알고리즘을 통해서 작동되는지 파악하기 어렵기 때문입니다. 해당 부분은 개발/리버싱 경험이 많아야지 쉽게 선택할 수 있습니다.</p><br><h3 id="IAT-후킹-동작-원리"><a href="#IAT-후킹-동작-원리" class="headerlink" title="IAT 후킹 동작 원리"></a>IAT 후킹 동작 원리</h3><p>IAT는 PE 파일을 공부했으면 알다시피 프로그램에서 호출되는 API들의 실제 주소가 저장이 되는 영역입니다. IAT 후킹이란 IAT에 저장된 API들의 실제 주소 값을 주소를 바꾸는 것입니다.</p><p>정상적인 프로그램 같은 경우에는 본래 호출하고자 했던 API를 호출하고, 함수 실행이 완료되면 돌아오는 것이 일반적입니다. 하지만 IAT 후킹을 당한 프로세스 같은 경우에는 본래 호출하고자 했던 API의 주소가 바뀌었기 때문에 후킹 API가 먼저 호출되고, 작업에 따라서 본래 API의 기능을 무시하고 새로운 기능을 만들 수 있고, 값을 조작할 수 있고, 여러가지 일을 할 수 있게 됩니다.</p><p>정리하자면, 타겟 프로세스에 후킹 DLL을 인젝션하고 타켓 프로세스의 IAT영역에서 API의 실제 주소 크기만큼만 변경하면 API 후킹을 할 수 있다는 말입니다.</p><br><h2 id="분석"><a href="#분석" class="headerlink" title="분석"></a>분석</h2><p>기본적으로 DLL 인젝션을 통해 API 후킹을 하기 위해서는 DLL Injector는 필요합니다. 어떤 DLL Injector를 사용해도 상관없습니다. 여기서 사용한 DLL Injector는 나뭇잎 책에서 제공하는 것을 사용했습니다.</p><p>여기서 후킹할 API는 ExitProcess 입니다. ExitProcess API 같은 경우에는 프로그램이 종료될 때 호출되는 API 인데, 대부분의 프로그램이 종료될 때 해당 함수를 호출합니다.</p><p>API 후킹을 통해서 MyExitProcess API를 만들고, 메시지 박스를 표시한 다음에 본래의 ExitProcess API를 호출하도록 실습을 할 것입니다.</p><p>소스 코드를 보면서, 실습을 진행해봅시다.</p><br><h3 id="DllMain"><a href="#DllMain" class="headerlink" title="DllMain()"></a>DllMain()</h3><p>실행 파일에서 늘 작성하던 main() 함수처럼 DLL 파일에서도 마찬가지로 늘 작성해야하는 DllMain() 함수가 있습니다. DllMain() 함수에서 늘 시작한다고 보면 됩니다. DllMain() 함수에서는 다음과 같은 작업을 합니다.</p><p>DllMain() 함수에서는 DLL이 인젝션이 되면, original API를 어딘가에 저장을 하고 IAT 후킹을 통해서 Hooking API의 주소로 대체합니다. DLL이 이젝션 되면 original API의 주소를 가지고 와서 본래의 IAT로 백업을 합니다.</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">switch</span> (fdwReason)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">DLL_PROCESS_ATTACH:</span></span><br><span class="line"><span class="comment">// original API 주소 저장</span></span><br><span class="line">g_pOrgFunc = GetProcAddress(GetModuleHandleA(<span class="string">"kernel32.dll"</span>), <span class="string">"ExitProcess"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ntdll!RtlExitUserProcess() 를 hook!hooking() 로 후킹</span></span><br><span class="line">hook_iat(<span class="string">"kernel32.dll"</span>, g_pOrgFunc, (PROC)MyExitProcess);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">DLL_PROCESS_DETACH:</span></span><br><span class="line"><span class="comment">// IAT를 원래 대로 복원</span></span><br><span class="line">hook_iat(<span class="string">"kernel32.dll"</span>, (PROC)MyExitProcess, g_pOrgFunc);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>코드를 보시면, DLL이 로딩될 때, kernel32.dll에서 ExitProcess API의 주소를 가지고 와서 저장을 하고, hook_iat() 함수를 호출을 통해서 ExitProcess API를 후킹하는 것을 알 수 있습니다. 그리고 DLL이 언로딩될 때, IAT를 원래 대로 복원하는 것을 볼 수 있습니다.</p><br><h3 id="MyExitProcess-후킹-함수-구현"><a href="#MyExitProcess-후킹-함수-구현" class="headerlink" title="MyExitProcess 후킹 함수 구현"></a>MyExitProcess 후킹 함수 구현</h3><p>ExitProcess API를 대신 사용할 MyExitProcess 함수를 구현을 해야 합니다. 본래 ExitProcess API 대신 호출이 되는 것이기 때문에 함수 인자 같은 경우에는 동일하게 해줘야 합니다. 그래야지 MyExitProcess 함수를 호출하고 나서 정상적으로 ExitProcess API를 호출할 수 있습니다.</p><p>ExitProcess API는 원래 리턴 타입이 void 타입이지만 직접 만든 MyExitProcess 함수는 ExitProcess API를 호출 할 수 있도록 하기 위해서 BOOL 타입으로 만들었습니다.</p><p>MyExitProcess 후킹 함수는 다음과 같습니다.</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">BOOL</span> <span class="selector-tag">WINAPI</span> <span class="selector-tag">MyExitProcess</span>(UINT uExitCode)</span><br><span class="line">&#123;</span><br><span class="line"><span class="selector-tag">MessageBoxA</span>(NULL, <span class="string">"IAT hooking"</span>, <span class="string">"hook"</span>, MB_OK);</span><br><span class="line"><span class="selector-tag">return</span> ((PFEXITPROCESS)g_pOrgFunc)(uExitCode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h3 id="후킹-로직-구현"><a href="#후킹-로직-구현" class="headerlink" title="후킹 로직 구현"></a>후킹 로직 구현</h3><p>hook_iat() 함수는 실질적인 후킹 로직이 담겨 있습니다. 해당 함수에서 실질적으로 ExitProcess API를 후킹을 합니다.</p><p>구현하고자 하는 API 후킹 기법은 IAT를 이용해서 후킹을 하는 것이기 때문에 메모리에 매핑된 IAT의 주소를 알아야 합니다. 구하는 방법은 다음과 같습니다.</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">hMod = GetModuleHandle(<span class="name">NULL</span>)<span class="comment">;// hMod = ImageBase</span></span><br><span class="line">pAddr = (<span class="name">PBYTE</span>)hMod<span class="comment">;// pAddr = ImageBase</span></span><br><span class="line">pAddr += *((<span class="name">DWORD*</span>)<span class="symbol">&amp;pAddr</span>[<span class="number">0</span>x3C])<span class="comment">;// pAddr = "PE" Signature</span></span><br><span class="line">#ifdef _WIN32</span><br><span class="line">#ifdef _WIN64</span><br><span class="line">dwRVA = *((<span class="name">DWORD*</span>)<span class="symbol">&amp;pAddr</span>[<span class="number">0</span>x90])<span class="comment">;// dwRVA = RVA of IMAGE_IMPORT_DESCRIPTOR -&gt; 64bit</span></span><br><span class="line">#else</span><br><span class="line">dwRVA = *((<span class="name">DWORD*</span>)<span class="symbol">&amp;pAddr</span>[<span class="number">0</span>x80])<span class="comment">;// dwRVA = RVA of IMAGE_IMPORT_DESCRIPTOR -&gt; 32bit</span></span><br><span class="line">#endif</span><br><span class="line">#endif</span><br><span class="line">pImportDesc = (<span class="name">PIMAGE_IMPORT_DESCRIPTOR</span>)((<span class="name">DWORD_PTR</span>)hMod + dwRVA)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>먼저, GetModuleHandle API를 통해서 프로세스의 Image base address를 구하고, IMAGE_DOS_HEADER 구조체의 e_lfanew 멤버를 통해서 IMAGE_NT_HEADER 구조체를 구합니다. 그다음으로 IMAGE_IMPORT_DESCRIPTOR의 RVA를 구하기 위해서 해당 위치에서 32bit 기준 0x80, 64bit 기준 0x90 만큼 offset값을 계산해서 IMAGE_IMPORT_DESCRIPTOR의 RVA를 구한 다음에 Image base Address + RVA 를 더해서 IMAGE_IMPORT_DESCRIPTOR 구조체 배열의 주소를 찾습니다.</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">for (<span class="comment">; pImportDesc-&gt;Name; pImportDesc++)</span></span><br><span class="line">&#123;</span><br><span class="line">szLibName = (<span class="name">LPCSTR</span>)((<span class="name">DWORD_PTR</span>)hMod + (<span class="name">DWORD</span>)pImportDesc-&gt;Name)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">if (!_stricmp(<span class="name">szLibName</span>, szDllName))</span><br><span class="line">&#123;</span><br><span class="line">pThunk = (<span class="name">PIMAGE_THUNK_DATA</span>)((<span class="name">DWORD_PTR</span>)hMod + (<span class="name">DWORD</span>)pImportDesc-&gt;FirstThunk)<span class="comment">;</span></span><br><span class="line">for (<span class="comment">; pThunk-&gt;u1.Function; pThunk++)</span></span><br><span class="line">&#123;</span><br><span class="line">if (<span class="name">pThunk-&gt;u1</span>.Function == (<span class="name">DWORD_PTR</span>)pfnOrg)</span><br><span class="line">&#123;</span><br><span class="line">VirtualProtect((<span class="name">LPVOID</span>)<span class="symbol">&amp;pThunk-&gt;u1</span>.Function, <span class="number">8</span>, PAGE_EXECUTE_READWRITE, <span class="symbol">&amp;dwOldProtect</span>)<span class="comment">;</span></span><br><span class="line">pThunk-&gt;u1.Function = (<span class="name">DWORD_PTR</span>)pfnNew<span class="comment">;</span></span><br><span class="line">VirtualProtect((<span class="name">LPVOID</span>)<span class="symbol">&amp;pThunk-&gt;u1</span>.Function, <span class="number">8</span>, dwOldProtect, <span class="symbol">&amp;dwOldProtect</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">return TRUE<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IMAGE_IMPORT_DESCRIPTOR 구조체 배열의 주소 까지 찾으면 다 한거나 마찬가지입니다. 다음으로, 내가 후킹하고 싶은 API가 들어있는 DLL 이름을 찾아내고, pImportDesc-&gt;FirstThunk를 이용해서 IAT의 RVA 값을 찾아내서 IAT의 주소를 구하고, 후킹하고 싶은 ExitProcess API의 주소를 찾아 낸다음 후킹을 하면 됩니다.</p><p>이때, VirtualProtect API를 사용하는 이유는 일반적으로 IAT는 쓰기 권한이 없기 때문에 IAT의 값을 변조를 할수가 없습니다. 그래서 해당 API를 이용하면 일시적으로 쓰기 권한이 생기기 떄문에 IAT 영역내 ExitProcess API의 주소값을 MyExitProcess API의 주소값으로 바꿀수 있게 되고, 후킹을 성공할 수 있게 됩니다.</p><br><h3 id="실행"><a href="#실행" class="headerlink" title="실행"></a>실행</h3><img src="/2020/01/14/WindowsAPIHookingUsingIAT/2.png" title="후킹"><br><h3 id="전체-소스-코드"><a href="#전체-소스-코드" class="headerlink" title="전체 소스 코드"></a>전체 소스 코드</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"tchar.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"windows.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(WINAPI* PFEXITPROCESS)</span><span class="params">(UINT uExitCode)</span></span>;</span><br><span class="line"></span><br><span class="line">FARPROC g_pOrgFunc = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL WINAPI <span class="title">MyExitProcess</span><span class="params">(UINT uExitCode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MessageBoxA(<span class="literal">NULL</span>, <span class="string">"IAT hooking"</span>, <span class="string">"hook"</span>, MB_OK);</span><br><span class="line"><span class="keyword">return</span> ((PFEXITPROCESS)g_pOrgFunc)(uExitCode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">hook_iat</span><span class="params">(LPCSTR szDllName, PROC pfnOrg, PROC pfnNew)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HMODULE hMod;</span><br><span class="line">LPCSTR szLibName;</span><br><span class="line">PIMAGE_IMPORT_DESCRIPTOR pImportDesc;</span><br><span class="line">PIMAGE_THUNK_DATA pThunk;</span><br><span class="line">DWORD dwOldProtect, dwRVA;</span><br><span class="line">PBYTE pAddr;</span><br><span class="line"></span><br><span class="line">hMod = GetModuleHandle(<span class="literal">NULL</span>);<span class="comment">// hMod = ImageBase</span></span><br><span class="line">pAddr = (PBYTE)hMod;<span class="comment">// pAddr = ImageBase</span></span><br><span class="line">pAddr += *((DWORD*)&amp;pAddr[<span class="number">0x3C</span>]);<span class="comment">// pAddr = "PE" Signature</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _WIN32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _WIN64</span></span><br><span class="line">dwRVA = *((DWORD*)&amp;pAddr[<span class="number">0x90</span>]);<span class="comment">// dwRVA = RVA of IMAGE_IMPORT_DESCRIPTOR -&gt; 64bit</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">dwRVA = *((DWORD*)&amp;pAddr[<span class="number">0x80</span>]);<span class="comment">// dwRVA = RVA of IMAGE_IMPORT_DESCRIPTOR -&gt; 32bit</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">pImportDesc = (PIMAGE_IMPORT_DESCRIPTOR)((DWORD_PTR)hMod + dwRVA);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (; pImportDesc-&gt;Name; pImportDesc++)</span><br><span class="line">&#123;</span><br><span class="line">szLibName = (LPCSTR)((DWORD_PTR)hMod + (DWORD)pImportDesc-&gt;Name);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!_stricmp(szLibName, szDllName))</span><br><span class="line">&#123;</span><br><span class="line">pThunk = (PIMAGE_THUNK_DATA)((DWORD_PTR)hMod + (DWORD)pImportDesc-&gt;FirstThunk);</span><br><span class="line"><span class="keyword">for</span> (; pThunk-&gt;u1.Function; pThunk++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pThunk-&gt;u1.Function == (DWORD_PTR)pfnOrg)</span><br><span class="line">&#123;</span><br><span class="line">VirtualProtect((LPVOID)&amp;pThunk-&gt;u1.Function, <span class="number">8</span>, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</span><br><span class="line">pThunk-&gt;u1.Function = (DWORD_PTR)pfnNew;</span><br><span class="line">VirtualProtect((LPVOID)&amp;pThunk-&gt;u1.Function, <span class="number">8</span>, dwOldProtect, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL WINAPI <span class="title">DllMain</span><span class="params">(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (fdwReason)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line"><span class="comment">// original API 주소 저장</span></span><br><span class="line">g_pOrgFunc = GetProcAddress(GetModuleHandleA(<span class="string">"kernel32.dll"</span>), <span class="string">"ExitProcess"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ntdll!RtlExitUserProcess() 를 hook!hooking() 로 후킹</span></span><br><span class="line">hook_iat(<span class="string">"kernel32.dll"</span>, g_pOrgFunc, (PROC)MyExitProcess);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line"><span class="comment">// IAT를 원래 대로 복원</span></span><br><span class="line">hook_iat(<span class="string">"kernel32.dll"</span>, (PROC)MyExitProcess, g_pOrgFunc);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Windows Reversing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C언어 포인터와 배열의 관계 이해하기</title>
      <link href="/2019/09/28/UnderstandC2/"/>
      <url>/2019/09/28/UnderstandC2/</url>
      
        <content type="html"><![CDATA[<p>강의, 책을 보면서 노트화 했던 것을 정리하는 포스팅입니다.</p><br><h2 id="포인터-배열-어떤-관계가-있지"><a href="#포인터-배열-어떤-관계가-있지" class="headerlink" title="포인터? 배열? 어떤 관계가 있지?"></a>포인터? 배열? 어떤 관계가 있지?</h2><p>저번시간에 포인터는 메모리 주소 값을 가질 수 있는 녀석이라고 설명했어요.</p><p>그렇다면 배열은 어떤 녀석일까요? 배열은 여러 개의 데이터들을 한꺼번에 관리할 수 있는 녀석이에요.</p><p>배열은 어떻게 여러 개의 데이터들을 한꺼번에 관리할 수 있는 걸까요?</p><p>그리고 단일 포인터에 일차원 배열을 대입하면 포인터를 배열처럼 사용할 수 있어요.<br>어떻게 그렇게 할 수 있는 걸까요?</p><p>아래의 코드를 보면, 배열과 포인터는 가리키는 대상체가 다르다는 것을 알 수가 있는데 말이죠.</p><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> a[<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125; =&gt; <span class="built_in">array</span> <span class="keyword">of</span> <span class="number">4</span> <span class="built_in">int</span></span><br><span class="line"><span class="built_in">int</span> *p=a; =&gt; pointer <span class="keyword">to</span> <span class="built_in">int</span></span><br><span class="line"></span><br><span class="line">sizeof(p) =&gt; <span class="number">8</span></span><br><span class="line">sizeof( <span class="built_in">int</span> * ) =&gt; <span class="number">8</span></span><br><span class="line"></span><br><span class="line">sizeof(a) =&gt; <span class="number">16</span></span><br><span class="line">sizeof(<span class="built_in">int</span> [<span class="number">4</span>]) =&gt; <span class="number">16</span></span><br></pre></td></tr></table></figure><p>배열이 여러 개의 데이터들을 한꺼번에 관리할 수 있는 이유는 배열의 크기만큼 메모리에 공간을 할당하고, 배열 이름 그 자체가 첫번째 데이터 시작지점의 주소 값을 가지고 있기 때문이에요.</p><p>단일 포인터에 일차원 배열을 대입하면 포인터를 배열처럼 사용할 수 있는 이유는 형 변환을 통해서 포인터에서 배열로 대입되기 때문이에요.</p><p>이런 것을 가능하게 하는 기법이 Decay라고 불려요.<br>Decay 이란 “배열의 이름은 일반적으로 배열의 첫번째 원소의 주소로 해석한다.” 에요.</p><p>Decay 문법에서도 예외 조건이 있다고 해요.<br>sizeof() 연산자에서는 대상체의 타입을 구해오는 것이 핵심이고, &amp; 연산자에서는 주소 값을 구하기 때문에 이 두가지는 예외적으로 취급해요.</p><p>그래서 sizeof(p)와 sizeof(a)의 크기가 다르고, p=a 와 p=&amp;a[0] 는 똑같은 의미를 가진다는 것을 알 수가 있어요. 그렇다면 p=&amp;a는 어떤 의미를 가지고 있을까요?</p><p>아래의 코드를 보면서, 좀 더 자세히 알아봅시다.</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int a[<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">int (*p)[<span class="number">4</span>]=&amp;a;</span><br><span class="line"></span><br><span class="line">(*p)[<span class="number">3</span>]=<span class="number">10</span>;  </span><br><span class="line"></span><br><span class="line">printf(<span class="string">"p=%p<span class="subst">\n</span>"</span>,p);</span><br><span class="line">printf(<span class="string">"p+1=%p<span class="subst">\n</span>"</span>,p+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">printf(<span class="string">"a[3]: %d<span class="subst">\n</span>"</span>,a[<span class="number">3</span>]);</span><br><span class="line">return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>10 line -&gt; p=0x7ffeec239830<br>11 line -&gt; p+1=0x7ffeec239840<br>13 line -&gt; a[3]: 10</p></blockquote><p>만약에 int (*p)[4]에 &amp;a를 대입한게 아니라, int *p=&amp;a를 대입했다면, 컴파일 할 때, 경고 문자를 볼 수 있어요. 그 이유는 &amp;연산자는 Decay 문법의 적용 대상이 아니기 때문이죠.</p><blockquote><p>warning: incompatible pointer types initializing ‘ int * ‘ with an<br>      expression of type ‘int (*)[4]’ [-Wincompatible-pointer-types]<br>        int *p=&a;</p></blockquote><br><p>int *p=&amp;a 는 int [4] 대상체의 주소를 int * 대상체에 집어 넣는 것이기 때문이죠. 즉, 자료형이 서로 다르기 때문에 경고 문자가 나타나는 거에요.</p><p>그에 반면, int (*p)[4]=&amp;a 같은 경우에는 int [4] 대상체의 주소를 int [4]의 메모리 주소 값을 가질 수 있는 대상체에 집어 넣기 때문에 경고 문자 없이 깔끔하게 컴파일이 되는거에요.</p><p>그래서 코드의 출력 결과를 보면, p가 가리키고 있는 녀석이 int [4] 이기 때문에 주소 값이 16이 증가한 것을 볼 수 있고, (*p)[3]을 통해 a[3]의 값을 바꿀 수 있는 이유는 int [4]의 메모리 주소 값을 가지고 있는 p를 역참조해서 a의 메모리 주소로 이동하고 첨자 [3]을 통해서 a의 세번째 인덱스를 접근해 값을 변경할 수 있는 거에요.</p><br><h2 id="포인터를-배열처럼-사용해보자"><a href="#포인터를-배열처럼-사용해보자" class="headerlink" title="포인터를 배열처럼 사용해보자."></a>포인터를 배열처럼 사용해보자.</h2><p>포인터를 어떠게 배열처럼 사용해야 하는지 차근차근 알아봅시다.</p><br><h3 id="배열을-포인터-접근으로-바꿔보자"><a href="#배열을-포인터-접근으로-바꿔보자" class="headerlink" title="배열을 포인터 접근으로 바꿔보자"></a>배열을 포인터 접근으로 바꿔보자</h3><p>배열로 선언한 것을 포인터를 이용해서 접근을 해봅시다.<br>아래의 처럼 선언했다고 생각해봅시다.</p><blockquote><p>int a[5]={1,2,3,4,5};</p></blockquote><p>이때, a가 요소 1,2,3,4,5를 포인터를 이용해서 어떻게 접근해야할까요?<br>바로 답은 아래와 같습니다.</p><blockquote><p>*(a)         // 인덱스 0에 접근<br>*(a + 1)    // 인덱스 1에 접근<br>*(a + 2)    // 인덱스 2에 접근<br>*(a + 3)    // 인덱스 3에 접근<br>*(a + 4)    // 인덱스 4에 접근</p></blockquote><p>배열의 이름은 배열의 요소의 첫번째 값을 가리키는 주소가 들어가 있습니다.<br>*(a + 1) 을 하면, 배열의 요소의 첫번째 값을 가리키는 주소에 변수 a가 가리키는 대상체인 int형의 크기 * 1을 더한 값을 역참조를 하기 때문에 배열의 요소의 2번째 값을 가리키는 녀석에 접근할 수 있는 것입니다.<br>마찬 가지로 인덱스 4에 접근을 할려면 *(a + 4)를 이용하면 됩니다.</p><h3 id="이차원배열과-포인터"><a href="#이차원배열과-포인터" class="headerlink" title="이차원배열과 포인터"></a>이차원배열과 포인터</h3><p>이러한 접근 방식을 이차원 배열에서 적용시켜 봅시다.<br>아래처럼 값을 선언했다고 생각해봐요.</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a[<span class="string">2</span>][<span class="symbol">2</span>]=&#123;1,2,3,4&#125;;</span><br><span class="line">int *p=a;</span><br><span class="line">p[<span class="string">1</span>][<span class="symbol">1</span>]=10;</span><br></pre></td></tr></table></figure><p>이때, a의 메모리 주소는 1000이라고 생각해요.</p><blockquote><p>p[1][1]<br>( *( p + 1 ) )[1]<br>( *( 1000 + sizeof(int) * 1 ) )[1]<br>( *1004 )[1]<br>*( *1004 + 1 )<br>*( 2 + 1 )<br>*3 // 이 때, 컴파일 에러가 발생, * 연산자를 이상한 주소 값을 가르켰기 때문.</p></blockquote><p>변수 p의 메모리 번지가 바뀌는 것을 봅시다.<br>p[1][1]은 ( *(p + 1) )[1]로 변경이 가능합니다.<br>그 후에 p가 가지고 있는 값은 1000이 되고, p가 가리키고 있는 대상체는 int형이기 때문에 1은 int형의 크기 * 1 로 변환이 됩니다. -&gt; ( *( 1000 + sizeof(int) * 1) )[1]<br>이를 간략하게 보면, ( *1004 )[1]이 되고, *( *1004 + 1)로도 표현이 가능합니다.<br>1004는 배열의 두번쨰 인덱스의 값인 2를 가리키게 되서, *( 2 + 1) 로 변환이 됩니다.<br>그렇다면, *(3) 이것의 의미는 3이라는 메모리 번지에 접근하는 것이기 때문에, 이상한 주소에 접근하게 되므로 컴파일 에러가 발생합니다.<br>요즘은 컴파일러가 좋아서인지 경고 문자를 보내고, 컴파일이 됩니다.<br>그리고 당연히 포인터를 이차원 배열처럼 사용은 불가능합니다.</p><br><p>이번에는 이중 포인터를 이용했다고 생각해봐요.</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a[<span class="string">2</span>][<span class="symbol">2</span>]=&#123;1,2,3,4&#125;;</span><br><span class="line">int **p=a;</span><br><span class="line">p[<span class="string">1</span>][<span class="symbol">1</span>]=10;</span><br></pre></td></tr></table></figure><p>이때, a의 메모리 주소는 마찬가지로 1000 입니다.</p><blockquote><p>p[1][1]<br>*( *(p + 1) + 1)<br>*( *(1000 + 1) + 1)<br>*( *(1000 + sizeof( int * ) * 1) + 1)<br>*( *(1008) + 1)<br>*( 0x0000000300000004 + 1)<br>*( 0x0000000300000004 + sizeof(int) * 1)<br>*( 0x0000000300000008 ) // 이 때, 잘못된 번지에 접근을 하기 때문에 run time 에러가 발생.</p></blockquote><p>변수 p의 메모리 주소가 바뀌는 것을 봅시다.<br>p[1][1]은 * ( <em>(p + 1) + 1) 변경이 가능합니다.<br>a의 메모리 주소가 1000이므로, *( *(1000 + 1) + 1) 으로도 변경이 가능합니다.<br>그리고 이때 p가 가리키는 대상체는 int * 이므로, *( *(1000 + sizeof( int * ) * 1) + 1) 으로 볼 수 있습니다. 이를 계산하면, *( *(1008) + 1) 으로 표현이 가능합니다.<br>이 때, int *</em> 이므로 이를 역참조하면 int * 이므로, 역참조를 한다고 하더라도 주소 값을 가져오는 것이기 때문에 0x0000000300000004가 되어서, *(0x0000000300000004+1) 으로 표현이 가능합니다. 이 때, 가리키는 대상체가 int형이므로, *(0x0000000300000004+sizeof(int) * 1) 으로 표현이 가능합니다.<br>따라서 *0x0000000300000008 이라는 잘못된 번지에 접근을 하기 때문에 run time 에러가 발생하는 것입니다. 그 뿐만 아니라 컴파일 에러도 발생 합니다.</p><br><p>그렇다면, 포인터를 이차원 배열처럼 사용할러면 어떻게 선언하면 될까요?<br>아래처럼 선언하면 됩니다.</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a[<span class="string">2</span>][<span class="symbol">2</span>]=&#123;1,2,3,4&#125;;</span><br><span class="line">int (*p)[2]=a;</span><br><span class="line">p[<span class="string">1</span>][<span class="symbol">1</span>]=10;</span><br></pre></td></tr></table></figure><p>이번에도 a의 메모리 주소는 이번에도 1000입니다.</p><blockquote><p>p[1][1]<br>*( *(p + 1) + 1)<br>*( *(1000 + sizeof(int [2]) * 1 ) + 1)<br>*( *(1008) + 1)<br>*( 1008 + 1)<br>*( 1008 + sizeof(int) * 1)<br>*(1012)</p></blockquote><p>p의 메모리 주소가 바뀌는 것을 한번더 봅시다.<br>p[1][1]을 포인터 접근으로 변환하면, *( *(p + 1) + 1)로 변환이 가능하고, p는 대상체 int [2]를 가리키기 때문에, *( *(1000 + sizeof(int [2]) * 1) + 1)로 바뀝니다.<br>이걸 간략화하면, *( *(1008) + 1) 으로 바꿀 수 있습니다. p 는 내부에 있는 이름 없는 배열을 가리키고 있기 때문에, Decay 문법에 의해 int [2] 타입이 int * 타입으로 변환되기 때문에 *( 1008 + 1)이 됩니다.<br>이 때, 가리키는 대상체는 int형 이기 때문에 *( 1008 + sizeof(int) * 1) 이 되고, 간략화하면, *(1012)가 되어서, a[1][1]에 해당하는 값인 4를 10으로 바꿀 수 있게 되는 것입니다.</p><br><p><strong>즉, 배열과 포인터의 관계를 이해하기 위해서는 Decay 에 대해 알아야 하고, Decay 을 이용하면 배열의 이름이 첫 번째 원소의 주소로 해석된다는 것을 알고 있으면 됩니다.</strong></p><br><h2 id="배열을-포인터적으로-해석해보자"><a href="#배열을-포인터적으로-해석해보자" class="headerlink" title="배열을 포인터적으로 해석해보자"></a>배열을 포인터적으로 해석해보자</h2><p>먼저 기본적으로 단일 포인터를 해석합시다.</p><blockquote><p>타입 해석<br>int* p // pointer to int</p><p>자체 크기<br>sizeof( p )<br>sizeof( int * )<br>-&gt; 64 bit는 8Byte, 32 bit는 4Byte</p><p>한번 움직이는 거리(offset)<br>p + 1<br>p + sizeof( *p ) + 1<br>p + sizeof( int ) * 1<br>p + 4</p></blockquote><p>int * 타입은 자기 자신의 크기는 64비트 기준 8바이트 이고, 가리키는 대상체가 int 형이기 때문에 offset 값이 4입니다.</p><br><h3 id="일차원-배열의-포인터적-해석"><a href="#일차원-배열의-포인터적-해석" class="headerlink" title="일차원 배열의 포인터적 해석"></a>일차원 배열의 포인터적 해석</h3><blockquote><p>타입해석<br>int a[2] // array of 2 int<br>자체 크기<br>sizeof( a )<br>sizeof( int [2] ) // 8Byte</p><p>한번 움직이는 거리(offset)<br>a + 1<br>a + sizeof( *a ) * 1<br>a + sizeof( int ) * 1<br>a + 4</p></blockquote><p>int [2] 타입은 자기 자신의 크기는 8바이트이고, 가리키는 대상체가 int 형이기 때문에 offset 값이 4입니다.</p><h3 id="포인터-배열의-포인터적-해석"><a href="#포인터-배열의-포인터적-해석" class="headerlink" title="포인터 배열의 포인터적 해석"></a>포인터 배열의 포인터적 해석</h3><blockquote><p>타입 해석<br>int *a[2] // array of 2 pointer to int</p><p>자체 크기<br>sizeof( a )<br>sizeof( int *[2] ) // 16Byte</p><p>한번 움직이는 거리(offset)<br>a + 1<br>a + sizeof( <em>a ) * 1<br>a + sizeof( int</em> ) * 1<br>a + 8</p></blockquote><p>전치랑 후치가 존재할 때, 후치가 먼저 해석되기 때문에 배열 포인터가 아니라 포인터 배열로 해석된다.<br>int *[2] 타입은 자기 자신의 크기는 16바이트이고, 가리키는 대상체가 int *형이기 때문에 offset 값기 8입니다.</p><h3 id="배열의-포인터의-포인터적-해석"><a href="#배열의-포인터의-포인터적-해석" class="headerlink" title="배열의 포인터의 포인터적 해석"></a>배열의 포인터의 포인터적 해석</h3><blockquote><p>int (*p)[2] // pointer to array of 2 int</p><p>자체크기<br>sizeof( p )<br>sizeof( int (*)[2] ) // 8Byte</p><p>한번 움직이는 거리(offset)<br>p + 1<br>p + sizeof( *p ) * 1<br>p + sizeof( int [2] ) + 1<br>p + 8</p></blockquote><p>전치랑 후치가 존재할 때, 후치가 먼저 해석되기 때문에 배열 포인터를 사용하기 위해서는 괄호를 쳐서 우선 순위를 높여줘야 한다.<br>int *[2] 타입은 자기 자신의 크기는 8바이트이고, 가리키는 대창체가 int [2] 형이기 때문에 offset 값은 8입니다.</p><h3 id="이중-포인터의-포인터적-해석"><a href="#이중-포인터의-포인터적-해석" class="headerlink" title="이중 포인터의 포인터적 해석"></a>이중 포인터의 포인터적 해석</h3><blockquote><p>타입해석<br>int **p // pointer to pointer to int</p><p>자체크기<br>sizeof( p )<br>sizeof( int ** ) // 8Byte</p><p>한번 움직인느 거리(offset)<br>p + 1<br>p + sizeof( *p ) * 1<br>p + sizeof( int * ) * 1<br>p + 8</p></blockquote><p>int ** 타입은 자기 자신의 크기는 8바이트이고, 가리키는 대상체가 int * 형이기 때문에 offset 값은 8입니다.</p><h3 id="이차원-배열의-포인터적-해석"><a href="#이차원-배열의-포인터적-해석" class="headerlink" title="이차원 배열의 포인터적 해석"></a>이차원 배열의 포인터적 해석</h3><blockquote><p>타입해석<br>int a[2][2] // array of 2 array of 2 int</p><p>자체 크기<br>sizeof( p )<br>sizeof( int [2][2] ) // 16Byte</p><p>한번 움직이는 거리(offset)<br>a + 1<br>a + sizeof( *a ) * 1<br>a + sizeof( int [2] ) * 1<br>a + 8</p></blockquote><p>int [2][2] 타입은 자시 자신의 크기는 16바이트이고, 가리키는 대상체가 int [2] 형이기 때문에 offset 값은 8입니다.</p><h3 id="삼차원-배열의-포인터적-해석"><a href="#삼차원-배열의-포인터적-해석" class="headerlink" title="삼차원 배열의 포인터적 해석"></a>삼차원 배열의 포인터적 해석</h3><blockquote><p>int a[2][2][2] // array of 2 array of 2 array of 2 int</p><p>자체크기<br>sizeof( a )<br>sizeof( int [2][2][2] ) // 32byte</p><p>a[0][0][0] : 0x7ffee4de57b0<br>a[0][0][1] : 0x7ffee4de57b4<br>a[0][1][0] : 0x7ffee4de57b8<br>a[0][1][1] : 0x7ffee4de57bc<br>a[1][0][0] : 0x7ffee4de57c0<br>a[1][0][1] : 0x7ffee4de57c4<br>a[1][1][0] : 0x7ffee4de57c8<br>a[1][1][1] : 0x7ffee4de57cc</p><p>한번 움직이는 거리(offset)<br>a + 1<br>a + sizeof( *a ) * 1<br>a + sizeof( int [2][2] ) * 1<br>a + 16</p></blockquote><p>int [2][2][2] 타입은 자기 자신의 크기는 32바이트이고, 가리키는 대상체가 int [2][2] 형이기 때문에 offset 값은 16입니다.</p>]]></content>
      
      
      <categories>
          
          <category> C language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C 언어 포인터 이해하기</title>
      <link href="/2019/09/24/UnderstandC/"/>
      <url>/2019/09/24/UnderstandC/</url>
      
        <content type="html"><![CDATA[<p>강의, 책을 보면서 노트화 했던 것을 정리하는 포스팅입니다.</p><br><h2 id="포인터는-무엇일까"><a href="#포인터는-무엇일까" class="headerlink" title="포인터는 무엇일까?"></a>포인터는 무엇일까?</h2><p>C 언어에서 포인터는 무엇일까요? 개념 자체는 단순해요. 그냥 <strong>메모리의 주소 값을 가질 수 있는 녀석</strong>이죠.</p><br><h3 id="사용하는-이유는"><a href="#사용하는-이유는" class="headerlink" title="사용하는 이유는?"></a>사용하는 이유는?</h3><p>이러한 포인터를 사용하는 무엇일까요?<br>함수를 사용하지 않고, 동적 할당도 사용하지 않고, 모든 코드를 진입점 함수에 해당하는 main()에 모든 코드를 집어 넣으면 포인터를 사용할 필요가 없을지도 몰라요.</p><p>하지만 우리는 그렇게 코딩을 하지 않고, 유지 보수를 용이하게 하기 위해서 기능별로 소스 파일 만들고, 모듈화 하기 위해서 진입점 함수의 부분을 간략화 하는 등 일을 하기 때문에 포인터 라는 것이 필요해요.</p><p>포인터라는 문법이 없는 자바, C# 등 에서는 가비지 컬렉션이라고 불리는 녀석들이 알아서 메모리를 관리하기 때문에 필요가 없지만, C/C++ 에서는 메모리 관리를 개발자가 직접하기 때문에 포인터라는 문법이 존재하죠.</p><br><h2 id="포인터-문법"><a href="#포인터-문법" class="headerlink" title="포인터 문법"></a>포인터 문법</h2><p>포인터는 <strong>“*”</strong> 별표라는 기호를 이용해서 사용해요.</p><p>예를 들어서, char *a, int *b, float *c 라고 하면, 순서대로 char 형 포인터로 선언된 a, int형 포인터로 선언된 b, float형 포인터로 선언된 c로 볼 수 있어요.</p><p>이렇게 단일 포인터로 사용될 경우에는 포인터가 어떤 식으로 사용되는지 쉽게 알 수 있지만, 포인터를 이중,삼중으로 사용하게 되면, 이 포인터가 무엇을 의미하는지 알기 쉽지 않아요. 그거에 대해서 차근차근 알아볼 거에요.</p><p>그리고 <strong>“*”</strong> 별표는 포인터 변수라는 것을 의미하는 것 이외에도, 곱셈 기호로 사용하기도 하고, 역참조해서 해당 주소의 값에 접근할 때도 사용해요.</p><p>또한 모든 포인터는 대상체의 크기만큼 이동을 하게 되는데 이게 무슨 의미일까요? 한번 코드를 통해 알아봅시다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span>* p=&amp;i;</span><br><span class="line">*p=<span class="number">200</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"sizeof(i): %lu\n"</span>,<span class="keyword">sizeof</span>(i));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"sizeof(int): %lu\n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"sizeof(p): %lu\n"</span>,<span class="keyword">sizeof</span>(p));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"sizeof(int *): %lu\n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>*));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"sizeof(*p): %lu\n"</span>,<span class="keyword">sizeof</span>(*p));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"p=%p\n"</span>,p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"p+1=%p\n"</span>,p+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>7 line-&gt; 200<br>8 line-&gt; sizeof(i): 4<br>9 line-&gt; sizeof(int): 4<br>10 line-&gt; sizeof(p): 8<br>11 line-&gt; sizeof( int * ): 8<br>12 line-&gt; sizeof( *p ): 4<br>13 line-&gt; p=0x7ffeea9fa848<br>14 line-&gt; p+1=0x7ffeea9fa84c</p></blockquote><p>맨 마지막의 메모리 주소 값은 환경에 따라 다를 수 있습니다.</p><p>변수 i를 100로 초기화를 했지만, 포인터 변수 p에 i의 주소 값을 집어 넣고, 포인터 변수 p를 역참조해서 200라는 값을 대입을 했어요.<br>그래서 변수 i의 값이 100에서 200로 변한 것이죠.</p><img src="/2019/09/24/UnderstandC/1.png"><p>그리고 int 형의 크기, int 형 변수의 크기, int 포인터 형의 크기, int 포인터 형 변수의 크기, int 포인터 형 변수의 역 참조의 크기에 대해 알아봤어요.</p><p>int 형 같은 경우에는 IA-64 계열에서는 4바이트의 크기를 가지고 있어요. cpu의 종류에 따라 이 크기는 달라질 수도 있어요.</p><p>int 포인터 형 같은 경우에는 IA-64 계열에서는 8바이트, x86 계열에서는 4바이트를 가지고 있어요. 그리고 포인터 같은 경우에는 int 형이든, float 형이든 크기가 동일해요. 그 이유는 메모리 주소를 나타내기 때문이죠. 그렇다고 하더라도 int 포인터 형과 float 포인터 형을 섞어서 써도 된다는 말은 아니에요. 섞어서 사용하면 안됩니다.</p><p>제 cpu는 IA-64 계열이라서 int 형의 크기가 4바이트, int 포인터 형의 크기가 8바이트, int 포인터 형의 역참조 크기가 4바이트가 나옵니다.</p><p>int 포인터 형의 역참조 크기가 4바이트가 나오는 이유는 int 포인터 형이 가리키고 있는 녀석이 int 형이기 때문입니다. 그래서 4바이트 크기가 나오는 것입니다.</p><p>char 포인터 형의 역참조 크기는 몇 바이트가 나올까요? char 포인터 형의 크기는 IA-64 계열에서 int 포인터 형의 크기처럼 8바이트가 나오지만, 역참조의 크기는 4바이트가 아니라 1바이트가 나옵니다. 그 이유는 char 포인터 형의 역참조는 char 형을 가리키기 때문이죠.</p>]]></content>
      
      
      <categories>
          
          <category> C language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PE 구조 이해하기 - IMAGE_SECTION_HEADER 구조</title>
      <link href="/2019/09/20/UnderstandPE6/"/>
      <url>/2019/09/20/UnderstandPE6/</url>
      
        <content type="html"><![CDATA[<p>windows 시스템 실행파일의 구조와 원리 책 내용을 요약 및 정리 하는 포스팅이에요.</p><p>섹션들의 정보들의 위치와 크기를 나타내는 <strong>IMAGE_SECTION_HEADER</strong>에 대한 내용을 알아볼 거에요.</p><br><h2 id="IMAGE-SECTION-HEADER의-시작"><a href="#IMAGE-SECTION-HEADER의-시작" class="headerlink" title="IMAGE_SECTION_HEADER의 시작"></a>IMAGE_SECTION_HEADER의 시작</h2><p>IMAGE_NT_HEADER에 대한 설명이 이제 다 끝났어요. 그 다음으로 이어질 구조체인 IMAGE_SECTION_HEADER에 대한 설명을 시작할게요.</p><p>여기에서도 섹션들의 정보들의 위치와 크기등 여러가지를 알려주는 IMAGE_SECTION_HEADER에 대해 알아볼 건데요. 섹션들의 정보들의 위차와 크기를 나타내는 IMAGE_DATA_DIRECTORY 구조체와 어떤 차이가 있는 걸까요?</p><p>IMAGE_DATA_DIRECTORY 구조체에 있는 섹션들은 IMAGE_SECTION_HEADER 구조체에 있는 섹션들에게 병합되어 있기 때문에 PE 파일 내에 정보가 없어요! 따라서 IMAGE_DATA_DIRECTORY 구조체에 있는 섹션들의 정보를 확인하고 싶으면, IMAGE_SECTION_HEADER 구조체에 있는 정보들과 조합해서 찾아야 합니다!</p><p>자 진짜로 IMAGE_SECTION_HEADER에 대한 설명을 시작할게요!</p><p><strong>IMAGE_SECTION_HEADER 구조체는 40바이트로 구성되어 있고요. IMAGE_FILE_HEADER의 NumberOfSections 필드에 있는 섹션의 개수만큼 IMAGE_SECTION_HEADER 가 존재해요.</strong><br>이 구조체도 마찬가지로 “WinNT.h” 헤더 파일에 정의되어 있습니다.</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#defome IMAGE_SECTION_HEADER 8</span></span><br><span class="line"></span><br><span class="line">typedef struct _IMAGE_SECTION_HEADER &#123;</span><br><span class="line">  <span class="keyword">BYTE </span> Name[IMAGE_SIZEOF_SHORT_NAME]<span class="comment">;</span></span><br><span class="line">  union &#123;</span><br><span class="line">    DWORD PhysicalAddress<span class="comment">;</span></span><br><span class="line">    DWORD VirtualSize<span class="comment">;</span></span><br><span class="line">  &#125; Misc<span class="comment">;</span></span><br><span class="line">  DWORD VirtualAddress<span class="comment">;</span></span><br><span class="line">  DWORD SizeOfRawData<span class="comment">;</span></span><br><span class="line">  DWORD PointerToRawData<span class="comment">;</span></span><br><span class="line">  DWORD PointerToRelocations<span class="comment">;</span></span><br><span class="line">  DWORD PointerToLinenumbers<span class="comment">;</span></span><br><span class="line">  WORD  NumberOfRelocations<span class="comment">;</span></span><br><span class="line">  WORD  NumberOfLinenumbers<span class="comment">;</span></span><br><span class="line">  DWORD Characteristics<span class="comment">;</span></span><br><span class="line">&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER<span class="comment">;</span></span><br></pre></td></tr></table></figure><br><h3 id="첫-번째-멤버-BYTE-Name-IMAGE-SIZEOF-SHORT-NAME"><a href="#첫-번째-멤버-BYTE-Name-IMAGE-SIZEOF-SHORT-NAME" class="headerlink" title="첫 번째 멤버, BYTE Name[IMAGE_SIZEOF_SHORT_NAME]"></a>첫 번째 멤버, BYTE Name[IMAGE_SIZEOF_SHORT_NAME]</h3><p><strong>섹션의 아스키 이름</strong>을 나타내요. IMAGE_SIZEOF_SHORT_NAME은 8바이트로 매크로 상수로 정의되어 있고요. 문자열임에도 불구하고 NULL을 신경쓰지 않아요.<br>그 이유가 섹션 이름을 8바이트 이상으로 지정했을 경우 링커가 알아서 8바이트 이후의 문자열은 잘라 버린 후 값을 채우기 때문이에요.</p><br><h3 id="두-번째-멤버-DOWRD-PhysicalAddress-or-VirtualSize"><a href="#두-번째-멤버-DOWRD-PhysicalAddress-or-VirtualSize" class="headerlink" title="두 번째 멤버, DOWRD PhysicalAddress or VirtualSize"></a>두 번째 멤버, DOWRD PhysicalAddress or VirtualSize</h3><p>이 필드는 OBJ 파일인 경우와 PE의 경우 의미가 달라져요.</p><p><strong>PE의 경우 공용체의 VirtualSize 필드를 사용하여 코드와 데이터의 실제 바이트수</strong>를 담고 있어요. 즉, 파일 바이트 정렬의 배수로 라운드업이 되기 전의 실제 바이트 수를 담고 있어요.<br>이 값에 대한 라운드업된 값은 이 구조체의 SizeOfRawData 필드에 저장되요.</p><p>이전까지는 OBJ 파일의 경우 공용체의 PhysicalAddress 필드를 통해 섹션의 물리적인 번지를 지정했지만, 현재에는 OBJ의 경우 이 필드는 0으로 세팅되요. 즉, PhysicalAddress 필드는 더 이상 의미가 없어졌어요.</p><p>이렇게 물리적인 번지를 직접 사용하지 않는 이유가 현대에는 보호모드가 보편적으로 사용되기 때문이에요.</p><br><h3 id="세-번째-멤버-DWORD-VirtualAddress"><a href="#세-번째-멤버-DWORD-VirtualAddress" class="headerlink" title="세 번째 멤버, DWORD VirtualAddress"></a>세 번째 멤버, DWORD VirtualAddress</h3><p><strong>PE에서 해당 섹션을 매핑시켜야 할 가상 주소 공간 상의 RVA</strong>를 가지고 있어요.<br>즉, <strong>메모리 상에서의 본 섹션의 시작 주소</strong>를 의미하는 거죠.<br>그리고 <strong>SectionAlignment 필드 값의 배수</strong>가 되어야 한다.</p><br><h3 id="네-번째-멤버-DWORD-SizeOfRawData"><a href="#네-번째-멤버-DWORD-SizeOfRawData" class="headerlink" title="네 번째 멤버, DWORD SizeOfRawData"></a>네 번째 멤버, DWORD SizeOfRawData</h3><p><strong>VirtualSize 필드 값에 대한 파일 정렬(Alignment) 값의 배수로 라운드업된 값</strong>이다.<br>만약 IMAGE_OPTIONAL_HEADER의 FileAlignment 필드의 값이 0x200 이고, VirtualSize 필드 값이 0x35A이면 SizeOfRawData 필드 값은 0x400이 된다.</p><p>OBJ 파일의 경우 이 값은 0이다.</p><br><h3 id="다섯-번째-멤버-DWORD-PointerToRawData"><a href="#다섯-번째-멤버-DWORD-PointerToRawData" class="headerlink" title="다섯 번째 멤버, DWORD PointerToRawData"></a>다섯 번째 멤버, DWORD PointerToRawData</h3><p><strong>해당 섹션의 PE 파일 내에서 시작하는 실제 파일 오프셋 값</strong>이다.<br>이 값 역시 IMAGE_OPTIONAL_HEADER의 <strong>FileAlignmnet 필드 값의 배수</strong>가 되어야 한다.<br>이 필드의 값은 <strong>VirtualAddress 필드의 값과 같을 수도 있고 다를 수도</strong> 있다.</p><p>그렇게 하는 이유가 VirtualAddress 필드는 IMAGE_OPTIONAL_HEADER의 SectionAlignment 필드 값의 배수가 되기 때문에 바이트 정렬 문제로 인하여 하드디스크 상의 공간을 낭비될 수 있고, 이때 PointerToRawData 필드에 실제 섹션의 파일 상의 시작 오프셋을 지정하고 오프셋에 섹션 데이터를 기록함으로써 PE 파일의 크기를 줄일 수 있는 거라고 해요.</p><p>따라서 VirtualAddress 필드와 PointerToRawData 필드 사이의 관계를 파악하는 것이 중요하다고 해요.<br>VirtualAddress의 값은 RVA이기 때문에 IMAGE_OPTIONAL_HEADER의 ImageBase 필드 값을 더한 결과가 프로그램 로더가 PE 파일을 위하여 프로세스 커널 객체를 생성한 후 가상 주소 공간을 만들고 나서 이 섹션을 해당 주소 공간에 매핑시킬 실제 번지 값이 되요. 그리고 PointerToRawData의 값은 이 섹션이 위치한 PE 파일 내의 파일 선두로 부터의 오프셋이 되고요.</p><p>VirtualAddress 필드와 PointerToRawData 필드는 중요한 필드인 거죠!<br>아래의 사진은 책에 첨부되더 있는 VirtualAddress와 PointerToRawData 사이의 관계에 대한 그림입니다.</p><img src="/2019/09/20/UnderstandPE6/1.png"><br><h3 id="여섯-번째-멤버-PointerToRelocations"><a href="#여섯-번째-멤버-PointerToRelocations" class="headerlink" title="여섯 번째 멤버, PointerToRelocations"></a>여섯 번째 멤버, PointerToRelocations</h3><p>본 섹션을 위한 <strong>재배치 파일 오프셋</strong>이에요. 이 필드는 OBJ에서만 사용되고 실행 파일에서는 0으로 세트되요. OBJ 파일에서 이 필드가 0이 아닐 경우 IMAGE_RELOCATION 구조체 배열의 시작 주소를 가리켜요.</p><br><h3 id="일곱-번째-멤버-PointerToLinenumbers"><a href="#일곱-번째-멤버-PointerToLinenumbers" class="headerlink" title="일곱 번째 멤버, PointerToLinenumbers"></a>일곱 번째 멤버, PointerToLinenumbers</h3><p>본 섹션을 위한 <strong>COFF 스타일의 라인 번호를 위한 파일 오프셋</strong>이에요. 이 필드의 값이 0이 아닐 경우 IMAGE_LINENUMBER 구조체 배열의 시작을 가리키고, COFF 라인 번호가 PE에 첨부되었을 경우에만 사용해요.</p><br><h3 id="여덟-번째-멤버-NumberOfRelocations"><a href="#여덟-번째-멤버-NumberOfRelocations" class="headerlink" title="여덟 번째 멤버, NumberOfRelocations"></a>여덟 번째 멤버, NumberOfRelocations</h3><p>PointerToRelocations 필드가 가리키는 <strong>IMAGE_RELOCATION 구조체 배열의 원소의 개수</strong>에요. 실행 파일에서는 항상 0이에요!</p><br><h3 id="아홉-번째-멤버-NumberOfLinenumbers"><a href="#아홉-번째-멤버-NumberOfLinenumbers" class="headerlink" title="아홉 번째 멤버, NumberOfLinenumbers"></a>아홉 번째 멤버, NumberOfLinenumbers</h3><p>PointerToLinenumbers 필드가 가리키는 <strong>IMAGE_LINENUMBER 구조체 배열의 원소의 개수</strong>에요. 마찬가지로 COFF 라인 번호가 PE 파일에 추가 되어쓸 때만 사용해요.</p><br><h3 id="열-번째-멤버-Characteristics"><a href="#열-번째-멤버-Characteristics" class="headerlink" title="열 번째 멤버, Characteristics"></a>열 번째 멤버, Characteristics</h3><p><strong>이 필드는 해당 섹션의 속성을 나타내는 플래그의 집합</strong>이에요.<br>“WinNT.h” 헤더 파일에 IMAGE_SCN_XXX_XXX의 형태로 매크로로 정의되어 있어요.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Section contains code.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SCN_CNT_CODE 0x00000020</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Section contains ubutuakuzed data</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SCN_CNT_INITIALIZED_DATA 0x00000040</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Section contains uninitialized data</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SCN_CNT_UNINITIALIZED_DATA 0x00000080</span></span><br></pre></td></tr></table></figure><p>링커는 링크 시에 필요에 따라서나 혹은 사용자의 지시에 의해 여러 섹션들을 하나로 병합할수 있어요. 병합하는 옵션은 /MERGS:from=to 형식으로 지정하면 되요. 이때 병합된 섹션 내에 특정 섹션이 포함되어 있는지를 확인할 수 있는 플래그 집함을 제공한느데 위의 플래그 집함이 그 목적으로 사용된다고 해요.</p><h4 id="IMAGE-SCN-CNT-CODE"><a href="#IMAGE-SCN-CNT-CODE" class="headerlink" title="IMAGE_SCN_CNT_CODE"></a>IMAGE_SCN_CNT_CODE</h4><p>섹션의 코드를 포함하고 있고, 보통 이 플래그는 실행 가능 플래그를 의미하는 IMAGE_SCN_MEM_EXECUTE(0x20000000) 플래그와 함께 저장된다고 해요.</p><h4 id="IMAGE-SCN-CNT-INITIALIZED-DATA"><a href="#IMAGE-SCN-CNT-INITIALIZED-DATA" class="headerlink" title="IMAGE_SCN_CNT_INITIALIZED_DATA"></a>IMAGE_SCN_CNT_INITIALIZED_DATA</h4><p>섹션이 초기화된 데이터를 포함하고 있어요. 실행 가능 섹션과 .bss 섹션을 제외한 거의 대부분의 섹션이 이 플래그를 가져요.</p><h4 id="IMAGE-SCN-CNT-UNINTIALIZED-DATA"><a href="#IMAGE-SCN-CNT-UNINTIALIZED-DATA" class="headerlink" title="IMAGE_SCN_CNT_UNINTIALIZED_DATA"></a>IMAGE_SCN_CNT_UNINTIALIZED_DATA</h4><p>섹션이 초기화되지 않은 데이터(.bss 섹션 …)들이 가져요.</p><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SCN_MEM_DISCARDABLE 0x02000000 <span class="comment">// Section can be discared.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SCN_MEM_NOT_CACHED 0x04000000 <span class="comment">// Section is not cachable.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SCN_MEM_NOT_PAGED 0x08000000 <span class="comment">// Section is not pageable.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SCN_MEM_SHARED 0x10000000 <span class="comment">// Section is shareable.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SCN_MEM_EXECUTE 0x20000000 <span class="comment">// Section is readable.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SCN_MEM_READ 0x40000000 <span class="comment">// Section is readable.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SCN_MEM_WRITE 0x80000000 <span class="comment">// Section is writeable.</span></span></span><br></pre></td></tr></table></figure><p>위의 매크로 정의들은 메모리 페이지 속성을 나타내는 플래그들이에요.</p><h4 id="IMAGE-SCN-MEM-DISCARDABLE"><a href="#IMAGE-SCN-MEM-DISCARDABLE" class="headerlink" title="IMAGE_SCN_MEM_DISCARDABLE"></a>IMAGE_SCN_MEM_DISCARDABLE</h4><p>이 섹션은 실행 이미지가 메모리에 완전히 매핑되고 난 뒤 버려질 수 있다는 것을 의미해요.<br>일단 메모리에 로드(매핑)되고 난 후 프로세스에게 더 이상 의미없는 섹션이며, 가장 일반적인 버릴 수 있는 섹션은 기본 재배치(.reloc)섹션이에요.</p><h4 id="IMAGE-SCN-MEM-NOT-CACHD"><a href="#IMAGE-SCN-MEM-NOT-CACHD" class="headerlink" title="IMAGE_SCN_MEM_NOT_CACHD"></a>IMAGE_SCN_MEM_NOT_CACHD</h4><h4 id="IMAGE-SCN-MEM-NOT-PAGED"><a href="#IMAGE-SCN-MEM-NOT-PAGED" class="headerlink" title="IMAGE_SCN_MEM_NOT_PAGED"></a>IMAGE_SCN_MEM_NOT_PAGED</h4><p>해당 섹션은 페이지되지 않거나 캐쉬되지 않아요. 페이지 되지 않는다는 말은 결코 페이지 파일로 스왑되지 않는 다는 것을 의미하며 이는 항상 RAM에 존재하는 섹션임을 의미해요. 이런 종류의 섹션을 필요로 하는 경우는 커널 모드에서 작동하는 디바이스 드라이버 가능 실행 모듈이에요.</p><h4 id="IMAGE-SCN-MEM-SHARED"><a href="#IMAGE-SCN-MEM-SHARED" class="headerlink" title="IMAGE_SCN_MEM_SHARED"></a>IMAGE_SCN_MEM_SHARED</h4><p>해당 섹션은 공유 가능한 섹션이라는 것을 의미해요. DLL과 함께 사용될 때 이 섹션에 있는 데이터는 DLL을 사용하는 모든 프로세스들에 의해 공유될 수 있어요.<br>일반적으로 데이터 섹션들은 공유 불가능하다. 이 말은 해당 DLL을 사용하는 각각의 프로세스는 이 섹션의 데이터에 대한 자신만의 사본을 가진다는 의미에요.<br>하지만 공유 가능 섹션은 메모리 매니저에게 해당 섹션을 공유 가능하도록 지시해요. 공유 가능 섹션을 만들려면 링커 시에 SHARED 속성을 주면 되요.</p><blockquote><p>LINK /SECTION:MYDATA, RWS …</p></blockquote><h4 id="IMAGE-SCN-MEM-EXECUTE"><a href="#IMAGE-SCN-MEM-EXECUTE" class="headerlink" title="IMAGE_SCN_MEM_EXECUTE"></a>IMAGE_SCN_MEM_EXECUTE</h4><p>이 섹션은 실행 가능한 섹션임을 의미해요. 이 플래그는 보통 코드 포함 플래그인 IMAGE_SCN_CNT_CODE 플래그와 함께 셋되요.</p><h4 id="IMAGE-SCN-MEM-READ"><a href="#IMAGE-SCN-MEM-READ" class="headerlink" title="IMAGE_SCN_MEM_READ"></a>IMAGE_SCN_MEM_READ</h4><p>이 섹션은 읽기 가능한 섹션임을 의미해요. 이 플래그는 언제나 EXE 파일 내의 대부분의 섹션들에 셋되요.</p><h4 id="IMAGE-SCN-MEM-WRITE"><a href="#IMAGE-SCN-MEM-WRITE" class="headerlink" title="IMAGE_SCN_MEM_WRITE"></a>IMAGE_SCN_MEM_WRITE</h4><p>이 섹션은 쓰기 가능한 섹션임을 의미해요. 이 플래그가 EXE의 섹션에 세트되지 않으면 로더는 메모리 맵드 페이지를 읽기 전용 또는 실행 전용으로 마크한다고 해요.<br>쓰기 가능한 전형적인 예로 .data와 .bss 섹션이 있고, .idata 섹션 역시 이 플래그를 가져요.</p><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Section contains comments or some other type of information</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SCN_LNK_INFO 0x00000200</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Section contents will not become of image.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SCN_LNK_REMOVE 0x00000800</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Section contents comdat.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SCN_LNK_COMDAT 0x00010000</span></span><br></pre></td></tr></table></figure><p>위의 매크로들은 컴파일 후 생성되는 OBJ 파일 내에서만 설정되는 플래그들로서 후에 링크 시에 링크로 하여금 최종 실행 모듈을 생성하는 데 필요한 정보를 참조할 수 있게 되요.</p><h4 id="IMAGE-SCN-LNK-INFO"><a href="#IMAGE-SCN-LNK-INFO" class="headerlink" title="IMAGE_SCN_LNK_INFO"></a>IMAGE_SCN_LNK_INFO</h4><p>해당 섹션이 링커에 의해 사용될 주석이나 다른 어떤 종류의 정보를 가져요. 이 섹션의 전형적인 예는 컴파일러에 의해 생성되며 링커를 위한 명령을 담고 있는 .drectve 섹션이에요.</p><h4 id="IMAGE-SCN-LNK-REMOVE"><a href="#IMAGE-SCN-LNK-REMOVE" class="headerlink" title="IMAGE_SCN_LNK_REMOVE"></a>IMAGE_SCN_LNK_REMOVE</h4><p>이 플래그는 링크 시에 최종 실행 파일의 일부가 되지 말아야 할 섹션의 내용들을 지시해요. 이 섹션들은 링커에게 정보를 넘겨주기 위한 컴파일러나 어셈블러에 의해 사용되요.</p><h4 id="IMAGE-CSCN-LNK-COMDAT"><a href="#IMAGE-CSCN-LNK-COMDAT" class="headerlink" title="IMAGE_CSCN_LNK_COMDAT"></a>IMAGE_CSCN_LNK_COMDAT</h4><p>해당 섹션의 내용은 공용 데이터라는 것을 의미해요. 이것은 COMDATA 라고 하는데, 공용 데이터나 코드 플래그는 여러 OBJ 파일에 걸쳐서 정의될 수 있어요. 링커는 실행 파일로 포함시키기 위해 하나의 복사본을 선택할 수 있어요.<br>COMDATA는 C++ 템플릿 함수와 함수 레벨 링킹을 지원하는데 매우 중요한 녀석이에요.</p><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Default alignemnt if no others are sepcifed.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SCN_ALIGN_1BYTES 0x00100000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SCN_ASLIGN_2BYTES 0x00200000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SCN_ALIGN_4BYTES 0x00300000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SCN_ALIGN_8BYTES 0x00400000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SCN_ALIGN_8192BYTES 0x00E00000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SCN_ALIGN_MASK 0x00F00000</span></span><br></pre></td></tr></table></figure><p>위의 매크로들은 생성된 실행 파일 내의 해당 섹셔의 데이터 정렬 단위를 나타내는 플래그이며, OBJ 파일 내에서만 셋팅되요.</p><h4 id="IMAGE-SCN-ALIGN-XBYTES"><a href="#IMAGE-SCN-ALIGN-XBYTES" class="headerlink" title="IMAGE_SCN_ALIGN_XBYTES"></a>IMAGE_SCN_ALIGN_XBYTES</h4><p>_XBYTES의 값으로 1BYT부터 8192BYTE 까지의 정렬 단위를 사타내요. 특별히 지정되지 않으면 디폴트로 16BYTE에 해당하는 IMAGE_SCN_ALIGN_16BYTES가 되고 이 값은 0x00500000 이에요.</p><br><h3 id="마지막으로…"><a href="#마지막으로…" class="headerlink" title="마지막으로…"></a>마지막으로…</h3><p>IMAGE_SECTION_HEADER에 있는 멤버들 중, <strong>VirtualSize, VirtualAddress, SizeOfRawData, PointerToRawData, Characteristics</strong> 멤버에 대해서는 확실하게 알아야 해요.</p><p>이 멤버들을 이용해서 메모리의 속성이 어떤지 파악할 수 있고, 어떤 부분이 데이터들이 저장되어 있는지 알 수 있거든요. 이 부분을 알아야지 우리가 필요한 데이터들을 찾을 수 있어요.</p><br><p>PE 파일에서 각 섹션의 실제 내용을 확인하고자 한다면 PointerToRawData가 가리키는 위치로 파일 오프셋을 이동시키고, 그곳에서부터 SizeOfRawData의 바이트 수만큼이 해당 섹션의 실제 내용이 되요.<br>이 섹션이 실제로 가상 주소 공간에 매핑되었을 때의 RVA가 VirtualAddress가 되며 매핑된 후의 <strong>섹션의 실제 시작 포인터를 얻고자 한다면 VirtualAddress 값에다가 IMAGE_OPTIONAL_HEADER의 ImageBase 필드 값을 더하면 되요.</strong> 그리고 매핑된 후에 이 섹션이 차지하고 있는 메모리 상의 크기는 VirtualSize에 명시되어 있어요.</p><p>일반적으로 포함되어 있는 섹션의 Charateristics 값을 한번 살펴봐요.</p><h4 id="textbss의-속성"><a href="#textbss의-속성" class="headerlink" title=".textbss의 속성"></a>.textbss의 속성</h4><ul><li>.textbss -&gt; 0xE0000000<ul><li>IMAGE_SCN_MEM__EXECUTE -&gt; 0x20000000</li><li>IMAGE_SCN_MEM_READ -&gt; 0x40000000</li><li>IMAGE_SCN_MEM_WRITE -&gt; 0x80000000</li><li>IMAGE_SCN_CNT_CODE -&gt; 0x00000020</li><li>IMAGE_SCN_CNT_UNINITALIZED_DATA -&gt; 0x00000080</li></ul></li></ul><p>.textbss 섹션은 코드 섹션과 초기화되지 않은 데이터가 있는 .bss 섹션이 혼합되어 있다는 것을 알 수 있어요. 그래서 메모리 속성으로는 실행, 읽기, 쓰기 속성이 지정되어 있고, 컨테이터 속성 중에서는 코드 속성과 초기화되지 않는 데이터 속성이 지정되어 있죠.</p><h4 id="text의-속성"><a href="#text의-속성" class="headerlink" title=".text의 속성"></a>.text의 속성</h4><ul><li>.text -&gt; 0x60000020<ul><li>IMAGE_SCN_MEM_EXECUTE -&gt; 0x20000000</li><li>IMAGE_SCN_MEM_READ -&gt; 0x40000000</li><li>IMAGE_SCN_CNT_CODE -&gt; 0x00000020</li></ul></li></ul><p>이 섹션은 코드 섹션으로서 전형적인 콛그 섹션의 속성만을 가지고 있어요. 메모리 속성으로는 실행과 읽기 속성을 가지며 컨테이너 속성으로는 코드 속성을 가져요.</p><h4 id="rdata의-속성"><a href="#rdata의-속성" class="headerlink" title=".rdata의 속성"></a>.rdata의 속성</h4><ul><li>.rdata -&gt; 0x40000040<ul><li>IMAGE_SCN_MEM_READ -&gt; 0x40000000</li><li>IMAGE_SCN_CNT_INITIALIZED_DATA -&gt; 0x00000040</li></ul></li></ul><p>이 섹션은 읽기 전용 데이터 섹션이에요. 따라서 메모리 속성은 읽기 속성만 가지며 컨테이너 속성으로는 초기화된 데이터 속성을 가져요.</p><h4 id="data-idata의-속성"><a href="#data-idata의-속성" class="headerlink" title=".data, .idata의 속성"></a>.data, .idata의 속성</h4><ul><li>.data, .idata -&gt; 0xC0000040<ul><li>IMAGE_SCN_MEM_READ -&gt; 0x40000000</li><li>IMAGE_SCN_MEM_WRITE -&gt; 0x80000000</li><li>IMAGE_SCN_CNT_INITIALIZED_DATA -&gt; 0x00000040</li></ul></li></ul><p>.data 섹션은 전형적인 데이터 섹션이에요. 그래서 읽기 쓰기가 가능하며, 초기화된 전역 변수들은 모두 이 섹션에 자리를 잡아요. 따라서 메모리 속성은 읽기, 쓰기 속성이 모두 지정되어 있으며 컨테이너 속성은 초기화된 데이터 속성이에요.</p><p>.idata 섹션은 임포트된 DLL과 그 함수들에 대한 정보를 담고 있는 섹션이에요. 따라서 프로그램 로드 시에 로더는 이 섹션을 참조하여 해당 DLL을 메모리에 매핑을 시켜요. 그렇기 때문에 당연히 메모리 속성은 읽기 속성을 가져야 해요. 그리고 이 정보는 링크 시에 정해지기 때문에 초기화된 데이터 컨테이너 속성을 가질 수밖에 없어요.</p><p>하지만 임포트 섹션은 왜 쓰기 속성을 가질까요? 그 이유는 로더가 DLL을 로드한 후에 이 섹션에 존재하는 DLL에 속하는 임포트 함수에 대한 함수 포인터를 임포트 주소 테이블(IAT)라고 하는 곳에 저장하기 떄문이에요.</p><p>임포트 주소 테이블(IAT)이 임포트 섹션 내에 존재하기 때문에 임포트 섹션은 쓰기 속성을 가져야만 하고, 임포트 함수를 사용할 때 임포트 주소 테이블(IAT)를 통해서 함수의 포인터를 얻어서 사용해요.</p><br><br><br><br><br><h2 id="참고자료"><a href="#참고자료" class="headerlink" title="참고자료"></a>참고자료</h2><hr><p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_section_header" target="_blank" rel="noopener">IMAGE_SECTION_HEADER</a></p>]]></content>
      
      
      <categories>
          
          <category> PE file </category>
          
          <category> Windows Reversing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PE 구조 이해하기 - IMAGE_DATA_DIRECTORY 구조</title>
      <link href="/2019/09/19/UnderstandPE5/"/>
      <url>/2019/09/19/UnderstandPE5/</url>
      
        <content type="html"><![CDATA[<p>windows 시스템 실행파일의 구조와 원리 책 내용을 요약 및 정리 하는 포스팅이에요.</p><p>주요 섹션들과 정보들의 위치와 크기를 나타내는 <strong>IMAGE_DATA_DIRECTORAY</strong>에 대한 내용을 알아볼 거에요.</p><br><h2 id="IMAGE-DATA-DIRECTORY의-시작"><a href="#IMAGE-DATA-DIRECTORY의-시작" class="headerlink" title="IMAGE_DATA_DIRECTORY의 시작"></a>IMAGE_DATA_DIRECTORY의 시작</h2><p><strong>이 구조체에는 주요 섹션들과 정보들의 위치와 크기를 나타내는 값들이 저장되어 있어요.</strong><br>구조체 배열의 크기에 대한 값이 <strong>매크로 상수 값(IMAGE_UNMBEROF_DIRECTROY_ENTRIES)</strong>으로 지정이 되어 있지만, 공식 문서에서는 항상 16개로 고정되어 있지 않다고해요.<br>따라서 <strong>IMAGE_DATA_DIRECTORY 구조체의 배열의 개수를 알기 위해서는 IMAGE_OPTIONAL_HEADER 구조체의 NumberOfRvaAndSizes 멤버를 확인</strong>해야 되요.</p><br><p>지금은 16개로 고정되있다고 생각을 할게요!<br>16개가 있다면 이 구조체는 128바이트로 이루어진 구조체 배열이에요.<br>그리고 이 배열의 마지막 엔트리, 인덱스 15에 해당하는 엔트리는 언제나 0으로 세팅되야 한다고 해요.</p><p>즉, <strong>배열의 인덱스 0부터 NumberOfRvaSizes-1까지의 인덱스가 지정하는 필드가 모두 사용되는 것이 아니라 마지막에 해당하는 인덱스를 제외하고 사용하는 거죠.</strong></p><p>각 엔트리들은 나름대로의 의미를 가지고 있고요. 특히 <strong>병합된 섹션과 관련된 정보가 엔트리에 들어가기 때문이에요. 그래서 이 필드는 반드시 참조해야 하는 영역입니다.</strong></p><p>각 배열의 엔트리의 의미는 이것 또한 “WinNT.h” 헤더 파일에 정의되어 있어요.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_UNMBEROF_DIRECTORAY_ENTRIES 16</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_DATA_DIRECTORY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">DWORD VirtualAddress;</span><br><span class="line">DWORD Size;</span><br><span class="line">&#125; IMAGE_DATA_DIRECTROY, *PIMAGE_DATA_DIRECTROY:</span><br></pre></td></tr></table></figure><p><strong>VirtualAddress 와 Size는 각각 해당 IMAGE_DATA_DIRECTORY_ENTRY의 인덱스에 해당하는 미리 지정된 섹션 또는 블록의 정보에 대한 시작 주소와 그 크기를 가리키는 RVA</strong> 이에요.</p><p>예를 들면, 인덱스 0번은 Export Directory(내보내기 함수 테이블)에 대한 RVA와 크기이고, Import Directory(가져오기 함수 테이블)에 대한 RVA와 크기에요.</p><br><h2 id="IMAGE-DATA-DIRECTORY-ENTRY의-종류"><a href="#IMAGE-DATA-DIRECTORY-ENTRY의-종류" class="headerlink" title="IMAGE_DATA_DIRECTORY_ENTRY의 종류"></a>IMAGE_DATA_DIRECTORY_ENTRY의 종류</h2><p>이것 또한 각 인덱스의 의미는 “WinNT.h” 헤더 파일에 정의되어 있죠.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Directory Entries</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_EXPORT          0   <span class="comment">// Export Directory</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_IMPORT          1   <span class="comment">// Import Directory</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_RESOURCE        2   <span class="comment">// Resource Directory</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_EXCEPTION       3   <span class="comment">// Exception Directory</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_SECURITY        4   <span class="comment">// Security Directory</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_BASERELOC       5   <span class="comment">// Base Relocation Table</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_DEBUG           6   <span class="comment">// Debug Directory</span></span></span><br><span class="line"><span class="comment">//      IMAGE_DIRECTORY_ENTRY_COPYRIGHT       7   // (X86 usage)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_ARCHITECTURE    7   <span class="comment">// Architecture Specific Data</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_GLOBALPTR       8   <span class="comment">// RVA of GP</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_TLS             9   <span class="comment">// TLS Directory</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG    10   <span class="comment">// Load Configuration Directory</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT   11   <span class="comment">// Bound Import Directory in headers</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_IAT            12   <span class="comment">// Import Address Table</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT   13   <span class="comment">// Delay Load Import Descriptors</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR 14   <span class="comment">// COM Runtime descriptor</span></span></span><br></pre></td></tr></table></figure><br><h3 id="0번-인덱스-IMAGE-DIRECTORY-ENTRY-EXPORT"><a href="#0번-인덱스-IMAGE-DIRECTORY-ENTRY-EXPORT" class="headerlink" title="0번 인덱스, IMAGE_DIRECTORY_ENTRY_EXPORT"></a>0번 인덱스, IMAGE_DIRECTORY_ENTRY_EXPORT</h3><p>익스포트 테이블(Export Directory Table), IMAGE_EXPORT_DIRECTORY 구조체의 시작 번지를 가리켜요. 이 시작 번지가 <strong>익스포트 섹션의 시작 주소</strong>에요.</p><br><h3 id="1번-인덱스-IMAGE-DIRECTORY-ENTRY-IMPORT"><a href="#1번-인덱스-IMAGE-DIRECTORY-ENTRY-IMPORT" class="headerlink" title="1번 인덱스, IMAGE_DIRECTORY_ENTRY_IMPORT"></a>1번 인덱스, IMAGE_DIRECTORY_ENTRY_IMPORT</h3><p>임포트 테이블(Import Directory Table), IMAGE_IMPORT_DESCRIPTOR 구조체 배열의 번지를 가리켜요. 이 시작 번지가 <strong>임포트 섹션의 시작 주소</strong>에요.</p><br><h3 id="2번-인덱스-IMAGE-DIRECTORY-ENTRY-RESOURCE"><a href="#2번-인덱스-IMAGE-DIRECTORY-ENTRY-RESOURCE" class="headerlink" title="2번 인덱스, IMAGE_DIRECTORY_ENTRY_RESOURCE"></a>2번 인덱스, IMAGE_DIRECTORY_ENTRY_RESOURCE</h3><p>리소스, IMAGE_RESOURCE_DIRECTORY 구조체의 시작 번지를 가리켜요. 이 시작 번지가 <strong>리소스 섹션의 시작 주소</strong>에요.</p><br><h3 id="3번-인덱스-IMAGE-DIRECTORY-ENTRY-EXCEPTION"><a href="#3번-인덱스-IMAGE-DIRECTORY-ENTRY-EXCEPTION" class="headerlink" title="3번 인덱스, IMAGE_DIRECTORY_ENTRY_EXCEPTION"></a>3번 인덱스, IMAGE_DIRECTORY_ENTRY_EXCEPTION</h3><p><strong>예외 핸들러 테이블(Exception Directory Table), IMAGE_RUNTIME_FUNCTION_ENTRY 구조체 배열의 시작 번지</strong>를 가리켜요. CPU에 의존적이고, 테이블 기반 예외 핸들링을 위한 것이죠. x86 계열을 제외한 모든 CPU상에서 사용되는데, X86 기반의 윈도우 PE 파일에서는 의미가 없는 영역이에요.</p><p><strong>IA-64 CPU, 64비트 CPU에서는 사용</strong>하는 영역인거죠!!</p><br><h3 id="4번-인덱스-IMAGE-DIRECTORY-ENTRY-SECURITY"><a href="#4번-인덱스-IMAGE-DIRECTORY-ENTRY-SECURITY" class="headerlink" title="4번 인덱스, IMAGE_DIRECTORY_ENTRY_SECURITY"></a>4번 인덱스, IMAGE_DIRECTORY_ENTRY_SECURITY</h3><p><strong>“WinTrust.h” 헤더 파일에 정의되어 있는 WIN_CRETIFICATEW 구조체들의 리스트 시작 번지</strong>를 가리켜요.<br>이 리스트는 메모리 상에 매핑되지 않기 때문에 <strong>VirtualAddress 필드 값</strong>은 RVA가 아니라 <strong>파일 오프셋</strong>에 해당되요.</p><br><h3 id="5번-인덱스-IMAGE-DIRECTORY-ENTRY-BASERELOC"><a href="#5번-인덱스-IMAGE-DIRECTORY-ENTRY-BASERELOC" class="headerlink" title="5번 인덱스, IMAGE_DIRECTORY_ENTRY_BASERELOC"></a>5번 인덱스, IMAGE_DIRECTORY_ENTRY_BASERELOC</h3><p><strong>기본 재배치(Base Relocation) 정보</strong>를 가리켜요.</p><p><strong>재배치</strong>는 무엇일까요?<br>로더가 실행 모듈을 원하는 위치, 즉 IMAGE_OPTIONAL_HEADER의 <strong>ImageBase 필드에 지정된 가상 주소 공간의 주소에 위치시키지 못했을 때 코드 상의 포인터 연산과 관련된 주소를 다시 갱신해야 하는 경우</strong>를 재배치 라고 불러요!</p><p>저번에 말했듯이 EXE의 경우에는 이런 상황이 거의 없어요. 그 이유는 EXE 파일보다 DLL이 먼저 메모리에 로딩되기 때문이에요. 그에 반면 DLL의 경우에는 빈번히 발생하죠.<br>이를 위해 재배치 섹셔이 존재하는데, 이 필드가 재배치 섹션의 시작 주소를 가리켜요.</p><br><h3 id="6번-인덱스-IMAGE-DIRECTORY-ENTRY-DEBUG"><a href="#6번-인덱스-IMAGE-DIRECTORY-ENTRY-DEBUG" class="headerlink" title="6번 인덱스, IMAGE_DIRECTORY_ENTRY_DEBUG"></a>6번 인덱스, IMAGE_DIRECTORY_ENTRY_DEBUG</h3><p><strong>IMAGE_DEBUG_DIRECTORY 구조체의 배열을 가리키는 번지</strong>에요.<br>각각 해당 <strong>이미지의 디버그 정보를 가지고 있죠.</strong></p><p>초기 볼랜드 링커의 경우 이 인덱스에 해당하는 IMAGE_DATA_DIRECTORY 엔트리의 Size 필드를 이 섹션의 바이트 수가 아니라 구조체의 수로 세트했다고 해요.</p><p>물론 지금은 섹션의 크기를 가지고 있어요!<br>따라서 IMAGE_DEBUG_DIRECTORY 구조체의 수를 얻기 위해서는 Size 필드의 값을 IMAGE_DEBUG_DIRECTORY 구조체의 바이트 수(28 바이트)로 나누면 되요.</p><br><h3 id="7번-인덱스-IMAGE-DIRECTORY-ENTRY-ARCHITECTURE"><a href="#7번-인덱스-IMAGE-DIRECTORY-ENTRY-ARCHITECTURE" class="headerlink" title="7번 인덱스, IMAGE_DIRECTORY_ENTRY_ARCHITECTURE"></a>7번 인덱스, IMAGE_DIRECTORY_ENTRY_ARCHITECTURE</h3><p><strong>아키텍처에 대한 구체적인 데이터, IMAGE_ARCHITECTURE_HEADER 구조체의 배열에 대한 시작 번지</strong>를 가리켜요.</p><p>X86 또는 IA-64 계열에서는 사용하지 않아요.<br>애초에 인텔 계열 CPU를 위해 만들어진 운영체제 이기 때문에 아키텍처에 대한 구체적인 데이터가 필요가 없는거죠!</p><br><h3 id="8번-인덱스-IMAGE-DIRECTORY-ENTRY-GLOBALPTR"><a href="#8번-인덱스-IMAGE-DIRECTORY-ENTRY-GLOBALPTR" class="headerlink" title="8번 인덱스, IMAGE_DIRECTORY_ENTRY_GLOBALPTR"></a>8번 인덱스, IMAGE_DIRECTORY_ENTRY_GLOBALPTR</h3><p><strong>글로벌 포인터 레지스터(GP, Global Pointer)로 사용되는 시작 번지</strong>를 가리켜요.<br>x86에서는 사용되지 않지만, IA-64 에서는 사용되요.<br>여기서 Size 필드는 필요가 없어요. 사용되지 않아요.</p><br><h3 id="9번-인덱스-IMAGE-DIRECTORY-ENTRY-TLS"><a href="#9번-인덱스-IMAGE-DIRECTORY-ENTRY-TLS" class="headerlink" title="9번 인덱스, IMAGE_DIRECTORY_ENTRY_TLS"></a>9번 인덱스, IMAGE_DIRECTORY_ENTRY_TLS</h3><p><strong>스레드 지역 저장소 초기화 섹션에 대한 시작 번지</strong>를 가리켜요.<br>별도의 TLS 함수를 사용하지 않고 __declspec(thread)라는 지시어를 통해 변수가 선언되면 이 변수는 TLS에 들어가게 되고 이를 위해 링커는 별도의 TLS 섹션을 만들게 되죠.</p><br><h3 id="10번-인덱스-IMAGE-DIRECTROY-ENTRY-LOAD-CONFIG"><a href="#10번-인덱스-IMAGE-DIRECTROY-ENTRY-LOAD-CONFIG" class="headerlink" title="10번 인덱스, IMAGE_DIRECTROY_ENTRY_LOAD_CONFIG"></a>10번 인덱스, IMAGE_DIRECTROY_ENTRY_LOAD_CONFIG</h3><p><strong>IMAGE_LOAD_CONFIG_DIRECTORY 구조체애 대한 시작 번지</strong>를 가리켜요.<br>Windows NT, Windows 2000, Windows XP의 구체적인 정보가 들어가 있다고해요.</p><p>이 구조체를 실행 파일에 집어 넣으러면 IMAGE_LOAD_CONFIG_DIRECTORY 구조체를 _load_config_used라는 이름으로 전역적으로 정의 해야 한다고 해요</p><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">extern <span class="string">"C"</span></span><br><span class="line"></span><br><span class="line"><span class="type">IMAGE_LOAD_CONFIG_DIRECTORY</span> __load_config_used = <span class="meta">&#123;...&#125;</span>;</span><br></pre></td></tr></table></figure><br><h3 id="11번-인덱스-IMAGE-DIRECTORY-ENTRY-BOUND-IMPORT"><a href="#11번-인덱스-IMAGE-DIRECTORY-ENTRY-BOUND-IMPORT" class="headerlink" title="11번 인덱스, IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT"></a>11번 인덱스, IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT</h3><p><strong>IMAGE_BOUND_IMPORT_DESCRIPTOR 구조체 배열에 대한 시작 번지</strong>를 가리켜요.<br><strong>DLL 바인딩과 관련된 정보</strong>를 가리켜요.</p><p>이 필드도 중요한 녀석이죠! 나중에 더 상세하게 다룰 예정입니다!</p><br><h3 id="12번-인덱스-IMAGE-DIRECTORY-ENTRY-IAT"><a href="#12번-인덱스-IMAGE-DIRECTORY-ENTRY-IAT" class="headerlink" title="12번 인덱스, IMAGE_DIRECTORY_ENTRY_IAT"></a>12번 인덱스, IMAGE_DIRECTORY_ENTRY_IAT</h3><p><strong>첫 번째 임포트 주소 테이블(IAT, Import Address Table)의 시작 번지</strong>를 가리켜요.<br>임포트된 각각의 DLL에 대한 IAT는 메모리 상에서 연속적으로 나타나게 되요.<br>Size 필드는 모든 IAT의 전체 크기를 가리켜요.</p><p>로더는 임포트 섹션을 해석할 동안 이 엔트리의 주소와 크기를 이용해서 임시적으로 IAT들을 읽기/쓰기 모드로 마킹한다고 해요.</p><br><h3 id="13번-인덱스-IMAGE-DIRECTORY-ENTRY-DELAY-IMPORT"><a href="#13번-인덱스-IMAGE-DIRECTORY-ENTRY-DELAY-IMPORT" class="headerlink" title="13번 인덱스, IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT"></a>13번 인덱스, IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT</h3><p>Visual C++ 이 제공하는 DELAYTMP.H 헤더 파일에 정의되어 있는 <strong>ImgDelayDescr 구조체의 배열을 가리키는 시작 번지</strong>에요.</p><p><strong>지연 로딩 DLL은 해당 API가 처음으로 호출되기 전까지 로드되지 않아요.</strong><br>윈도우는 지연 로딩 DLL에 대한 어떠한 암시적인 정보고 가지고 있지 않아요.<br>전적으로 지연 로딩의 정보는 링커나 런타임 라이브러리에 구현되어 있죠.</p><br><h3 id="14번-인덱스-IMAGE-DIRECTORY-ENTRY-COM-DESCRIPTOR"><a href="#14번-인덱스-IMAGE-DIRECTORY-ENTRY-COM-DESCRIPTOR" class="headerlink" title="14번 인덱스, IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR"></a>14번 인덱스, IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR</h3><p>업데이트된 시스템 헤더 파일에 IMAGE_DIRECTORY_ENTRY_COMHEADER 라는 이름으로 변경되었다고 해요.</p><p>이 필드의 정보는 .NET 응용 애플리케이션이나 DLL용 PE를 위한 거라고 해요.<br>PE 내의 .NET 정보에 대한 최상위 정보의 시작 번지를 가리킨다고 해요.</p><p>이 정보 같은 경우에는 IMAGE_COR20_HEADER 구조체의 형태로 구성되었다고 합니다.</p><br><h2 id="마지막으로…"><a href="#마지막으로…" class="headerlink" title="마지막으로…"></a>마지막으로…</h2><p>모두 다 알면 좋겠지만, <strong>Export Directory, Import Directory, Exception Directory, Base Relocation Table, Bound Import Directory, Import Address Table(IAT), Delay Load Import Descriptors</strong>에 해당 하는 섹션들은 확실하게 공부를 해야한다고 생각을 합니다!</p><br><br><br><br><br><h2 id="참고자료"><a href="#참고자료" class="headerlink" title="참고자료"></a>참고자료</h2><hr><p><a href="https://docs.microsoft.com/ko-kr/windows/win32/api/winnt/ns-winnt-image_data_directory" target="_blank" rel="noopener">IMAGE_DATA_DIRECTORY</a></p>]]></content>
      
      
      <categories>
          
          <category> PE file </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PE 구조 이해하기 - IMAGE_OPTIONAL_HEADER 구조</title>
      <link href="/2019/09/18/UnderstandPE4/"/>
      <url>/2019/09/18/UnderstandPE4/</url>
      
        <content type="html"><![CDATA[<p>windows 시스템 실행파일의 구조와 원리 책 내용을 요약 및 정리 하는 포스팅이에요.</p><p>PE파일의 PE 시그니처 다음에 이어지는 <strong>IMAGE_OPTIONAL_HEADER</strong>에 대한 내용을 알아볼 거에요.</p><br><h2 id="IMAGE-OPTIONAL-HEADER의-시작"><a href="#IMAGE-OPTIONAL-HEADER의-시작" class="headerlink" title="IMAGE_OPTIONAL_HEADER의 시작"></a>IMAGE_OPTIONAL_HEADER의 시작</h2><p>IMAGE_FILE_HEADER에 이어서 나오는 구조체는 <strong>224바이트</strong>로 구성된 <strong>IMAGE_OPTIONAL_HEADER</strong> 이에요.</p><p>IMAGE_OPTIONAL_HEADER 구조체는 <strong>96바이트를 차지하는 30개의 기본 필드</strong>와 <strong>8바이트 크기의 IMAGE_DATA_DIRECTORY 구조체에 대한 엔트리 개수가 16개인 배열 128(=8*16)바이트</strong>로 구성되어 있어요.</p><p>-&gt; IMAGE_OPTIONAL_HEADER32 구조체를 가지고 설명. </p><p>-&gt; 64비트 같은 경우에는 BaseOfData 부분이 없으며, 메모리 영역 부분이 DWORD 형이 아닌 ULONGLONG 형으로 선언이 되어있고, 데이터 디렉토리 구조체의 크기가 고정되어 있지 않음.</p><p>구조체는 다음과 같이 “WinNT.h” 헤더 파일에 정의되어 있음.</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _IMAGE_OPTIONAL_HEADER &#123;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"><span class="type">Standard</span> fields.</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">  <span class="type">WORD</span>                 <span class="type">Magic</span>;</span><br><span class="line">  <span class="type">BYTE</span>                 <span class="type">MajorLinkerVersion</span>;</span><br><span class="line">  <span class="type">BYTE</span>                 <span class="type">MinorLinkerVersion</span>;</span><br><span class="line">  <span class="type">DWORD</span>                <span class="type">SizeOfCode</span>;</span><br><span class="line">  <span class="type">DWORD</span>                <span class="type">SizeOfInitializedData</span>;</span><br><span class="line">  <span class="type">DWORD</span>                <span class="type">SizeOfUninitializedData</span>;</span><br><span class="line">  <span class="type">DWORD</span>                <span class="type">AddressOfEntryPoint</span>;</span><br><span class="line">  <span class="type">DWORD</span>                <span class="type">BaseOfCode</span>;</span><br><span class="line">  <span class="type">DWORD</span>                <span class="type">BaseOfData</span>;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"><span class="type">NT</span> additional fields.</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">  <span class="type">DWORD</span>                <span class="type">ImageBase</span>;</span><br><span class="line">  <span class="type">DWORD</span>                <span class="type">SectionAlignment</span>;</span><br><span class="line">  <span class="type">DWORD</span>                <span class="type">FileAlignment</span>;</span><br><span class="line">  <span class="type">WORD</span>                 <span class="type">MajorOperatingSystemVersion</span>;</span><br><span class="line">  <span class="type">WORD</span>                 <span class="type">MinorOperatingSystemVersion</span>;</span><br><span class="line">  <span class="type">WORD</span>                 <span class="type">MajorImageVersion</span>;</span><br><span class="line">  <span class="type">WORD</span>                 <span class="type">MinorImageVersion</span>;</span><br><span class="line">  <span class="type">WORD</span>                 <span class="type">MajorSubsystemVersion</span>;</span><br><span class="line">  <span class="type">WORD</span>                 <span class="type">MinorSubsystemVersion</span>;</span><br><span class="line">  <span class="type">DWORD</span>                <span class="type">Win32VersionValue</span>;</span><br><span class="line">  <span class="type">DWORD</span>                <span class="type">SizeOfImage</span>;</span><br><span class="line">  <span class="type">DWORD</span>                <span class="type">SizeOfHeaders</span>;</span><br><span class="line">  <span class="type">DWORD</span>                <span class="type">CheckSum</span>;</span><br><span class="line">  <span class="type">WORD</span>                 <span class="type">Subsystem</span>;</span><br><span class="line">  <span class="type">WORD</span>                 <span class="type">DllCharacteristics</span>;</span><br><span class="line">  <span class="type">DWORD</span>                <span class="type">SizeOfStackReserve</span>;</span><br><span class="line">  <span class="type">DWORD</span>                <span class="type">SizeOfStackCommit</span>;</span><br><span class="line">  <span class="type">DWORD</span>                <span class="type">SizeOfHeapReserve</span>;</span><br><span class="line">  <span class="type">DWORD</span>                <span class="type">SizeOfHeapCommit</span>;</span><br><span class="line">  <span class="type">DWORD</span>                <span class="type">LoaderFlags</span>;</span><br><span class="line">  <span class="type">DWORD</span>                <span class="type">NumberOfRvaAndSizes</span>;</span><br><span class="line">  <span class="type">IMAGE_DATA_DIRECTORY</span> <span class="type">DataDirectory</span>[<span class="type">IMAGE_NUMBEROF_DIRECTORY_ENTRIES</span>];</span><br><span class="line">&#125; <span class="type">IMAGE_OPTIONAL_HEADER32</span>, *<span class="type">PIMAGE_OPTIONAL_HEADER32</span>;</span><br></pre></td></tr></table></figure><br><h3 id="첫-번째-멤버-WORD-Magic"><a href="#첫-번째-멤버-WORD-Magic" class="headerlink" title="첫 번째 멤버, WORD Magic"></a>첫 번째 멤버, WORD Magic</h3><p>IMAGE_OPTIONAL_HEADER를 나타내는 <strong>시그니처</strong>에요. 이 값은 3<strong>2비트 PE의 경우 0x010B</strong>이고, <strong>64비트 PE의 경우 0x020B</strong>에요.<br>닷넴 프레임워크 .NET PE의 경우 항상 0x010B 라고 해요.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_NT_OPTIONAL_HDR32 0x10B</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_NT_OPTIONAL_HDR64_MAGIC 0x20B</span></span><br></pre></td></tr></table></figure><br><h3 id="두-번째-멤버-BYTE-MajorLinkerVersion"><a href="#두-번째-멤버-BYTE-MajorLinkerVersion" class="headerlink" title="두 번째 멤버, BYTE MajorLinkerVersion"></a>두 번째 멤버, BYTE MajorLinkerVersion</h3><h3 id="세-번째-멤버-BYTE-MinorLinkerVersion"><a href="#세-번째-멤버-BYTE-MinorLinkerVersion" class="headerlink" title="세 번째 멤버, BYTE MinorLinkerVersion"></a>세 번째 멤버, BYTE MinorLinkerVersion</h3><p>P<strong>E 파일을 만들어낸 링커의 버전</strong>을 나타내요.<br>예를 드러 메이저 0x09, 마이너 0x0A라면 링커 버전 9.10을 나타내는 거죠.</p><p>“Visual Studio.NET Command Prompt”를 실행시켜 Link.exe를 실행시키면 링커의 버전을 확인할 수 있다고 해요.</p><br><h3 id="네-번째-멤버-DWORD-SizeOfCode"><a href="#네-번째-멤버-DWORD-SizeOfCode" class="headerlink" title="네 번째 멤버, DWORD SizeOfCode"></a>네 번째 멤버, DWORD SizeOfCode</h3><p><strong>모든 코드 섹션들의 사이즈를 합한 라운드업된 크기</strong>에요.<br>일반적으로 실행 파일은 하나의 코드 섹션을 가지기 때문에 이 필드는 .text 섹션의 바이트 수와 동일해요.</p><p><strong>정확하게 말하면, 섹션 중 “IMAGE_SCN_CNT_CODE” 속성을 가진 섹션들의 전체 크기</strong>라고 해요.<br>이러한 속성들은 IMAGE_SECTION_HEADER의 Characteristics에서 찾아볼 수 있어요.</p><br><h3 id="다섯-번째-멤버-DWORD-SizeOfInitializeData"><a href="#다섯-번째-멤버-DWORD-SizeOfInitializeData" class="headerlink" title="다섯 번째 멤버, DWORD SizeOfInitializeData"></a>다섯 번째 멤버, DWORD SizeOfInitializeData</h3><p><strong>코드 섹션을 제외한 초기화된 데이터 섹션의 전체 크기</strong>를 나타내요.<br><strong>초기화된 데이터 섹션은 “IMAGE_SCN_CNT_INITALIZED_DATA” 속성</strong>을 가져요.</p><br><h3 id="여섯-번째-멤버-DWORD-SizeOfUninitializedData"><a href="#여섯-번째-멤버-DWORD-SizeOfUninitializedData" class="headerlink" title="여섯 번째 멤버, DWORD SizeOfUninitializedData"></a>여섯 번째 멤버, DWORD SizeOfUninitializedData</h3><p><strong>초기화되지 않은 데이터 섹션(일반적으로 .bss 섹션 또는 .textbss 섹션)의 바이트수</strong>를 나타내요.</p><p><strong>초기화되지 않은 데이터 섹션은 “IMAGE_SCN_CNT_UNINITALIZED_DATA” 속성</strong>을 가져요.</p><p>일반적으로 초기화되지 않은 데이터를 일반 데이터 섹션에 병합시킬 수 있기 때문에 보통 이 필드의 값은 0이 된다.</p><br><h3 id="일곱-번째-멤버-DWORD-AddressOfEntryPoint"><a href="#일곱-번째-멤버-DWORD-AddressOfEntryPoint" class="headerlink" title="일곱 번째 멤버, DWORD AddressOfEntryPoint"></a>일곱 번째 멤버, DWORD AddressOfEntryPoint</h3><p><strong>로더가 실행을 시작할 주소</strong>를 나타내요. RVA 형태로 값이 저장되고, 일반적으로 <strong>.text 섹션 내의 특정 번지</strong>가 되요.<br>즉, 이 필드의 값은 <strong>프로그램이 처음으로 실행될 코드를 담고 있는 주소</strong>인 거죠.</p><p>좀 더 자세히보면, 프로그램이 로드된 후 이 프로세스의 메인 스레드 문맥(Context)의 EIP/RIP 레지스터가 가질 수 있는 최초의 값이에요.<br>일반적으로 이 <strong>번지가 가리키는 값은 소위 말하는 런타임 시작 루틴(EXE의 경우 WinMainCRTStartup 또는 mainCRTStartup, DLL의 경우 DllMainCRTStartup)의 번지 값</strong>이에요.</p><p>AddressOfEntryPoint 멤버는 중요한 필드죠!</p><br><h3 id="여덟-번째-멤버-DWORD-BaseOfCode"><a href="#여덟-번째-멤버-DWORD-BaseOfCode" class="headerlink" title="여덟 번째 멤버, DWORD BaseOfCode"></a>여덟 번째 멤버, DWORD BaseOfCode</h3><p><strong>첫 번째 코드 섹션이 시작 되는 RVA값</strong>을 가지고 있어요.<br>코드 섹션은 전형적으로 PE 헤더 다음, 데이터 섹션 바로 직전에 있어요.</p><p>MS 링커가 만들어내는 EXE의 RVA는 보통 0x1000인데, 이 값은 설정에 따라 바뀔 수 있어요.</p><br><h3 id="아홉-번째-멤버-DWORD-BaseOfData"><a href="#아홉-번째-멤버-DWORD-BaseOfData" class="headerlink" title="아홉 번째 멤버, DWORD BaseOfData"></a>아홉 번째 멤버, DWORD BaseOfData</h3><p>이론적으로 <strong>메모리에 로드될 때 데이터의 첫 번째 바이트의 RVA</strong>를 가리켜요.<br>그리고 이 필드의 값은 MS의 링커 버전에 따라 다르고, 64비트 PE에서는 없는 멤버에요.</p><br><h3 id="열-번째-멤버-ImageBase"><a href="#열-번째-멤버-ImageBase" class="headerlink" title="열 번째 멤버, ImageBase"></a>열 번째 멤버, ImageBase</h3><p>해당 <strong>PE가 가상 주소 공간에 매핑될 때, 매핑시키고자 하는 메모리 상의 시작 주소</strong>에요.</p><p>그 주소가 사용되고 있지 않으면 로더는 이 멤버가 가리키는 값으로 매핑시키기를 원해요.</p><p>만약에 PE 파일이 ImageBase가 가리키는 주소에 로드되면 로더는 기본 재배치를 수행하는 과정을 건너뛸 수 있어요.</p><p><strong>EXE에 대해서 이 값은 기본 이미지 베이스의 값은 0x00400000</strong> 이고, <strong>DLL의 경우 이 값은 0x10000000</strong> 이에요. 이 값들은 링크 시 옵션 /BASE를 지정함으로써 변결될 수 있어요.</p><h4 id="추가적으로…"><a href="#추가적으로…" class="headerlink" title="추가적으로…"></a>추가적으로…</h4><p>일반적으로 PE 파일이 가상 메모리 공간에 매핑될 때, DLL 파일보다 EXE 파일이 먼저 올라가게 되요. 그래서 EXE 파일이 메모리에 올라갈 때 재배치 과정을 거치지 않아요. 하지만 DLL의 경우에는 그 해당하는 위치가 다른 녀석들이 이미 올라가 있는 경우가 많아서 재배치 과정을 거쳐요.</p><p>요즘에는 윈도우의 보호기법 중 하나인 ASLR(Address space layout randomization) 때문에 ImageBase에 있는 주소에 PE 파일들이 매핑되지 않고, 랜덤으로 가상 메모리 공간에 매핑이 되요!</p><br> <h3 id="열한-번째-멤버-SectionAlignment"><a href="#열한-번째-멤버-SectionAlignment" class="headerlink" title="열한 번째 멤버, SectionAlignment"></a>열한 번째 멤버, SectionAlignment</h3><p><strong>PE 파일이 메모리에 매핑될 때</strong> 각 섹션의 시작 주소는 언제나 이 <strong>SectionAlignment 필드에서 지정된 값의 배수가 되는 가상 주소가 되도록 보장되요.</strong></p><p>이러한 제한이 바로 <strong>PE 파일 자체가 메모리 맵 파일</strong>임을 말하고 있는 거에요. </p><p>일반적인 파일들은 시스템 페이징 파일을 통해서 메모리에 매핑이 되지만, <strong>PE 파일 경우에 PE 파일 자체가 페이징 파일이 되기 떄문에 섹션의 시작 주소는 항상 메모리 페이지의 배수</strong>이어야 되요.</p><p>PE 파일 자체가 메모리 맵 파일이라고 하더라도 <strong>메모리에서 PE 파일에 대한 변조가 일어나더라도 실제 파일에는 영향을 끼치지 않아요.</strong></p><p>메모리 속성 중 “<strong>실행 가능</strong>“ 속성을 가지게 되면 이 페이지에 대한 “<strong>쓰기</strong>“ 동작에 대한 파일로의 반영은 “<strong>COW</strong>“ 라는 매커니즘을 통해서 페이지에 데이터를 갱신하게 되면 매핑된 파일로의 반영이 아니라 <strong>해당 데이터를 그 페이지에 갱신하기 직전에 페이지 파일(PageFile.sys)로 복사되어서 백업된 뒤 해당 페이지가 갱신</strong>되요.</p><p>따라서 <strong>메모리에 매핑된 PE는 “실행 가능”속성을 지니기 때문에 디스크 상의 해당 PE 자체로의 즉각적인 반영이 이루어지지 않는거죠.</strong></p><br><h3 id="열두-번째-멤버-FileAlignment"><a href="#열두-번째-멤버-FileAlignment" class="headerlink" title="열두 번째 멤버, FileAlignment"></a>열두 번째 멤버, FileAlignment</h3><p><strong>PE 파일 내에서 섹션들의 정렬 단위</strong>를 나타내요.<br><strong>하드 디스크에 저장된 PE 파일 내의 각각의 섹션을 구성하는 바이너리 데이터들은 FileAlignemnt 필드의 값의 배수</strong>로 시작하도록 보장해요.</p><p><strong>이 값이 실질적으로 디스크의 섹터 단위</strong>가 되는거죠.<br>NTFS의 경우 한 섹터는 디폴트로 4K이고, <strong>보통 0x200 아니면 0x100의 값</strong>을 가지고 있어요.<br>MS 링커 버전에 따라 기본 값은 변경이 되고, 무조건 이 값은 2의 멱승이 되어야 해요.</p><p><strong>만약 SectionAlignment 필드의 값이 CPU 페이지 사이즈보다 작을 경우 이 필드는 SectionAlignment 필드의 값과 같아야 해요.</strong></p><br><h3 id="열세-번째-멤버-MajorOperatingSystemVersion"><a href="#열세-번째-멤버-MajorOperatingSystemVersion" class="headerlink" title="열세 번째 멤버, MajorOperatingSystemVersion"></a>열세 번째 멤버, MajorOperatingSystemVersion</h3><h3 id="열네-번째-멤버-MinorOperatingSystemVersion"><a href="#열네-번째-멤버-MinorOperatingSystemVersion" class="headerlink" title="열네 번째 멤버, MinorOperatingSystemVersion"></a>열네 번째 멤버, MinorOperatingSystemVersion</h3><p><strong>PE 파일을 실행하는 데 필요한 운영체제의 최소 버전</strong>을 말해요.<br>Windows 10 기반에서 컴파일과 링킹 과정을 거쳤다고 하더라도, 특정 버전 이상에서만 지원되는 기능 같은 것들을 사용하지 않으면 그 이전 버전에서도 돌아갈 수 있기 때문에 운영체제의 최소 버전 값이 정해져요.</p><br><h3 id="열다섯-번째-멤버-MajorImageVersion"><a href="#열다섯-번째-멤버-MajorImageVersion" class="headerlink" title="열다섯 번째 멤버, MajorImageVersion"></a>열다섯 번째 멤버, MajorImageVersion</h3><h3 id="열여섯-번째-멤버-MinorImageVersion"><a href="#열여섯-번째-멤버-MinorImageVersion" class="headerlink" title="열여섯 번째 멤버, MinorImageVersion"></a>열여섯 번째 멤버, MinorImageVersion</h3><p>유저가 정의 가능한 필드이며, 사<strong>용자가 만드는 EXE나 DLL에 유저 나름대로의 버전</strong>을 넣을 수 있어요.<br>링킹 시에 /VERSION 옵션을 사용해서 링킹을 해주면 되요.</p><br><h3 id="열일곱-번째-멤버-MajorSubsystemVersion"><a href="#열일곱-번째-멤버-MajorSubsystemVersion" class="headerlink" title="열일곱 번째 멤버, MajorSubsystemVersion"></a>열일곱 번째 멤버, MajorSubsystemVersion</h3><h3 id="열여덟-번째-멤버-MinorSubsystemVersion"><a href="#열여덟-번째-멤버-MinorSubsystemVersion" class="headerlink" title="열여덟 번째 멤버, MinorSubsystemVersion"></a>열여덟 번째 멤버, MinorSubsystemVersion</h3><p><strong>PE 파일을 실행하는 데 필요한 서브시스템의 최소 버전</strong>을 말해요.<br>링킹 시에 /SUBSYSTEM 스위치로 변경할 수 있어요.</p><br><h3 id="열아홉-번째-멤버-Win32VersionValue"><a href="#열아홉-번째-멤버-Win32VersionValue" class="headerlink" title="열아홉 번째 멤버, Win32VersionValue"></a>열아홉 번째 멤버, Win32VersionValue</h3><p>이 필드는 VC++ 6.0 SDK 까지는 예약 필드였는데, 7.0에 와서 Win32VersionValue 라는 이름을 가진 필드로 바뀌었고, 보통 0으로 결정되요.</p><br><h3 id="스물-번째-멤버-DWORD-SizeOfImage"><a href="#스물-번째-멤버-DWORD-SizeOfImage" class="headerlink" title="스물 번째 멤버, DWORD SizeOfImage"></a>스물 번째 멤버, DWORD SizeOfImage</h3><p>이 멤버는 <strong>로더가 해당 PE 파일을 메모리 상에 로드할 때 확보/예약해야 할 해당 PE를 위한 충분한 크기 값</strong>을 가져요.<br>PE 파일의 크기와 같을 수도 있지만 <strong>PE 파일 상에서의 섹션의 배치가 메모리에 매핑되면서 달라질 수 있기 때문에 보통은 PE 파일의 크기보다 커요.</strong></p><p><strong>이 필드의 값은 반드시 SectionAlignment 필드의 값의 배수</strong>가 되어야 해요.</p><br><h3 id="스물-첫-번째-멤버-DWORD-SizeOfHeaders"><a href="#스물-첫-번째-멤버-DWORD-SizeOfHeaders" class="headerlink" title="스물 첫 번째 멤버, DWORD SizeOfHeaders"></a>스물 첫 번째 멤버, DWORD SizeOfHeaders</h3><p>이 필드는 <strong>MS-DOS 헤더, PE 헤더, 섹션 테이블들의 크기를 모두 합친 바이트의 수</strong>에요.<br><strong>모든 헤더나 테이블들은 PE 파일 상에서 반드시 코드 또는 데이터 섹션의 앞쪽에 위치</strong>에 있어야 해요.</p><p><strong>이 필드의 값은 FilaAlignment 필드 값의 배수</strong>가 되어야 해요.</p><br><h3 id="스물-두-번째-멤버-DWORD-CheckSum"><a href="#스물-두-번째-멤버-DWORD-CheckSum" class="headerlink" title="스물 두 번째 멤버, DWORD CheckSum"></a>스물 두 번째 멤버, DWORD CheckSum</h3><p>이름 그대로 이미지의 체크섬 값이다. PE 파일의 체크섬 값은 IMAGEHELP.DLL의 CheckSumMAppedFile API를 통해서 얻을 수 있으며, 체크섬 값은 커널 모드 드라이버나 시스템 DLL의 경우 요구 된다.<br>그 외의 경우라면 보통 0으로 설정이 된다.<br>/RELEASE 링커 스위치를 통해 이 필드를 설정을 할 수 있다.</p><br><h3 id="스물-세-번째-멤버-WORD-Subsystem"><a href="#스물-세-번째-멤버-WORD-Subsystem" class="headerlink" title="스물 세 번째 멤버, WORD Subsystem"></a>스물 세 번째 멤버, WORD Subsystem</h3><p><strong>Win32 아키텍처는 크게 유저 모드와 커널 모드로 나눌 수 있으며, 유저 모드에는 서브시스템이라는 컴포넌트가 존재</strong>해요.</p><p>Win32에서 지원하는 기본 서브 시스템은 Win32 서브시스템, 이전 OS/2와의 호환을 위한 OS/2 서브시스템, 이전 UNIX와의 호환을 위해 최소 표준으로 지원되는 POSIX/CUI 서브시스템 이렇게 3가지 정도가 있다고 해요.</p><p>어떤 서브시스템을 지원하는지 알고 싶으면, “WinNT.h” 헤더 파일에 정의되어 있으니, 그것을 참고하면 되요.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SUBSYSTEM_UNKNOWN              0   <span class="comment">// Unknown subsystem.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SUBSYSTEM_NATIVE               1   <span class="comment">// Image doesn't require a subsystem.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SUBSYSTEM_WINDOWS_GUI          2   <span class="comment">// Image runs in the Windows GUI subsystem.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SUBSYSTEM_WINDOWS_CUI          3   <span class="comment">// Image runs in the Windows character subsystem.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SUBSYSTEM_OS2_CUI              5   <span class="comment">// image runs in the OS/2 character subsystem.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SUBSYSTEM_POSIX_CUI            7   <span class="comment">// image runs in the Posix character subsystem.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SUBSYSTEM_NATIVE_WINDOWS       8   <span class="comment">// image is a native Win9x driver.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SUBSYSTEM_WINDOWS_CE_GUI       9   <span class="comment">// Image runs in the Windows CE subsystem.</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SUBSYSTEM_EFI_APPLICATION      10  <span class="comment">//</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER  11   <span class="comment">//</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER   12  <span class="comment">//</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SUBSYSTEM_EFI_ROM              13</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SUBSYSTEM_XBOX                 14</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SUBSYSTEM_WINDOWS_BOOT_APPLICATION 16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SUBSYSTEM_XBOX_CODE_CATALOG    17</span></span><br></pre></td></tr></table></figure><p>대부분의 경우 IMAGE_SUBSYSTEM_WINDOS_GUI 또는 IMAGE_SUBSYSTEM_WINDOWS_CUI 이에요.</p><p>WinMain()으로 시작하는 경우 IMAGE_SUBSYSTEM_WINDOWS_GUI 인 0x0002가 될 것이고, main()으로 시작하는 콘솔 응용 애플리케이션의 경우 IMAGE_SUBSYSTEM_WINDOWS_CUI인 0x0003이 될거에요.</p><p>그 이외의 다바이스 드라이버 같이 별도로 서브시스템을 사용하지 않는 경우 IMAGE_SUBSYSTEM_NATIVE인 0x00001의 값을 가지게 되요.</p><br><h3 id="스물-네-번째-멤버-WORD-DllCharacteristics"><a href="#스물-네-번째-멤버-WORD-DllCharacteristics" class="headerlink" title="스물 네 번째 멤버, WORD DllCharacteristics"></a>스물 네 번째 멤버, WORD DllCharacteristics</h3><p>이 멤버는 <strong>PE가 DLL 이라는 전제 하에 어떤 상황에서 DLL 초기화 함수(DLLMain())을 호출 되어야 하는지를 지시하는 플래그 값</strong>이 저장되어 있어요.</p><p>“WinNT.h” 헤더 파일에 이 필드에 집어 넣을 수 있는 매크로 정의가 되어 있어요.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DllCharacteristics Entries</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//      IMAGE_LIBRARY_PROCESS_INIT            0x0001     // Reserved.</span></span><br><span class="line"><span class="comment">//      IMAGE_LIBRARY_PROCESS_TERM            0x0002     // Reserved.</span></span><br><span class="line"><span class="comment">//      IMAGE_LIBRARY_THREAD_INIT             0x0004     // Reserved.</span></span><br><span class="line"><span class="comment">//      IMAGE_LIBRARY_THREAD_TERM             0x0008     // Reserved.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DLLCHARACTERISTICS_HIGH_ENTROPY_VA    0x0020  <span class="comment">// Image can handle a high entropy 64-bit virtual address space.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE 0x0040     <span class="comment">// DLL can move.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DLLCHARACTERISTICS_FORCE_INTEGRITY    0x0080     <span class="comment">// Code Integrity Image</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DLLCHARACTERISTICS_NX_COMPAT    0x0100     <span class="comment">// Image is NX compatible</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DLLCHARACTERISTICS_NO_ISOLATION 0x0200     <span class="comment">// Image understands isolation and doesn't want it</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DLLCHARACTERISTICS_NO_SEH       0x0400     <span class="comment">// Image does not use SEH.  No SE handler may reside in this image</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DLLCHARACTERISTICS_NO_BIND      0x0800     <span class="comment">// Do not bind this image.</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DLLCHARACTERISTICS_APPCONTAINER 0x1000     <span class="comment">// Image should execute in an AppContainer</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DLLCHARACTERISTICS_WDM_DRIVER   0x2000     <span class="comment">// Driver uses WDM model</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DLLCHARACTERISTICS_GUARD_CF     0x4000     <span class="comment">// Image supports Control Flow Guard.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE     0x8000</span></span><br></pre></td></tr></table></figure><p>이 중 DllMain() 정의시 아래의 대응 관계처럼 이 진입점 함수의 파라미터로 넘어오는 fdwReason의 가능한 네가지 값과 동일한 위상이라고 볼 수 있어요.</p><ul><li>IMAGE_LIBRARY_PROCESS_INIT &lt; - &gt; DLL_PROCESS_ATTACH</li><li>IMAGE_LIBRARY_PROCESS_TERM &lt; - &gt; DLL_PROCESS_DEATCH</li><li>IMAGE_LIBRARY_THREAD_INIT &lt; - &gt; DLL_THREAD_ATTACH</li><li>IMAGE_LIBRARY_THREAD_TERM &lt; - &gt; DLL_PROCESS_DETACH</li></ul><p>하지만 이 필드의 값은 EXE의 경우에도 0이며, DLL의 경우에도 0이에요.<br>MS는 위의 예약어에 해당하는 네 가지 플래그를 더이상 사용하지 않고 IMAGE_DLLCHARACTERISTIC_XXX 라는 플래그들을 추가했어요.</p><ul><li><p>IMAGE_DLLCHARACTERISTICS_NO_SEH ( 0x0400)</p><blockquote><p>구조적 예외 핸들링(SEH, Structured Exception Handling)을 사용하지 않는다. 구조적 예외 핸들링은 Win32 시스템에서 제공하는 기능(C++ 에서의 try{…}catch(…){…{ 예외 제어 구문과 비슷한 기능)이다.</p><p>Visual C++ 컴파일러의 경우 이 SEH를 지원하기 위해 <strong>try{…}</strong>except(…){…} 라는 키워드를 제공한다. 이 플래그의 경우 VC++ 6.0에서는 지원하지 않음.</p></blockquote></li><li><p>IMAGE_DLLCHARACTERISTICS_NO_BIND ( 0x0800)</p><blockquote><p>이 플래그는 이 이미지를 바인딩하지 않음을 의미함. VC++ 6.0 에서는 없는 정의</p></blockquote></li><li><p>IMAGE_DLLCHARACTERISTICS_WDM_DRIVER ( 0x2000)</p><blockquote><p>드라이버가 WDM 모델을 사용한다는 의미. WDM은 Windows Driver Model의 약자로서 모든 Microsoft Windows 운영체제에 걸쳐서 호환 가능한 소스코드로 구성되는 디바이스 드라이버를 작성할 수 있도록 소개된 모델임.</p><p>WDM 룰을 따르는 커널 모드 드라이버를 WDM 드라이버라고 부름. DDK의 서브셋의 일종임.</p></blockquote></li><li><p>IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE ( 0x8000)</p><blockquote><p>이 플래그는 터미널 서버가 터미널 서비스가 인식하지 못하는 애플리케이션을 로드시켰을 경우 실행 가능하도록 하기 위해 호환 가능한 코드를 담고 있는 DLL도 같이 로드시킬 수 있음을 의미함.</p></blockquote></li></ul><br><h3 id="스물-다섯-번째-멤버-DWORD-SizeOfStackReserver"><a href="#스물-다섯-번째-멤버-DWORD-SizeOfStackReserver" class="headerlink" title="스물 다섯 번째 멤버, DWORD SizeOfStackReserver"></a>스물 다섯 번째 멤버, DWORD SizeOfStackReserver</h3><h3 id="스물-여섯-번째-멤버-DWORD-SizeOfStackCommit"><a href="#스물-여섯-번째-멤버-DWORD-SizeOfStackCommit" class="headerlink" title="스물 여섯 번째 멤버, DWORD SizeOfStackCommit"></a>스물 여섯 번째 멤버, DWORD SizeOfStackCommit</h3><h3 id="스물-일곱-번째-멤버-DWORD-SizeOfHeapReserve"><a href="#스물-일곱-번째-멤버-DWORD-SizeOfHeapReserve" class="headerlink" title="스물 일곱 번째 멤버, DWORD SizeOfHeapReserve"></a>스물 일곱 번째 멤버, DWORD SizeOfHeapReserve</h3><h3 id="스물-여덟-번째-멤버-DWORD-SizeOfHeapCommit"><a href="#스물-여덟-번째-멤버-DWORD-SizeOfHeapCommit" class="headerlink" title="스물 여덟 번째 멤버, DWORD SizeOfHeapCommit"></a>스물 여덟 번째 멤버, DWORD SizeOfHeapCommit</h3><p>프로세스는 가상 주소 공간에 자신만의 스택과 힙을 별도로 가져요.<br>프로세스 생성 시 시스템은 언제나 메인 스레드를 위한 디폴트 스택과 프로세스를 위한 디폴트 힙을 해당 프로세스 내에 생성 시켜 주는데, 이 <strong>스택과 힘의 크기와 속성에 관계된 설정</strong>을 이 필드에서 지정해요.</p><p>PE 파일의 경우 로드되면서 하나의 프로세스가 되든지, DLL 이라면 특정 프로세스의 주소 공간 내부에 잠입해 들어가게 되는데요.<br>이때 <strong>스택과 힙의 예약 크기와 커밋 크기를 지정</strong>해줄 수 있어요.</p><p>PE 파일이 메모리에 로드될 때 시스템은 이 필드들의 값을 참조하여 해당 프로세스에 디폴트 스택과 디폴트 힙을 만들어 줘요.</p><p><strong>링커가 만들어낸 디폴트 값은 스택과 힙 모두 예약 크기 1M인 0x00100000 이며 커밋 크기는 1페이지에 해당하는 4K인 0x00001000</strong>이에요.</p><br><h3 id="스물-아홉-번째-멤버-DWORD-LoaderFlags"><a href="#스물-아홉-번째-멤버-DWORD-LoaderFlags" class="headerlink" title="스물 아홉 번째 멤버, DWORD LoaderFlags"></a>스물 아홉 번째 멤버, DWORD LoaderFlags</h3><p>이 필드는 0으로 설정이되요. 원래 목적은 디버깅 지원에 관계 되었다고 해요.</p><br><h3 id="서른-번째-멤버-DWORD-NumberOfRvaAndSizes"><a href="#서른-번째-멤버-DWORD-NumberOfRvaAndSizes" class="headerlink" title="서른 번째 멤버, DWORD NumberOfRvaAndSizes"></a>서른 번째 멤버, DWORD NumberOfRvaAndSizes</h3><p>이 필드는 바로 다음에 나올 주요 섹션들과 정보들의 위치와 크기를 나타내는  <strong>IMAGE_DATA_DIRECTORY 구조체 배열의 원소 개수를 의미</strong>해요.<br>책 에서는 이 구조체의 개수는 항상 16라서, 이 멤버의 값은 언제나 0x00000010 이라고 해요.</p><p><strong>하지만 공식 문서에서 항상 그렇지 않다고 해요. 따라서 IMAGE_DATA_DIRECTORY 구조체 배열의 개수를 알기 위해서는 이 멤버의 값을 확인 해야 되요.</strong></p><br><h2 id="마지막으로…"><a href="#마지막으로…" class="headerlink" title="마지막으로…"></a>마지막으로…</h2><p>IMAGE_OPTIONAL_HEADER에서 기억하고 가야할 멤버들은 <strong>AddressOfEntryPoint, ImageBase, SectionAlignment, FileAlignment, SizeOfImage, NumberOfRvaAndSizes</strong> 라고 생각해요.</p><p><strong>AddressOfEntryPoint</strong>는 OP의 주소 값이 들어가고,<br><strong>ImageBase</strong>는 가상 주소 공간에 매핑될 때, 매핑시키고자 하는 메모리 상의 주소 값이고,<br><strong>SectionAlignment</strong>는 메모리에 매핑될 때, 섹션의 크기를 확인할 때 사용하는 녀석이고,<br><strong>FileAlignemt</strong>는 파일 내에서, 섹션의 크기를 확인할 때 사용하는 녀석이고,<br><strong>SizeOfImage</strong>는 PE 파일을 메모리 상에 로드할 때 확보해야할 크기 값을 가지고 있는 녀석이고,<br><strong>NumberOfRvaAndSizes</strong>는 PE 파일 안에 있는 섹션들의 위치와 크기를 나타내는 녀석이므로 기억해야 한다고 생각해요!</p><br><br><br><br><br><h2 id="참고자료"><a href="#참고자료" class="headerlink" title="참고자료"></a>참고자료</h2><hr><p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_optional_header64" target="_blank" rel="noopener">IMAGE_OPTIONAL_HEADER</a></p>]]></content>
      
      
      <categories>
          
          <category> PE file </category>
          
          <category> Windows Reversing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PE 구조 이해하기 - IMAGE_FILE_HEADER 구조</title>
      <link href="/2019/09/18/UnderstandPE3/"/>
      <url>/2019/09/18/UnderstandPE3/</url>
      
        <content type="html"><![CDATA[<p>windows 시스템 실행파일의 구조와 원리 책 내용을 요약 및 정리 하는 포스팅이에요.</p><p>PE파일의 PE 시그니처 다음에 이어지는 <strong>IMAGE_FILE_HEADER</strong>에 대한 내용을 알아볼 거에요.</p><br><h2 id="IMAGE-FILE-HEADER-구조체"><a href="#IMAGE-FILE-HEADER-구조체" class="headerlink" title="IMAGE_FILE_HEADER 구조체"></a>IMAGE_FILE_HEADER 구조체</h2><p><strong>IMAGE_FILE_HEADER</strong> 구조체는 <strong>20바이트</strong>로 구성이 되어 있어요.<br>이것도 당연히 “WinNT.h” 헤더 파일에 정의되어 있어요.</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _IMAGE_FILE_HEADER &#123;</span><br><span class="line">  <span class="type">WORD</span>  <span class="type">Machine</span>;</span><br><span class="line">  <span class="type">WORD</span>  <span class="type">NumberOfSections</span>;</span><br><span class="line">  <span class="type">DWORD</span> <span class="type">TimeDateStamp</span>;</span><br><span class="line">  <span class="type">DWORD</span> <span class="type">PointerToSymbolTable</span>;</span><br><span class="line">  <span class="type">DWORD</span> <span class="type">NumberOfSymbols</span>;</span><br><span class="line">  <span class="type">WORD</span>  <span class="type">SizeOfOptionalHeader</span>;</span><br><span class="line">  <span class="type">WORD</span>  <span class="type">Characteristics</span>;</span><br><span class="line">&#125; <span class="type">IMAGE_FILE_HEADER</span>, *<span class="type">PIMAGE_FILE_HEADER</span>;</span><br></pre></td></tr></table></figure><p>구조체 멤버에 대해 하나씩 설명을 해드릴게요.</p><br><h3 id="첫-번째-멤버-WORD-Machine"><a href="#첫-번째-멤버-WORD-Machine" class="headerlink" title="첫 번째 멤버, WORD Machine"></a>첫 번째 멤버, WORD Machine</h3><p>Machine 필드는 PE 파일의 CPU ID를 나타내요. 즉, 사용자가 <strong>어떤 CPU를 통해서 PE 파일을 생성했는지 알 수 있어요</strong>.</p><p>C언어와 C++로 짜여진 코드 같은 경우에는 CPU 의존적이라서 이런 정보가 들어가 있나봐요.</p><p>이것도 CPU ID에 해당하는 매크로 상수가 정의되어 있는데, 자주 사용되는 매크로 상수는 아래와 같아요</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_IA64              0x0200  <span class="comment">// Intel 64</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_AMD64             0x8664  <span class="comment">// AMD64 (K8)</span></span></span><br></pre></td></tr></table></figure><br><h3 id="두-번째-멤버-WORD-NumberOfSections"><a href="#두-번째-멤버-WORD-NumberOfSections" class="headerlink" title="두 번째 멤버, WORD NumberOfSections"></a>두 번째 멤버, WORD NumberOfSections</h3><p><strong>PE 파일에서의 섹션의 수</strong>를 나타내요. IMAGE_SECTION_HEADER 구조체 배열의 원소의 개수. 즉, 해당 PE 파일의 섹션의 개수를 의미해요.</p><br><h3 id="세-번째-멤버-DWORD-TimeDateStamp"><a href="#세-번째-멤버-DWORD-TimeDateStamp" class="headerlink" title="세 번째 멤버, DWORD TimeDateStamp"></a>세 번째 멤버, DWORD TimeDateStamp</h3><p>OBj 파일이라면 컴파일러가, EXE 또는 DLL과 같은 PE 파일이라면 링커가 해당 <strong>파일을 만들어낸 시간</strong>을 의미해요.</p><p>이 값은 1970년 1월 1일 09시(GMT 시간 기준)로부터 해당 파일을 만들어낸 시점까지의 초 단위로 표현해요.</p><br><h3 id="네-번째-멤버-DWOARD-PointerToSymbolTable"><a href="#네-번째-멤버-DWOARD-PointerToSymbolTable" class="headerlink" title="네 번째 멤버, DWOARD PointerToSymbolTable"></a>네 번째 멤버, DWOARD PointerToSymbolTable</h3><p>PointerToSymbolTable 필드는 말 그대로 심볼 테이블의 데이터를 가리키는 주소 값이 들어가는 영역이에요. 즉, <strong>COFF 심벌의 파일 오프셋 값</strong>을 가지고 있는 거에요.</p><p><strong>이 필드 같은 경우에는 컴파일러에 의해 생성되는 OBJ 파일 또는 디버그 모드로 만들어져서 COFF 디버그 정보를 가진 PE 파일에서만 사용이 되요.</strong></p><p>PE 파일은 복수의 디버그 포맷을 지원하기 떄문에 IMAGE_DIRECTORY_ENTRY_DEBUG 엔트리를 참조해야 되고요.</p><p><em>요즘에는 COFF 심벌 테이블은 새로운 디버그 포맷에 의해 대체되어서 PE 파일 내에서는 거의 사용하지 않아요.</em><br>물론 링커 스위치를 /DEBUGTYPE:COFF로 지정할 경우 생성할 수 있어요.</p><br><h3 id="다섯-번째-멤버-DOWRD-NumberOfSymbols"><a href="#다섯-번째-멤버-DOWRD-NumberOfSymbols" class="headerlink" title="다섯 번째 멤버, DOWRD NumberOfSymbols"></a>다섯 번째 멤버, DOWRD NumberOfSymbols</h3><p><strong>PointerToSymbolTable 필드가 가리키는 COFF 심벌 테이블 내에서의 심벌의 수</strong>를 나타냄.</p><p><em>이것도 마찬가지로 새로운 디버그 포맷에 의해 대체되어서 사용되지 않음.</em></p><br><h3 id="여섯-번째-멤버-WORD-SizeOfOptionalHeader"><a href="#여섯-번째-멤버-WORD-SizeOfOptionalHeader" class="headerlink" title="여섯 번째 멤버, WORD SizeOfOptionalHeader"></a>여섯 번째 멤버, WORD SizeOfOptionalHeader</h3><p>IMAGE_FILE_HEADER 구조체 바로 다음에 이어서 나오는 <strong>IMAGE_OPTIONAL_HEADER 구조체의 바이트 수</strong>를 나타내요. </p><p>이 필드는 OBJ 파일의 경우 0이고, 실행 파일의 경우는 “sizeof(IMAGE_OPTIONAL_HEADER)”의 값을 가져요.</p><p>32비트 PE 파일의 경우 0xE0(224)바이트이고, 64비트 PE 파일의 경우 0xF0(240)바이트에요.</p><br><h3 id="일곱-번째-멤버-WORD-Characteristics"><a href="#일곱-번째-멤버-WORD-Characteristics" class="headerlink" title="일곱 번째 멤버, WORD Characteristics"></a>일곱 번째 멤버, WORD Characteristics</h3><p><strong>PE 파일에 대한 특정 정보를 나타내는 플래그</strong>에요. 이 필드도 “WinNT.h” 헤더 파일에 정의되어 있어요.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_RELOCS_STRIPPED           0x0001  <span class="comment">// Relocation info stripped from file.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_EXECUTABLE_IMAGE          0x0002  <span class="comment">// File is executable  (i.e. no unresolved external references).</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_LINE_NUMS_STRIPPED        0x0004  <span class="comment">// Line nunbers stripped from file.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_LOCAL_SYMS_STRIPPED       0x0008  <span class="comment">// Local symbols stripped from file.</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_AGGRESIVE_WS_TRIM         0x0010  <span class="comment">// Aggressively trim working set</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_LARGE_ADDRESS_AWARE       0x0020  <span class="comment">// App can handle &gt;2gb addresses</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_BYTES_REVERSED_LO         0x0080  <span class="comment">// Bytes of machine word are reversed.</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_32BIT_MACHINE             0x0100  <span class="comment">// 32 bit word machine.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_DEBUG_STRIPPED            0x0200  <span class="comment">// Debugging info stripped from file in .DBG file</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP   0x0400  <span class="comment">// If Image is on removable media, copy and run from the swap file.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_NET_RUN_FROM_SWAP         0x0800  <span class="comment">// If Image is on Net, copy and run from the swap file.</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_SYSTEM                    0x1000  <span class="comment">// System File.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_DLL                       0x2000  <span class="comment">// File is a DLL.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_UP_SYSTEM_ONLY            0x4000  <span class="comment">// File should only be run on a UP machine</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_BYTES_REVERSED_HI         0x8000  <span class="comment">// Bytes of machine word are reversed.</span></span></span><br></pre></td></tr></table></figure><p>이 중에서도 중요한 것은 요것들이에요.</p><table><thead><tr><th>매크로명</th><th>값</th><th>의미</th></tr></thead><tbody><tr><td>IMAGE_FILE_RELOCS_STRIPPED</td><td>0x0001</td><td>현재 파일에 재배치 정보가 없음</td></tr><tr><td>IMAGE_FILE_EXECUTABLE_IMAGE</td><td>0x0002</td><td>본 파일은 실행 파일 이미지이다.</td></tr><tr><td>IMAGE_FILE_LINE_NUMS_STRIPPED</td><td>0x0004</td><td>본 파일에 라인 정보가 없다.</td></tr><tr><td>IMAGE_FILE_LOCAL_SYMS_STRIPPED</td><td>0x0008</td><td>본 파일에 로컬 심벌이 없다.</td></tr><tr><td>IMAGE_FILE_AGGRESIVE</td><td>0x0010</td><td>OS로 하여금 적극적으로 워킹셋을 정리할 수 있도록 한다</td></tr><tr><td>IMAGE_FILE_LARGE_ADD_RESS_AWARE</td><td>0x0020</td><td>애플리케이션이 2G 이상의 가상 주소 번지를 제어할 수 있도록한다.</td></tr><tr><td>IMAGE_FILE_32BIT_MACHINE</td><td>0x0100</td><td>본 PE는 32비트 워드 머신을 필요로 한다.</td></tr><tr><td>IMAGE_FILE_DEBUG_STRIPPED</td><td>0x0200</td><td>디버그 정보가 본 파일에는 없고 .DBG 파일에 존재한다.</td></tr><tr><td>IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP</td><td>0x0400</td><td>PE 이미지가 이동 가능한 장치 위에 존재할 때 고정 디스크 상의 스왑 파일로 카피해서 실행한다.</td></tr><tr><td>IMAGE_FILE_NET_RUN_FROM_SWAP</td><td>0x0800</td><td>PE 이미지가 네트워크 상에 존재할 때 고정 디스크 상의 스왑 파일로 카피해서 실행한다.</td></tr><tr><td>IMAGE_FILE_DLL</td><td>0x2000</td><td>본 파일은 동적 링크 라이브러리 파일이다.</td></tr><tr><td>IMAGE_FILE_UP_SYSTEM_ONLYT</td><td>0x4000</td><td>본 파일은 하나의 프로세서만을 장착한 머신에서 실행된다.</td></tr></tbody></table><br><h2 id="마지막으로…"><a href="#마지막으로…" class="headerlink" title="마지막으로…"></a>마지막으로…</h2><p>IMAGE_FILE_HEADER에 대해서 살펴봤는데요.<br><strong>여기서 중요한 멤버들은 섹션의 수를 조절할 수 있는 NumberOfSections 하고, PE 파일에 대한 특정 정보는 나타내는 플래그인 Characteristics</strong> 이에요.</p><p>NumberOfSections을 조절하면, 우리가 원하는대로 임의의 섹션을 추가할 수 있어요. 이러한 방법을 이용해서 악성코드를 삽입도 가능하다고 해요!</p><p>PE 파일에 특정 정보를 나타내는 플래그인 Characteristics 값의 조합을 알고 있으면, PE 파일을 분석할 필요 없이 이 값만을 가지고 PE 파일이 어떤 특징을 가지고 있는지 알 수 있을 거에요.</p><br><br><br><br><br><h2 id="참고자료"><a href="#참고자료" class="headerlink" title="참고자료"></a>참고자료</h2><hr><p><a href="https://docs.microsoft.com/ko-kr/windows/win32/api/winnt/ns-winnt-image_file_header" target="_blank" rel="noopener">IMAGE_FILE_HEADER</a></p>]]></content>
      
      
      <categories>
          
          <category> PE file </category>
          
          <category> Windows Reversing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PE 구조 이해하기 - IMAGE_NT_HEADERS 구조</title>
      <link href="/2019/09/18/UnderstandPE2/"/>
      <url>/2019/09/18/UnderstandPE2/</url>
      
        <content type="html"><![CDATA[<p>windows 시스템 실행파일의 구조와 원리 책 내용을 요약 및 정리 하는 포스팅이에요.</p><p>PE파일의 맨 앞부분에 해당하는 <strong>IMAGE_NT_HEADER</strong>에 대한 알아볼 거에요.</p><p>이 부분은 내용이 길어서 여기서는 간단한 구조체 설명만 할거에요.</p><br><h2 id="PE-파일의-시작"><a href="#PE-파일의-시작" class="headerlink" title="PE 파일의 시작"></a>PE 파일의 시작</h2><p>IMAGE_NT_HEADER은 진정한 PE파일의 시작을 알리는 신호이면서, PE에 관계된 많은 부분을 담고 있어요.</p><p>이것도 마찬가지로 IMAGE_NT_HEADER도 “WinNT.h” 헤더 파일에 정의되어 있어요.</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _IMAGE_NT_HEADERS</span><br><span class="line">&#123;</span><br><span class="line">DWORD Signature<span class="comment">;</span></span><br><span class="line">IMAGE_FILE_HEADER FileHeader<span class="comment">;</span></span><br><span class="line">IMAGE_OPTIONAL_HEADER32 OptionalHeader<span class="comment">;</span></span><br><span class="line">&#125; IMAGE_NT_HEADER32, *PIMAGE_NT_HEADER32<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>여기서 DWORD 형인 Signature 필드는 PE 파일을 나타내는 매직넘버에요. 이 값도 마찬가지로 “WinNT.h” 헤더 파일에 정의되어 있어요.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DOS_SIGNATURE                 0x5A4D      <span class="comment">// MZ</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_OS2_SIGNATURE                 0x454E      <span class="comment">// NE</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_OS2_SIGNATURE_LE              0x454C      <span class="comment">// LE</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_VXD_SIGNATURE                 0x454C      <span class="comment">// LE</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_NT_SIGNATURE                  0x00004550  <span class="comment">// PE00</span></span></span><br></pre></td></tr></table></figure><br><h3 id="PE-파일임을-확인하는-방법"><a href="#PE-파일임을-확인하는-방법" class="headerlink" title="PE 파일임을 확인하는 방법?"></a>PE 파일임을 확인하는 방법?</h3><p>PE 파일을 확인하는 방법은 아주 간단해요.<br>IMAGE_DOS_HEADER 구조체의 마지막 필드인 e_lfanew가 가리키는 값만큼 파일 포인터를 이동시켜 그 오프셋부터 DWORD형으로 값을 읽고, 그 값을 IMAGE_NT_SIGNAUTRE 매크로 상수와 비교하기만 하면 되요.</p><br><h2 id="마지막으로…"><a href="#마지막으로…" class="headerlink" title="마지막으로…"></a>마지막으로…</h2><p>IMAGE_NT_HEADER 구조체는 <strong>매직넘버 필드</strong>뿐만 아니라, PE에 관계된 부분을 설명해주는 다른 구조체들도 포함되어 있어요. <strong>IMAGE_FILE_HEADER</strong> 와 <strong>IMAGE_OPTIONAL_HEADER</strong> 에요.</p><p>여기서는 <strong>IMAGE_NT_HEADERS</strong> 중에서 32비트용 <strong>IMAGE_NT_HEADER32</strong>를 설명을 했어요. 64비트용 <strong>IMAGE_NT_HEADER64</strong>도 있다는 것을 잊지 마세요!<br>그리고 이 구조체에 필드로 들어있는 <strong>IMAGE_OPTIONAL_HEADERS</strong> 도 32비트용인 <strong>IMAGE_OPTIONAL_HEADER32</strong>, 64비트용인 <strong>IMAGE_OPTIONAL_HEADER64</strong>가 있어요.</p><p>32비트용과 64비트용은 별다른 차이가 없어요.<br>대부분의 구조가 거의 같기 때문에 32비트용을 완벽하게 이해하고 차후에 64비트용에서 쓰이는 부분과 바뀐 부분만 체크하면 되요</p><br><br><br><br><br><h2 id="참고자료"><a href="#참고자료" class="headerlink" title="참고자료"></a>참고자료</h2><hr><p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_nt_headers32" target="_blank" rel="noopener">IMAGE_NT_HEADER32</a><br><a href="https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_nt_headers64" target="_blank" rel="noopener">IMAGE_NT_HEADER64</a></p>]]></content>
      
      
      <categories>
          
          <category> PE file </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PE 구조 이해하기 - IMAGE_DOS_HEADER 구조</title>
      <link href="/2019/09/17/UnderstandPE/"/>
      <url>/2019/09/17/UnderstandPE/</url>
      
        <content type="html"><![CDATA[<p>windows 시스템 실행파일의 구조와 원리 책 내용을 요약 및 정리 하는 포스팅이에요.</p><p>PE파일의 맨 앞부분에 해당하는 <strong>DOS 스텁</strong>에 대한 내용을 알아볼 거에요.</p><br><h2 id="DOS-스텁의-시작"><a href="#DOS-스텁의-시작" class="headerlink" title="DOS 스텁의 시작"></a>DOS 스텁의 시작</h2><p>PE 파일은 몇십 바이트의 MS-DOS 스텁으로 시작 하고, MS-DOS 스텁은 예전의 MS-DOS 시절때의 MZ 포맷으로 PE 포맷에서는 큰 의미가 없다고 해요.</p><p>MS-DOS 스텁은 PE 파일을 도스 환경에서 실행 시킬 때 “This program cannot be run in DOS mode” 라는 문장을 출력하기 위한 조그마한 16비트 도스용 응용 프로그램에 불과해요.<br>그리고 DOS 스텁은 40바이트의 IMAGE_DOS_HEADER 구조체와 해당 프로그램 코드로 이루어져 있어요. </p><br><h3 id="IMAGE-DOS-HEADER-구조체"><a href="#IMAGE-DOS-HEADER-구조체" class="headerlink" title="IMAGE_DOS_HEADER 구조체"></a>IMAGE_DOS_HEADER 구조체</h3><p>IMAGE_DOS_HEADER 구조체는 “WinNT.h” 헤더 파일에 정의되어 있다고 해요.</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _IMAGE_DOS_HEADER <span class="regexp">//</span> DOS .EXE header</span><br><span class="line">&#123;</span><br><span class="line">    WORD e_magic;       <span class="regexp">//</span> Magic number</span><br><span class="line">    WORD e_cblp;        <span class="regexp">//</span> Byte on last page of file</span><br><span class="line">    WORD e_cp;          <span class="regexp">//</span> Pages <span class="keyword">in</span> file</span><br><span class="line">    WORD e_crlc;        <span class="regexp">//</span> Relocations</span><br><span class="line">    WORD e_cparhdr;     <span class="regexp">//</span> Size of header <span class="keyword">in</span> paragraphs</span><br><span class="line">    WORD e_minalloc;    <span class="regexp">//</span> Minimum extra paragraphs needed</span><br><span class="line">    WORD e_maxalloc;    <span class="regexp">//</span> Maximum extra paragraphs needed</span><br><span class="line">    WORD e_ss;          <span class="regexp">//</span> Initial (relative) SS value</span><br><span class="line">    WORD e_sp;          <span class="regexp">//</span> Checksum</span><br><span class="line">    WORD e_ip;          <span class="regexp">//</span> Initital IP value</span><br><span class="line">    WORD e_cs;          <span class="regexp">//</span> Initial (relative) CS value</span><br><span class="line">    WORD e_lfarlc;      <span class="regexp">//</span> File address of relocation table</span><br><span class="line">    WORD e_ovno;        <span class="regexp">//</span> Overlay number</span><br><span class="line">    WORD e_res[<span class="number">4</span>];      <span class="regexp">//</span> Reserved words</span><br><span class="line">    WORD e_oemid;       <span class="regexp">//</span> OEM identifier (<span class="keyword">for</span> e_oeminfo)</span><br><span class="line">    WORD e_oeminfo;     <span class="regexp">//</span> OEM information; e_oemid specific</span><br><span class="line">    WORD e_res2[<span class="number">10</span>];    <span class="regexp">//</span> Reserved words</span><br><span class="line">    LONG e_lfanew;      <span class="regexp">//</span> File address of new exe header</span><br><span class="line">&#125; IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;</span><br></pre></td></tr></table></figure><p>IMAGE_DOS_HEADER 구조체는 64바이트로 구성되어 있어요.<br>PE 파일에서 0x0000003F 까지가 IMAGE_DOS_HEADER 구조체에요.<br>이 구조체에서 실제로 쓸모가 있는 것은 <strong>첫 번쨰 필드인 e_magic과 마지막 필드인 e_lfanew</strong> 이에요. 그 이외에 나머지는 사용되지 않아요.</p><br><h2 id="첫-번째-필드인-e-magic"><a href="#첫-번째-필드인-e-magic" class="headerlink" title="첫 번째 필드인 e_magic"></a>첫 번째 필드인 e_magic</h2><p>모든 PE 파일은 IMAGE_DOS_HEADER로 시작해요.<br>이때 e_magic은 <strong>ASCII “MZ”</strong> 로 고정되어 있어요. 위 구조체에서는 e_magic WORD 형으로 되어 있는데, “MZ”을 워드로 읽게 되면 <strong>0x5A4D</strong>가 되요.</p><p>여기서 0x5A=’Z’, 0x4D=’M’ 에 해당해요.<br>인텔 cpu 같은 경우에는 리틀 엔디번 방식으로 메모리를 정렬하기 때문에 0x5A4D로 값을 저장하게 되요.</p><p>이러한 “MZ”도 “WinNT.h” 헤더 파일에 매크로로 정의되어 있어요.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DOS_SIGNATURE 0x5A4D <span class="comment">// MZ</span></span></span><br></pre></td></tr></table></figure><br><h2 id="마지막-필드인-e-lfanew"><a href="#마지막-필드인-e-lfanew" class="headerlink" title="마지막 필드인 e_lfanew"></a>마지막 필드인 e_lfanew</h2><p>IMAGE_DOS_HEADER 구조체에서 <strong>e_flanew</strong> 필드에는 실제 PE 파일의 시작이라고 할 수 있는 <strong>IMAGE_NT_HEADER 시작 오프셋 값</strong>을 가진다고 해요.</p><p>예를 들어서 DWORD 형으로 정의된 e_flanew의 값이 0x000000F0 이라면, 실제 PE 파일의 시작은 0x000000F0 이고, 여기서 PE 파일의 시그니쳐인 “PE”를 볼 수 있어요.</p><br><h2 id="마지막으로…"><a href="#마지막으로…" class="headerlink" title="마지막으로…"></a>마지막으로…</h2><p>IMAGE_DOS_HEADER 와 DOS 스텁은 MS-DOS 시절의 유산물이에요. 우리는 여기서 PE 파일내에서 사용하지 않는 부분이 있다는 것을 알았어요. 앞으로도 PE 파일내에서 사용하지 않는 부분이 존재할거에요. 그리고 이러한 부분들을 이용해서 패커 같은 것을 구현해서 PE 파일의 크기를 줄이고, 리버싱을 하기 어렵게 만들었다고 해요!!</p><p>우리가 <strong>IMAGE_DOS_HEADER에서 e_magic의 값이 0x5A4D</strong> 이어야지 PE 파일이라는 것을 알 수 있다는 사실과 <strong>e_lfanew의 값에 따라서 IMAGE_NT_HEADER의 시작 오프셋 값</strong>을 알 수 있다는 것만 알면 되요.</p>]]></content>
      
      
      <categories>
          
          <category> PE file </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>햄스터 기르기 일지 - 기본편</title>
      <link href="/2019/09/16/HamsterBreddingDiary/"/>
      <url>/2019/09/16/HamsterBreddingDiary/</url>
      
        <content type="html"><![CDATA[<p>어젯밤에 이마트에서 햄스터를 <strong>봤는데</strong>, 너무 귀여운거 있죠<br>그 중에서 가장 유독 눈이 띄는 아이가 있었어요.<br>다른 아이들은 친구들과 놀고 있는데, 펄 햄스터라고 불리는 아이 한명이 계속 잠만 자고 있는 거에요.<br>이 친구가 내 맘을 흔들더라고요.</p><p>지금 당장 데리고 가고 싶었는데, 지금은 분양 받을 수 없다고 하더라고요.<br>그 떄 시간이 오후 10시 30분이었으니까… ㅎㅎㅎ<br>데려갈 수 없었던게 당연한 걸지도 몰라요.<br>덕분에 햄스터를 키우는 데 필요한 용품들을 더 자세하게 찾아보게 되었어요.<br>천만다행이었죠!!<br>그때 햄스터를 데리고 왔다면, 햄스터는 좋은 환경에서 살지도 못하고, 스트레스를 받았을 거에요</p><p>아 그리고 다음날 데리고 왔는데, 아라찌(햄스터)가 은신처에서 잠을 자고 있는데, 관리 하시는 분이 오셔서 은신처에서 쉬고 있는 얘를 탁탁 털어서 꺼내더라고요. 순간 가슴이 철렁했답니다.</p><br><h2 id="햄스터에게-필요한-것들"><a href="#햄스터에게-필요한-것들" class="headerlink" title="햄스터에게 필요한 것들"></a>햄스터에게 필요한 것들</h2><p>너무 데리고 데리고 가고 싶어서, 필요한 것들을 이것저것 찾아 봤어요.<br>햄스터를 기르는데 필수적으로 있어야 하는 것들은<br><strong>햄스터 케이지</strong>, <strong>햄스터 집</strong>, <strong>쳇바퀴</strong>, <strong>급수기</strong>, <strong>급식기</strong>, <strong>베딩</strong>, <strong>밥</strong> 이라고 해요. 일단은 이렇게 7가지가 필수적으로 있어야 된다고 해요.</p><p>그 중 가장 중요한 것은 햄스터 케이지에요!</p><br><h3 id="햄스터-케이지"><a href="#햄스터-케이지" class="headerlink" title="햄스터 케이지"></a>햄스터 케이지</h3><p>햄스터한테 케이지는 가장 중요한 물품에 속해요.<br>케이지의 크기에 따라서 햄스터의 활동반경이 정해지는 지거든요.</p><p>케이지의 종류는 여러가지가 있어요.<br><strong>철장 케이지</strong>, <strong>채집통 케이지</strong>, <strong>수족관 케이지</strong>, <strong>터널형 케이지</strong>, <strong>리빙박스 케이지</strong>이 있어요.</p><p>옛날에는 햄스터를 유통될 때, 가장 손쉽게 구할 수 있는 철장 케이지를 많이 사용했다고 해요.<br>요즘은 철장 비스무리한 플라스틱 케이지도 많이 유통이 되는 것 같아요. 이마트에서 이런 비스무리한<br>플라스틱 철장 케이지를 판매를 하고 있어요.</p><p>채집통 케이지는 소,중,대 사이즈가 있다고해요.<br>보통 일반적으로 채팁통의 크기는 햄스터를 기르기에는 작다고 해요. 일반적으로 햄스터를 다른 곳으로 이동시킬 떄, 이동장 역할로 많이 사용한다고 해요.</p><p>수족관 케이지는 공간이 협소한 우리나라에서는 볼 수 없다고 해요. 보통 일반적으로 서양권에서 볼 수 있다고 해요. 기다란 수족관에다가 햄스터가 살 수 있는 환경을 구성한다고 해요.<br>햄스터들이 완전 기부니가 좋아서 방방 뛸 것 같아요 ㅎㅎ</p><p>터널형 케이지는 햄스터들이 굴속에서 삶을 사는 그 환경을 그대로 재현할 수 있다고 해요. 하지만 가격이 비싸고 청소하기도 힘들어서 터널형 케이지는 자주 볼수 없는 케이스라고 합니다.</p><p><strong>리빙박스 케이지</strong>는 우리나라에서 요즘에 흔히 볼 수 있는 햄스커 케이지라고 해요. 철장 케이지는 햄스터들이 다칠 수 있을 뿐만 아니라 크기가 커질 수록 가격이 상승하거든요. 수족관 케이스도 마찬가지죠.</p><p>그래서 저렴한 리빙박스를 이용해서 햄스터 케이지를 개조하는 경우가 많다고 해요.<br><strong>드워프 햄스터</strong>는 못해도 리빙박스 <strong>55L</strong> 짜리를 구매를 해야 한다고 하고요. <strong>골든 햄스터</strong>는 못해도 <strong>68L</strong> 짜리를 구매를 해야 한다고 해요.</p><p>그래서 아라찌(햄스터)를 데리고 올 때, 리빙박스 55L 짜리로 구매를 했어요. 빠르게 데려오고 싶은 마음 때문에 120L 짜리는 구매를 하지 못한게 아쉬워요.<br>대신 차후에 리빙박스에 구멍을 뚫어서 터널을 연결해서 더 큰 공간을 만들어줄 생각이에요!</p><br><h3 id="햄스터-집"><a href="#햄스터-집" class="headerlink" title="햄스터 집"></a>햄스터 집</h3><p>햄스터 집하고 햄스터 케이지는 다른 거에요. 햄스터를 키울 때, 햄스터의 넓은 활동반경을 조성을 할수가 없어요. 웬만한 부자가 아닌 이상은… 그래서 우리는 타협을 본거에요. 햄스터 케이지를 이만큼의 크기로 햄스터를 기르자. 즉, 햄스터 케이지의 크기는 햄스터의 활동반경의 크기에요.</p><p>햄스터 집은 말그대로 자신만의 영역인거에요! 우리도 엄청나게 넓은 지구에서 살아가고 있잖아요. 그리고 자기 자신만의 집이 존재하죠? 햄스터도 마찬가지에요. 햄스터도 집이 필요해요. 즉, 햄스터 집, 은신처를 만들어주는 거에요.</p><p>은신처는 2~3개 있으면 좋다고해요. 햄스터들이 번갈아가면서 사용한다고 해요. 은신처에다가 먹이를 보관하기도하고 그런다고 하네요 ㅎㅎ</p><br><h3 id="쳇바퀴"><a href="#쳇바퀴" class="headerlink" title="쳇바퀴"></a>쳇바퀴</h3><p>다른 햄스터를 키우는 분들이 말씀하시길, 햄스터에게 쳇바퀴를 제공하지 않으면 동물 학대라고 합니다. 무조건 쳇바퀴를 구매를 해야 한다고 하더라고요.</p><p>그래서 쳇바퀴에 대해서 찾아봤어요. 싼 가격부터 비싼 가격까지 다양하게 있어요. 당연히 비싼게 가장 좋겠죠? 그렇지만 언제나 비싸고 좋은 제품을 살 수가 없용. 우리도 비싼게 좋다는 것을 알지만 항상 비싼것만 사면서 살지는 않잖아요. 그래서 가성비를 본다고 해요.</p><p>쳇바퀴는 <strong>아크릴 쳇바퀴</strong>가 최고봉이라고 해요. 소리도 안나고, 햄스터들이 다칠 이유도 없다고 해요. 하지만 가격이 3만원 이상을 한다고 해요.</p><p>저의 개인적인 생각으로는 발빠짐 쳇바퀴류만 아니면 괜찮다고 생각해요. 저는 소음에 민감한 편이 아니라서 햄스터들이 쳇바퀴 돌리는 시간이 짜증이 나지 않거든요. 그리고 돈이 넉넉한 편은 아니라서 가성비를 생각해서 저같은 경우에는 <strong>사일런트 휠</strong>을 구매를 했어요. 이거 같은 경우에는 만원정도에 인터넷에서 구매를 할 수 있어요.</p><p>아직 쳇바퀴를 케이지 안에 배치를 못해서… 저는 햄스터를 학대하고 있답니다. ㅠㅠㅠ 쳇바퀴가 배송되자마자 바로 케이지에 넣어줄 거에요</p><br><h3 id="급수기와-급식기"><a href="#급수기와-급식기" class="headerlink" title="급수기와 급식기"></a>급수기와 급식기</h3><p>급식기 같은 경우에는 다이소에서 파는 자그마한 그릇으로 충분해요. 거기에다가 햄스터의 몸무게의 12% 해당하는 양만 배식하면 된다고 해요. 햄스터도 인간처럼 편식을 하는 동물이라고 해요. 그래서 원하는 것만 먹다보면, 쉽게 우리처럼 비만이 될 수 있다고 하니 음식 조절을 잘 해줘야 된다고 해요 ㅎㅎㅎ</p><p>그리고 편식을 하지 않는 햄스터 같은 경우에는 큰 그릇에 하루 분량이 아니라 며칠치 분량을 놓아도 된다고 해요. 햄스터의 습성중 하나가 먹을 것들을 은식처에 숨기는 거라고 해요. 급식기에 먹을 것이 있다면, 햄스터들이 그 자리에서 먹지 않고 볼주머니에 음식을 가득 담고 은신처로 파파팍 가는 모습을 볼 수 있을 거에요.</p><p>급수기는 그릇으로 해도 되고, 햄스터용으로 나온 전용 급수기를 사용해도 된다고 해요.<br>급수기는 종류가 여러가지라고 해요. <strong>볼 급수기</strong>, <strong>진공 급수기</strong> 하나 더 있었는데 기억이 안나네요. ㅎㅎ</p><p>볼 급수기는 물이 누수가 발생하기도 하는데, 그런 것을 방지하기 위해서 만든게 진공 급수기라고 해요. 그래서 진공 급수기가 볼 급수기보다 비싸죠. 그렇다고 하더라도 그렇게 비싼 금액은 아니에요 ㅎㅎ</p><p>그릇 같은 경우는 잘 사용하지 않는다고 해요. 그릇에 베딩이 들어갈 수도 있고, 햄스터들이 움직이면서 그릇에 이물질이 들어갈 수 있다고 해서 그릇은 깨끗하지 않다고 해요.그래서 그릇은 비추를 한다고 합니다.</p><p>저 같은 경우에는 아라찌(햄스터)에게 <strong>거치대형 볼 급수기</strong>를 줄거에요. 리빙박스를 벽면을 뚫어서 거는 것보다는 바닥에 배치할 생각이에요. 아직 급수기가 안와서 그릇을 사용하고 있지만, 살짝 미안해지네요 ㅠㅠㅠ</p><br><h3 id="베딩"><a href="#베딩" class="headerlink" title="베딩"></a>베딩</h3><p>햄스터에게 중요한 것이라고 해요. 햄스터의 잠자리가 될 수도 있고, 햄스터의 놀이터가 될 수도 있거든요. 햄스터들이 파묻힐 수 있을 정도로 베딩을 깔아줘야 된다고 해요.</p><p>베딩의 종류도 여러가지가 있어요. 톱밥도 있고, 종이 베딩도 있고, 천 베딩도 있어요. 톱밥 하고 종이 베딩은 햄스터의 면역력에 따라서 사용하면 된다고해요. 그 중에서도 끝판왕이 당연히 존재하겠죠? 그게 바로 <strong>아스펜 베딩</strong>이라고 해요. 다른 것들에 비해 가격이 비싸지만, 햄스터들에게 안전성이 보장된 베딩이라고 해요. 그리고 천 베딩은 웬만하면 사용하지 말라고 하네요. 천 베딩 같은 경우에는 꾸준히 갈아줘야 되서 여러 개를 구매할 뿐만 아니라 세탁을 하는 것도 귀찮고 햄스터들의 본능인 디깅을 하지 못한다는게 단점이에요. 물론 따로 디깅박스를 만들어준다고 하더라도 전 개인적으로 천 베딩을 하지 않을 것 같아요.</p><p>하지만 햄스터가 아프다면, 천 베딩을 할거나, 베딩을 아에 깔지 않을지도 몰라요. 햄스터가 아플 경우에는 의료목적으로 베딩을 깔지 않는다고 해요.</p><p>그리고 베딩에는 압축 베딩 비압축 베딩이 있다고해요. 압축 베딩은 말그대로 압축해서 베딩을 포장한 것이고요, 비압축 베딩은 압축하지 않은 상태로 베딩을 포장한 것이에요.<br>압축 베딩이 비압축 베딩에 비해 먼지가 많다고해요. 어찌됬든 압축 베딩과 비압축 베딩 둘다 먼지를 털어내고 사용하는 것이 좋다고 해요. 저도 알았다면, 먼지를 털어주고 깔아줬을 텐데… 먼저 데려오고 준비를 하다보니까… 미숙한 저의 모습이 보이는 것 같아요.</p><p>저 같은 경우네느 펫 리터의 종이 베딩을 사용하고 있어요. 이마트에서 9000원 주고 구입했어요 ㅎㅎ. 55L 짜리 리빙박스에 이것을 다 부으니까 햄스터가 굴도파고 푹 파고 들어갈 수 있더라고요</p><br><h3 id="밥"><a href="#밥" class="headerlink" title="밥"></a>밥</h3><p>사람에게 있어서 밥이 중요하듯이 햄스터한테도 밥이 중요해요. 사람들도 건강을 지키는 사람들은 영분을 따져가면서 밥을 먹듯이 햄스터도 건강을 지킬러면 영양분을 따져가면서 먹어야 해요.<br>마트에서 파는 일반적인 사료들은 햄스터의 영양분을 충족시키지 못하는 저급사료라고 해요.<br>여기서 저급 사료는 사료의 질이 좋지 않다는게 아니라, 햄스터에게 영양분을 골고루 주지 못한다는 의미에요.</p><p>그래서 좀더 찾아보면서 우리 햄스터에게 좋은게 뭐가 있을지 찾아볼 계획이에요 ㅎㅎ</p><br><h3 id="기타-등등"><a href="#기타-등등" class="headerlink" title="기타 등등"></a>기타 등등</h3><p>햄스터들은 일반적으로 대소변 훈련을 시킬수가 없다고 해요.<br>하지만 시킬수 있다고해요!!! 햄스터들은 소변을 볼 때, 가장자리에 소변을 보는 경향이 있는데, 그 부분을 잘 관찰해서 거기다가 화장실을 만들면, 거기서 소변을 보게 만들 수 있다고 해요.<br>똥 같은 경우에는 아무곳에서나 싸기 때문에 가릴수가 없다고 해요.</p><p>똥 같은 경우에는 햄스터들이 자기가 어느 한 곳에다가 모아두는 경향이 있기도 하지만, 웬만해서는 그냥 흩뿌리고 다닌다고 하네요 ㅎㅎ 우리 햄스터들 귀엽죵 ㅎㅎㅎ</p><p>저는 마트에서 파는 목욕용 모래를 가지고 왔어요. 근데 이게 알고보니까 엄청 햄스터들에게 안 좋다고 하더라고요. 그래서 햄스터들한테 좋은 사막모래로 바꿔줄 예정입니다. 안 좋은 이유는 목욕용 모래가 입자가 고와서 햄스터에 기관지에 들어가면 좋지 않다고 합니다. 사람도 마찬가지죠? </p><p>우리 아라찌(햄스터)가 목욕용 모래에서 소변을 봤어요!!! 그것도 처음 데려온 날 말이죠. 저는 이 목욕용 모래가 마법의 가루라고 생각해요. 어떤 사람들은 이런 모래를 마약이라고 해요. 대소변 못가리는 햄스터들이 마법처럼 대소변을 가리게 된다고 해서요 ㅎㅎ</p><br><h2 id="먹이를-집으로-feat-아라찌"><a href="#먹이를-집으로-feat-아라찌" class="headerlink" title="먹이를 집으로 feat. 아라찌"></a>먹이를 집으로 feat. 아라찌</h2><p>이제 포스팅을 끝났어요 ㅎㅎ 햄스터를 처음 데려왔을 때 일주일 동안은 햄스터에게 관심을 가지면 안된다고 해요. 근데 너무 귀여워서… 어쩔수 없이 동영상을 찍어버렸어요.<br>마지막으로 아라찌가 먹이를 집으로 가져가는 모습을 볼까요? ㅎㅎ</p><img src="/2019/09/16/HamsterBreddingDiary/hamster.gif" title="먹이를-집으로"><p>ㅎㅎ 귀엽죠? 원래 베딩위에 아라찌 집이 있었는데, 제가 잠든 사이에 베딩을 열심히 옮겨서 은식처를 베딩안으로 파묻었어요. 우리 아라찌가 집이 엄청 맘에 드나봐요. 근데 이렇게 아라찌가 굴속에서만 살면, 저는 언제 아라찌를 볼 수 있을까요? ㅠㅠㅠㅠ</p><img src="/2019/09/16/HamsterBreddingDiary/bury-house.jpeg" title="파묻힌집">]]></content>
      
      
      <categories>
          
          <category> hamster </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hamster </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unlink 취약점?</title>
      <link href="/2019/09/12/UnlinkVulnerability/"/>
      <url>/2019/09/12/UnlinkVulnerability/</url>
      
        <content type="html"><![CDATA[<p>pwnable.kr unlink 문제를 풀어보기 위해서, unlink 취약점에 대해서 찾아 봤어요.<br>처음에 봤을 때는, 하나도 이해가 안 갔지만 ㅠㅠㅠ<br>그래도 계속 읽다보고 생각하다보니까 아주 조금 이해가 됬어요!!<br>조금이라도 더 기억하기 위해서 한번 끄적여 볼게요</p><br><h2 id="malloc의-동적할당"><a href="#malloc의-동적할당" class="headerlink" title="malloc의 동적할당?"></a>malloc의 동적할당?</h2><p>malloc을 통해서 32바이트만큼 동적할당을 한다고 생각해봐요.<br>실제로 heap 영역에는 32바이트만큼 메모리가 할당이 되어야할 것 같지만, <strong>실제로는 40바이트가 할당이 됩니다.</strong><br>왜 그럴까요? 바로, 할당된 메모리를 관리하기 위한 정보들이 포함되어 있기 때문이에요!<br>그러한 정보는 <strong>chunk</strong>라고 불리는 구조체를 통해 관리됩니다.</p><br><h2 id="chunk의-구조"><a href="#chunk의-구조" class="headerlink" title="chunk의 구조"></a>chunk의 구조</h2><p>아까 말했듯이 동적할당된 메모리는 chunk라고 불리는 구조체로 관리하고 있어요.<br>이 구조체는 다음과 같이 구성되어 있죠</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>&#123;</span></span><br><span class="line">    INTERNAL_SIZE_T mchnk_prev_size; <span class="comment">/* Size of previous chunk (if free). */</span></span><br><span class="line">    INTERNAL_SIZE_T mchnk_size; <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Only sued for large blocks: pointer to next larger size. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span></span><br><span class="line">    sutrct malloc_chunk* bk_nextsize;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">mchunkptr</span>;</span></span><br></pre></td></tr></table></figure><p>mchunk_prev_size: 해제가 되면, 이전 chunk의 크기를 가지게 되요.</p><p>mchunk_size: overhead를 포함해서,  현재 chunk의 크기를 가지게 되요. 여기서 overhead는 하위 3비트에 set되는 플래그를 말해요.</p><ul><li>P(PREV_INUSE): 이전의 chunk가 없으면 0으로 셋되는 데, 맨 처음 chunk에서는 free 됬을 때 합병되지 않도록 하기위해서 1로 셋이 되어 있어요.</li><li>M(IS_MMAPPED): mmap함수를 통해서 만들어진 chunk일 경우 1로 셋이 되요.</li><li>A(NON_MAIN_ARENA): main 쓰레드에서 만들어졌을 경우 0으로 셋이 되지만 그외의 쓰레드에서 만들어질 경우 1로 셋이 되요.</li></ul><p>fd, bk: 각각 forward pointer, back pointer 라고해서 다음의 chunk를 가리키고, 이전의 chunk를 가리켜요.</p><br><h3 id="할당된-메모리와-해제된-메모리의-차이"><a href="#할당된-메모리와-해제된-메모리의-차이" class="headerlink" title="할당된 메모리와 해제된 메모리의 차이?"></a>할당된 메모리와 해제된 메모리의 차이?</h3><p>이제 할당된 메모리와 해제된 메모리가 어떤 차이가 있는지 알아봅시다.</p><p><code>Allocated chunk</code></p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">            |             <span class="type">Size</span> of previous chunk, <span class="keyword">if</span> unallocated (P <span class="built_in">clear</span>)  |<span class="type"></span></span><br><span class="line"><span class="type">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="type">            |             Size</span> of chunk, <span class="built_in">in</span> bytes                     |<span class="type">A</span>|<span class="type">M</span>|<span class="type">P</span>|<span class="type"></span></span><br><span class="line"><span class="type">      mem</span>-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">            |             <span class="type">User</span> data starts here...                          .</span><br><span class="line">            .                                                               .</span><br><span class="line">            .             (malloc_usable_size() bytes)                      .</span><br><span class="line">            .                                                               |<span class="type"></span></span><br><span class="line"><span class="type">nextchunk</span>-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">            |             <span class="type">(size</span> of chunk, but used <span class="keyword">for</span> application data)    |<span class="type"></span></span><br><span class="line"><span class="type">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="type">            |             Size</span> of next chunk, <span class="built_in">in</span> bytes                |<span class="type">A</span>|<span class="type">0</span>|<span class="type">1</span>|<span class="type"></span></span><br><span class="line"><span class="type">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br></pre></td></tr></table></figure><p><code>Free chunk</code></p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">            |             <span class="type">Size</span> of previous chunk, <span class="keyword">if</span> unallocated (P <span class="built_in">clear</span>)  |<span class="type"></span></span><br><span class="line"><span class="type">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="type">    `head</span>:' |             <span class="type">Size</span> of chunk, <span class="built_in">in</span> bytes                     |<span class="type">A</span>|<span class="type">0</span>|<span class="type">P</span>|<span class="type"></span></span><br><span class="line"><span class="type">      mem</span>-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">            |             <span class="type">Forward</span> pointer to next chunk <span class="built_in">in</span> list             |<span class="type"></span></span><br><span class="line"><span class="type">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="type">            |             Back</span> pointer to previous chunk <span class="built_in">in</span> list            |<span class="type"></span></span><br><span class="line"><span class="type">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="type">            |             Unused</span> space (may be <span class="number">0</span> bytes long)                .</span><br><span class="line">            .                                                               .</span><br><span class="line">            .                                                               |<span class="type"></span></span><br><span class="line"><span class="type">nextchunk</span>-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">    `foot:' |             <span class="type">Size</span> of chunk, <span class="built_in">in</span> bytes                           |<span class="type"></span></span><br><span class="line"><span class="type">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="type">            |             Size</span> of next chunk, <span class="built_in">in</span> bytes                |<span class="type">A</span>|<span class="type">0</span>|<span class="type">0</span>|<span class="type"></span></span><br><span class="line"><span class="type">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br></pre></td></tr></table></figure><p>할당된 chunk와 해제된 chunk를 비교하시면 사용하고 있는 데이터 영역이 다르다는 것을 알수가 있어요.<br>할당된 chunk 같은 경우에는 저희가 입력한 데이터들이 들어가 있지만, 해제된 chunk에는 아까 말했던 FD와 BK가 들어가 있고, 나머지 영역은 사용하지 않는다는 것을 알 수가 있어요.</p><p>동적메모리가 어떻게 할당되는지 알았으니, 이러한 동적메모리가 여러 개가 존재를 한다고 생각해봐요.<br>그러면 이러한 동적메모리들을 한 곳에 모아서 보관하는 것이 편하겠죠?<br>그래서 <strong>bin</strong>이라는 자료구조가 존재해요!!</p><br><h2 id="bin-자료구조"><a href="#bin-자료구조" class="headerlink" title="bin 자료구조"></a>bin 자료구조</h2><p>bin 자료구조는 총 4가지가 있다고해요.<br>chunk의 크기에 따라서 사용되는 bin이 달라져요.</p><ul><li>Fast bin</li><li>Unsorted bin</li><li>Small bin</li><li>Large bin</li></ul><p><strong>Fast bin</strong>은 10개가 존재하고, 다른 bin들은 double linked list로 구성되어 있지만, Fast bin은 single linked list로 구성되어 있어요.<br>데이터를 삭제하거나 추가할 때 LIFO 방식으로 동작한다고 합니다.<br>그리고 각각의 bin들은 크기가 달라요. 16, 24, 32, 48, 56, 64, 72, 80, 88 순으로 구성되어 있죠.<br>당연히 여기에도 메타 데이터가 포함되요.</p><p><strong>Unsorted bin</strong>은 오직 한개만 존재하는데, 이 놈은 다른놈들과 달라요. 이 bin의 목적은 cache layer처럼 빠르게 할당과 해제를 할 수 있게 도와주는 녀석이에요. 즉, 같은 크기의 chunk가 있다면 해당 chunk를 재사용하는 거에요.<br>메모리를 동적할당하고 사용하고 나서 어떤 값을 입력하고 해제한 후, 똑같은 크기의 메모리를 재사용할 때, 메모리를 초기화 해주는 작업을 해주지 않으면 그 메모리 안에 쓰레기 값이 존재할 수도 있어요. 그리고 이를 이용해서 exploit도 가능하다고 합니다.!!</p><p><strong>Small bin</strong>은 62개가 존재하고, 16byte에서 시작해서 8byte씩 늘어낙서 504byte까지 존재한다고 해요. 추가하고 제거하는 방식은 FIFO 방식으로 관리 된다고 합니다.<br>그리고 small bin 같은 경우에는 해제된 후에, Unsorted bin에 의해 관리되기전에 서로서로가 합쳐질수도 있다고 합니다.</p><p><strong>Large bin</strong>은 63개가 존재하고, 처음 32개의 bin들은 64byte만큼 떨어져 있지만, 특정 large bin들은 크기가 다른 chunk들을 가질 수 있다고 합니다. 그리고 추가하고 제거하는 방식은 어떤 자리에서도 일어날 수 있다고 합니다.!</p><br><h2 id="동적할당-해제"><a href="#동적할당-해제" class="headerlink" title="동적할당 해제"></a>동적할당 해제</h2><p>이렇든 chunk들은 4가지의 bin을 통해서 관리가 되고, list를 이동해야할 일도 생긴다고 해요. 이때, free() 함수가 실행되는 과정중에 <strong>unlink</strong>라는 매크로 함수가 불릴 때 발생한다고 해요.</p><img src="/2019/09/12/UnlinkVulnerability/1.png" title="unlink"> <p>free된 chunk가 다시 malloc 되는 경우,<br>chunk의 크기가 증가해서 다른 bin으로 이동할 경우,<br>어떤 chunk가 free 되었을 때,<br>연속된 위치의 다른 chunk가 free 되었을 떄,<br>unlink 매크로 함수를 통해서 2개의 chunk를 합병을 해준다고 해요.</p><p>이렇게 chunk의 사이즈가 증가할 때는 원래 속해있던 bin 리스트에서 해당 chunk를 제거하고, 다시 적절한 bin에 넣어줘야 한다고 합니다.</p><br><p>이때 unlink corruption -&gt; Double Free Bug가 발생한다고 합니다.<br>맨 처음에 봤을 때는 무슨 이상한 줏자들과 함께 써져 있어서, 헷갈리고 이게 무슨 소리인지 이해되지 않았어요.<br><strong>fd와 bk를 조작해서 우리가 원하는 값을 쓸수 있다는 것만 알고 있으면 되요!!</strong></p><img src="/2019/09/12/UnlinkVulnerability/2.png" title="unlink-corruption"><br><br><br><br><br><h2 id="참고자료"><a href="#참고자료" class="headerlink" title="참고자료"></a>참고자료</h2><hr><p><a href="https://heap-exploitation.dhavalkapil.com/diving_into_glibc_heap/malloc_chunk.html#" target="_blank" rel="noopener">Heap Exploitation</a><br><a href="https://bpsecblog.wordpress.com/2016/10/06/heap_vuln/" target="_blank" rel="noopener">Heap 영역에서 발생하는 취약점을 알아보자.</a></p>]]></content>
      
      
      <categories>
          
          <category> System hacking </category>
          
      </categories>
      
      
        <tags>
            
            <tag> System hacking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 블로그 만들기 삽질 일지 - 2</title>
      <link href="/2019/09/12/HowToCreateBlogUingHexo2/"/>
      <url>/2019/09/12/HowToCreateBlogUingHexo2/</url>
      
        <content type="html"><![CDATA[<p>어떤 기기에서든 hexo 블로그를 업데이트 하기 위해서는 hexo 프로젝트와 hexo 테마를 백업을 해야 한다.</p><p>그 이유는 hexo 프로젝트를 통해서 배포를 할 때, 올라가는 데이터들은 웹사이트을 구동시킬 때 필요한 데이터들이 USERNAME.github.io 에 올라 가는 것이기 때문이다. </p><p>즉, hexo 블로그를 만들면서 포스팅 했던 데이터들은 github에 올라가지 않는다.<br>따라서 별도로 hexo 프로젝트를 백업할 필요가 있다.</p><br><h2 id="어디서-백업을-해야할까"><a href="#어디서-백업을-해야할까" class="headerlink" title="어디서 백업을 해야할까?"></a>어디서 백업을 해야할까?</h2><p>다시 한번 말하자면, hexo 프로젝트 안에 있는 데이터를 보관하기 위한 새로운 저장소를 만들어야 한다.</p><p>github 을 이용하든 gitlab을 이용하든 상관은 없다.<br>하지만 배포를 할 떄 github을 이용했고, github에서 현재 private도 무료로 서비스를 제공하기 때문에 github을 사용하는 것이 좋다.</p><p>저장소를 만들 때,<br>private를 선택하든, public를 선택하든 상관은 없다.<br>자신의 데이터를 공개하고 싶지 않다면, private를 선택하는 것이고, 자신의 데이터를 공개해도 좋다고 하면, public을 선택할 뿐이다.</p><br><h2 id="새로운-저장소-생성"><a href="#새로운-저장소-생성" class="headerlink" title="새로운 저장소 생성"></a>새로운 저장소 생성</h2><p>저장소는 총 2개가 필요하다. 하나는 테마를 보관할 곳, 또 다른 하나는 hexo 프로젝트를 보관할 곳이다.</p><p>저장소의 이름은 사용자가 구분하기 쉽고, 쉽게 이용할 수 있는 이름으로 정하면 된다.</p><p>나 같은 경우에는 설명하기 쉽게 hexo 프로젝트를 저장할 공간인 <em>blog</em> 테마를 저장할 공간인 <em>theme</em> 라는 이름으로 만들었다.</p><br><h3 id="hexo-프로젝트-백업하기"><a href="#hexo-프로젝트-백업하기" class="headerlink" title="hexo 프로젝트 백업하기"></a>hexo 프로젝트 백업하기</h3><p>hexo 프로젝트를 백업하는 방법은 간단하다.<br>다음처럼 git을 만들어 주기만 하면된다.</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># initialize git</span></span><br><span class="line">git init</span><br><span class="line"></span><br><span class="line"><span class="meta"># add contents</span></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line"><span class="meta"># commit contents</span></span><br><span class="line">git commit -m <span class="string">"Initial commit"</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># change remote repository</span></span><br><span class="line">git remote add origin https:<span class="comment">//github.com/777bareman777/blog.git</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># push contents</span></span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><br><h3 id="테마-백업하기"><a href="#테마-백업하기" class="headerlink" title="테마 백업하기"></a>테마 백업하기</h3><p>직접 만든 경우에는 상관은 없지만, 다른 사람들이 만든 테마 같은 경우에는 백업하기가 힘들다.</p><p>fork를 하든, duplicate를 하든 상관이 없다.<br>어차피 원래의 테마 개발자가 업데이트를 하고, 우리가 그것을 따르고 싶다면, 우리가 설정했던 것들은 날라가기 때문이다.</p><p>-&gt; 그럴 경우에는 자신이 설정했던 파일들을 따로 백업을 하는 것이 좋음.</p><p>그렇지 않고, 그 테마를 가지고 스스로 수정하고 싶다면 fork를 하는 것이 좋을지도 모른다.</p><p>일단은 duplicate를 했을 때를 생각해보자.</p><p>원하는 테마를 고르고 duplicate를 하고, 저장소 위치를 우리가 theme를 만들고자 했던 곳으로 바꾸고,<br>안에 있는 데이터들을 올리기만 하면된다.</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># clone theme</span></span><br><span class="line"><span class="string">git </span><span class="string">clone </span><span class="string">https:</span>//<span class="string">github.</span><span class="string">com/</span><span class="string">aircloud/</span><span class="string">hexo-theme-</span><span class="string">aircloud</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#</span> <span class="string">check </span><span class="string">remote </span><span class="string">repository</span></span><br><span class="line"><span class="string">git </span><span class="string">remote </span>-v</span><br><span class="line"></span><br><span class="line"><span class="comment"># change retmoe repository</span></span><br><span class="line"><span class="string">git </span><span class="string">remote </span><span class="built_in">set-url</span> <span class="string">origin </span><span class="string">https:</span>//<span class="string">github.</span><span class="string">com/</span><span class="string">777bareman777/</span><span class="string">theme</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#</span> <span class="string">add </span><span class="string">contents</span></span><br><span class="line"><span class="string">git </span><span class="string">add </span>.</span><br><span class="line"></span><br><span class="line"><span class="comment"># commit contents</span></span><br><span class="line"><span class="string">git </span><span class="string">commit </span>-m <span class="string">"Initial commit"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># push contents</span></span><br><span class="line"><span class="string">git </span><span class="string">push </span>-u <span class="string">origin </span><span class="string">master</span></span><br></pre></td></tr></table></figure><br><h2 id="서브모듈-추가하기"><a href="#서브모듈-추가하기" class="headerlink" title="서브모듈 추가하기"></a>서브모듈 추가하기</h2><p>테마 폴더를 hexo 프로젝트에 push 하기 전에 고려해야할 점이 있다. git안에 git이 있는 경우 서로의 독립성을 유지하면서 서로의 버전을 따로 관리 하기 위해서 서브모듈로 추가해서 관리하는 것이 필수이다.</p><p>서브모듈에 대한 자세한 설명은 아래의 블로그를 참고하기 바란다.</p><ul><li><a href="https://www.tuwlab.com/ece/26011" target="_blank" rel="noopener">서브모듈에 대해 이해하기</a></li></ul><p>그럼 서브모듈을 hexo 프로젝트에 추가해보자.</p><p>먼저 hexo 프로젝트로 이동을하고, hexo 프로젝트 안에 있는 themes 폴더에 테마를 서브모듈로 추가한다. 그 후에 제대로 변경이 되었는지 확인을 하고 변경된 내용을 push 하면 된다.</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># add theme repository in hexo theme folder as submodule</span></span><br><span class="line">git submodule add https:<span class="comment">//github.com/777bareman777/theme themes/aircloud</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># check status</span></span><br><span class="line">git status</span><br><span class="line">git submodule status</span><br><span class="line"></span><br><span class="line"><span class="meta"># add contents</span></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line"><span class="meta"># commit contents</span></span><br><span class="line">git commit -m <span class="string">"Initial commit"</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># push contents</span></span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><br><h2 id="마지막으로…"><a href="#마지막으로…" class="headerlink" title="마지막으로…"></a>마지막으로…</h2><p>이러한 작업을 거치면 github에서 hexo 프로젝트와 테마를 관리해주기 때문에 데이터가 날라가도 다시 복구를 할 수가 있다.</p><p>데이터가 날라갔을 떄, 복구하는 방법은 다음과 같다.</p><p>먼저 hexo 프로젝트를 불러온다. 그 후에 서브모듈을 초기화 시키고 업데이트 시켜서 서브모듈의 데이터들을 가져온다. 서브모듈은 또 다른 git으로 이루어져 있기 때문에 그 독립성과 버전 관리를 위해서 데이터를 포함하고 있지 않기 때문이다. 마지막으로 local hexo를 다시 설치해줘야 한다.</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">git</span> clone https://github.com/<span class="number">777</span>bareman777/<span class="keyword">blog</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">git </span><span class="keyword">submodule </span>init</span><br><span class="line"></span><br><span class="line"><span class="symbol">git</span> <span class="keyword">submodule </span>update</span><br><span class="line"></span><br><span class="line"><span class="symbol">npm</span> install hexo --save</span><br></pre></td></tr></table></figure><br><h2 id="진짜-마지막으로…"><a href="#진짜-마지막으로…" class="headerlink" title="진짜 마지막으로…"></a>진짜 마지막으로…</h2><p>변경된 사항을 github에 push를 하기 전에 Slave(submodule) 먼저 push를 한후 Master(iriginal git)을 push를 해야 한다.</p><p>Master -&gt; Slave의 순서로 commit을 하게 되면, 다시 한번 더 Master에서 변경사항이 있다는 것을 알게 된다.</p><p>이렇게 작동 하는 이유는 Slave가 Master를 바라볼 때 Abstraction되는 방식으로 관리하기 때문이다.</p><p>Slave에서 변경된 사항은 Master에서 commit 할 때, 파일들을 Tracking 하는 것이 아니라 Slave의 HEAD가 무엇으로 변경되었는지에 대한 정보만 기록하기 때문이다.</p><br><br><br><br><br><h2 id="이전-포스팅"><a href="#이전-포스팅" class="headerlink" title="이전 포스팅"></a>이전 포스팅</h2><hr><p><a href="../HowToCreateBlogUingHexo">Hexo 블로그 만들기 삽질 일기 - 1</a></p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 블로그 만들기 삽질 일지 - 1</title>
      <link href="/2019/09/12/HowToCreateBlogUingHexo/"/>
      <url>/2019/09/12/HowToCreateBlogUingHexo/</url>
      
        <content type="html"><![CDATA[<p>아는 형한테 github page와 hexo를 통해서 블로그를 만들 수 있다고 이야기를 들었다.<br>티스토리 보다는 간지나게 hexo로 블로그를 관리해보자라는 욕심으로 정보를 찾아봤다.<br>하지만 그 이야기를 들었으면 안됬다.</p><img src="/2019/09/12/HowToCreateBlogUingHexo/sibal.jpeg" title="오열"> <p>이제부터 시작이다 나의 hexo 삽질이 ….</p><br><h2 id="Git-Page로-정적-페이지-Hosting하기"><a href="#Git-Page로-정적-페이지-Hosting하기" class="headerlink" title="Git Page로 정적 페이지 Hosting하기"></a>Git Page로 정적 페이지 Hosting하기</h2><p>Git Page를 통해 USERNAME.github.io 도메인을 통해 정적 페이지를 호스팅할 수 있고, 자기 자신이 도메인을 가지고 있으면 커스텀 도메인할 수 있다. 이런거 필요 없다. 몰라도 좋다.</p><p>그냥 github에 들어가서 USERNAME.github.io를 생성하면 된다.<br>public 이든 private든 무엇이든 선택해도 좋다.</p><br><h2 id="Hexo-시작"><a href="#Hexo-시작" class="headerlink" title="Hexo 시작"></a>Hexo 시작</h2><p>자 이제 우리는 고통의 시간이 조금씩 다가왔다.<br>hexo를 사용하기 전에 필수적으로 설치해야 하는 것들이 있다.</p><ul><li><strong>Node.js</strong></li><li><strong>Git</strong></li></ul><p>위의 두가지만 설치를 하면 된다. 설치 되어 있으면 생략해도 씹가능이다.</p><br><h3 id="hexo-cli-설치-블로그-생성"><a href="#hexo-cli-설치-블로그-생성" class="headerlink" title="hexo cli 설치 + 블로그 생성"></a>hexo cli 설치 + 블로그 생성</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install </span>hexo-cli -g</span><br><span class="line">hexo init <span class="keyword">blog</span></span><br><span class="line"><span class="keyword">cd </span><span class="keyword">blog</span></span><br><span class="line"><span class="keyword">npm </span><span class="keyword">install</span></span><br></pre></td></tr></table></figure><br><h3 id="설정파일-바꾸기"><a href="#설정파일-바꾸기" class="headerlink" title="설정파일 바꾸기"></a>설정파일 바꾸기</h3><p>위와 같은 방식으로 Hexo 프로젝트를 만들 수 있는데, Hexo 프로젝트 안에 _config.yml 이라는 설정파일이 존재한다. 이 설정 파일을 가지고 블로그에 대한 설정을 할 수 있는데, 나중에 테마를 설정하게 되면 테마 폴더에 있는 _config.yml 도 건드려야 한다.<br>설정파일안에 주석도 달려있고, 공식 문서도 존재하고, 다른 블로그에서도 설명이 되있으니 생략한다.</p><p>-&gt; 이 부분이 좀 많이 짜증난다.</p><ul><li>공식 사이트 : <a href="https://hexo.io/docs/" target="_blank" rel="noopener">https://hexo.io/docs/</a></li></ul><p>하지만 그 설정 파일 중에서 필수적으로 바꿔야 하는 것이 있다.<br>블로그 URL을 바꾸는 부분과 Github 정보를 바꾸는 부분이다.</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># blod url</span></span><br><span class="line"><span class="symbol">url:</span> https:<span class="comment">//USERNAME.github.io</span></span><br><span class="line"><span class="symbol">root:</span> /</span><br><span class="line"><span class="symbol">permalink:</span> :year/:month/:day/:title/</span><br><span class="line"><span class="symbol">permalink_defaults:</span></span><br></pre></td></tr></table></figure><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># Deployment</span></span><br><span class="line"><span class="symbol">deploy:</span></span><br><span class="line"><span class="symbol">  type:</span> git</span><br><span class="line"><span class="symbol">  repo:</span> https:<span class="comment">//USERNAME@github.com/USERNAME/USERNAME.github.io</span></span><br><span class="line"><span class="symbol">  branch:</span> master</span><br></pre></td></tr></table></figure><p>위와 같이 자신의 github 아이디를 USERNAME에 넣어주기만 하면 배포를 할 수 있게된다.</p><br><h3 id="로컬에서-테스트하기"><a href="#로컬에서-테스트하기" class="headerlink" title="로컬에서 테스트하기"></a>로컬에서 테스트하기</h3><p>설정을 완료하면 아래의 명령어를 통해 로컬에서 서버를 구동할 수 있다.</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo <span class="keyword">server</span></span><br></pre></td></tr></table></figure><p>서버가 구동이 되면 브라우저에서 <a href="https://localhost:4000" target="_blank" rel="noopener">https://localhost:4000</a> 을 통해 hexo로 만든 블로그에 접속할 수 있다.</p><br><h2 id="Github에-배포하기"><a href="#Github에-배포하기" class="headerlink" title="Github에 배포하기"></a>Github에 배포하기</h2><p>로컬에서 정상적으로 블로그가 동작한다는 것을 확인 한후에 github을 통해 배포가 가능하다.</p><p>먼저 hexo 설정을 가지고 리소스를 생성하고 배포하면된다.</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo <span class="keyword">generate</span></span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure><p>생성과 배포를 동시에 할 수도 있다.</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo <span class="keyword">generate</span> --deploy</span><br></pre></td></tr></table></figure><p>하지만 배포를 하기 전에 hexo에서 github에 push 할 수 있도록 플러그인을 다운로드 받아야한다.</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm instgall hexo-deployer-git <span class="comment">--save</span></span><br></pre></td></tr></table></figure><p>플러그인을 받은 후에 _config.yml에 플러그인 설정을 해주기만 하면된다.</p><p>-&gt; 설정을 하지 않아도 동작하기는 한다.</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">plugins:</span></span><br><span class="line">    - hexo-deployer-git</span><br></pre></td></tr></table></figure><br><h2 id="기타-등등"><a href="#기타-등등" class="headerlink" title="기타 등등"></a>기타 등등</h2><p>포스팅을 하고, 이미지를 넣고, 하는 방법은 다른 블로그에도 많으니 다른 곳을 참고하길 바란다.<br>다음 글에서는 hexo 프로젝트를 백업하고, 테마를 설정하고, 테마를 백업하는 방법에 대해 설명하고자 한다.</p><p>hexo blog를 백업하는 부분에서 많은 시간이 소모가 된다. github을 자주 사용하지 않아서 이 부분에서 깊은 빡침을 느꼈다.</p><p>다음 포스팅에서 보자.</p><br><br><br><br><br><h2 id="다음-포스팅"><a href="#다음-포스팅" class="headerlink" title="다음 포스팅"></a>다음 포스팅</h2><hr><p><a href="../HowToCreateBlogUingHexo2">Hexo 블로그 만들기 삽질 일기 - 2</a></p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
