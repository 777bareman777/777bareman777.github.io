<!DOCTYPE html>





<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.4.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.4.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.4.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.4.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: 'Copy',
      copy_success: 'Copied',
      copy_failure: 'Copy failed'
    },
    sidebarPadding: 40
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="777bareman777 Blog">
<meta property="og:url" content="http://777bareman777.github.io/index.html">
<meta property="og:site_name" content="777bareman777 Blog">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="777bareman777 Blog">
  <link rel="canonical" href="http://777bareman777.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>777bareman777 Blog</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">
  <div class="container use-motion">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">777bareman777 Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">켄넬 교육받은 댕댕이</p>
      
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-about">
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>About</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>Tags</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-categories">
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>Categories</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>

  </li>
  </ul>

    

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <div id="posts" class="posts-expand">
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://777bareman777.github.io/2020/01/15/WindowsX64Hooking/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="777bareman777">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="777bareman777 Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2020/01/15/WindowsX64Hooking/" class="post-title-link" itemprop="url">WindowsX64Hooking</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2020-01-15 21:39:37" itemprop="dateCreated datePublished" datetime="2020-01-15T21:39:37+09:00">2020-01-15</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-01-16 17:36:38" itemprop="dateModified" datetime="2020-01-16T17:36:38+09:00">2020-01-16</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Windows-Reversing/" itemprop="url" rel="index"><span itemprop="name">Windows Reversing</span></a></span>

                
                
              
            </span>
          

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
        
      
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2020/01/15/WindowsX64Hooking/#comments" itemprop="discussionUrl"><span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/01/15/WindowsX64Hooking/" itemprop="commentCount"></span></a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Code Patch를 통해서 API 후킹을 할 떄, 32bit 환경에서는 JMP Instruction 중 “E9 XXXXXXXX”를 사용하면 됬었다. 하지만 64bit 환경에서는 32bit 환경보다 가상메모리 공간이 훨씬더 커지면서 “E9 XXXXXXXX”을 이용해서는 안정적으로 후킹을 할 수가 없게 되었다. (32bit 가상메모리공간 -&gt; 4GB, 64bit 가상메모리공간 -&gt; 16TB)</p>
<p>따라서 64bit 환경에서는 32bit 환경에서 했던 것처럼 Code Patch를 하지 못한다. 다른 방법을 사용을 해야 한다. 64bit 환경에서 후킹 할 수 있는 방법을 찾는대로 계속 꾸준히 업데이트를 할 계획이다. 하지만 찾은 방법들이 안정적인지는 잘 모르겠다.</p>
<h2 id="후킹-방법-목록"><a href="#후킹-방법-목록" class="headerlink" title="후킹 방법 목록"></a>후킹 방법 목록</h2><p>다음 항목들은 64bit에서 후킹할 수 있는 방법들이다.</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 첫번째 방법 -&gt; <span class="number">14</span> 바이트</span><br><span class="line"><span class="number">0x00007FFF</span> <span class="number">00000001</span> <span class="string">'FF 25 00000000'</span> <span class="keyword">JMP</span> <span class="built_in">QWORD</span> <span class="built_in">PTR</span> <span class="built_in">ds</span>:[7FFF00000007] # <span class="keyword">JMP</span> <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">RIP</span>+addr0]</span><br><span class="line"><span class="number">0x00007FFF</span> <span class="number">00000007</span> <span class="string">'XXXXXXXX XXXXXXXX'</span> # 후킹 함수 주소</span><br><span class="line"></span><br><span class="line"># 두번째 방법 -&gt; <span class="number">12</span> 바이트</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">rax</span>, address # <span class="string">"48 b8 000000 000000"</span></span><br><span class="line"><span class="keyword">jmp</span> <span class="built_in">rax</span>          # <span class="string">"ff e0"</span></span><br><span class="line"></span><br><span class="line"># 세번째 방법 -&gt; <span class="number">14</span> 바이트</span><br><span class="line"><span class="keyword">push</span> 4byte_low_address</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">dword</span> <span class="built_in">ptr</span>[<span class="built_in">rsp</span>+<span class="number">4</span>], 4byte_high_address</span><br><span class="line"><span class="keyword">ret</span></span><br><span class="line"></span><br><span class="line"># 네번째 방법 -&gt; ?? 추후 업데이트</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">rax</span>, address</span><br><span class="line"><span class="keyword">call</span> <span class="built_in">rax</span></span><br></pre></td></tr></table></figure>

<br>

<h3 id="1-JMP-Instruction-“FF-25”"><a href="#1-JMP-Instruction-“FF-25”" class="headerlink" title="1. JMP Instruction “FF 25”"></a>1. JMP Instruction “FF 25”</h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x00007FFF</span> <span class="number">00000001</span> <span class="string">'FF 25 00000000'</span> <span class="keyword">JMP</span> <span class="built_in">QWORD</span> <span class="built_in">PTR</span> <span class="built_in">ds</span>:[7FFF00000007] # <span class="keyword">JMP</span> <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">RIP</span>+addr0]</span><br><span class="line"><span class="number">0x00007FFF</span> <span class="number">00000007</span> <span class="string">'XXXXXXXX XXXXXXXX'</span> # 후킹 함수 주소</span><br></pre></td></tr></table></figure>

<p>JMP Instruction 중에서 <strong>“FF 25 XXXXXXXX”</strong>를 이용하는 방법이다. FF25로 시작하는 JMP 명령어는 레지스터 RIP + offset(XXXXXXXX)을 더한 주소로 이동한다. 이를 통해서 RIP+offset(XXXXXXXX) 주소에다가 후킹 함수 주소를 넣으면, 후킹 함수로 이동할 수 있는 기법이다.</p>
<br>

<h4 id="테스트-코드"><a href="#테스트-코드" class="headerlink" title="테스트 코드"></a>테스트 코드</h4><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">#include <span class="string">"Windows.h"</span></span><br><span class="line">#include <span class="string">"stdio.h"</span></span><br><span class="line"></span><br><span class="line">BYTE g_pOrgBytes[<span class="number">14</span>] = &#123; <span class="number">0</span>, &#125;;</span><br><span class="line"></span><br><span class="line">BOOL hook(LPCSTR szDllName, LPCSTR szFuncName, PROC pfnNew, PBYTE pOrgBytes)</span><br><span class="line">&#123;</span><br><span class="line">	FARPROC pfnOrg;</span><br><span class="line">	DWORD dwOldProtect;</span><br><span class="line">	BYTE pBuf1[<span class="number">6</span>] = &#123; <span class="number">0xFF</span>, <span class="number">0x25</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span> &#125;;</span><br><span class="line">	BYTE pBuf2[<span class="number">8</span>] = &#123; <span class="number">0</span>, &#125;;</span><br><span class="line">	PBYTE pByte;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 후킹 대상 API 주소를 구한다</span></span><br><span class="line">	pfnOrg = (FARPROC)GetProcAddress(GetModuleHandleA(szDllName), szFuncName);</span><br><span class="line">	pByte = (PBYTE)pfnOrg;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 만약 후킹되어 있다면 return FALSE</span></span><br><span class="line">	if (pByte[<span class="number">0</span>] == <span class="number">0xFF</span> &amp;&amp; pByte[<span class="number">1</span>] == <span class="number">0x25</span>)</span><br><span class="line">		return <span class="literal">FALSE</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 기존코드 14바이트 백업 및 후킹 함수 시작 주소 구하기</span></span><br><span class="line">	memcpy(pOrgBytes, pfnOrg, <span class="number">14</span>);</span><br><span class="line">	memcpy(pBuf2, &amp;pfnNew, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 14바이트 패치를 위하여 메모리에 Write 속성 추가</span></span><br><span class="line">	VirtualProtect((LPVOID)pfnOrg, <span class="number">14</span>, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Hook: 14바이트 패치</span></span><br><span class="line">	memcpy(pfnOrg, pBuf1, <span class="number">6</span>);</span><br><span class="line">	memcpy((LPVOID)((DWORD_PTR)pfnOrg + <span class="number">6</span>), pBuf2, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 메모리에 속성 복원</span></span><br><span class="line">	VirtualProtect((LPVOID)pfnOrg, <span class="number">14</span>, dwOldProtect, &amp;dwOldProtect);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOL unhook(LPCSTR szDllName, LPCSTR szFuncName, PBYTE pOrgBytes)</span><br><span class="line">&#123;</span><br><span class="line">	FARPROC pfnOrg;</span><br><span class="line">	DWORD dwOldProtect;</span><br><span class="line">	PBYTE pByte;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// API 주소를 구한다.</span></span><br><span class="line">	pfnOrg = GetProcAddress(GetModuleHandleA(szDllName), szFuncName);</span><br><span class="line">	pByte = (PBYTE)pfnOrg;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 만약 이미 언후킹되어 있다면 FALSE</span></span><br><span class="line">	if (pByte[<span class="number">0</span>] != <span class="number">0xFF</span> &amp;&amp; pByte[<span class="number">1</span>] != <span class="number">0x25</span>)</span><br><span class="line">		return <span class="literal">FALSE</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 기존 코드 14바이트를 덮어쓰기 위헤 메모리에 WRITE 속성 추가</span></span><br><span class="line">	VirtualProtect((LPVOID)pfnOrg, <span class="number">14</span>, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// unHook: 14바이트 패치</span></span><br><span class="line">	memcpy(pfnOrg, pOrgBytes, <span class="number">14</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 메모리 속성 복원</span></span><br><span class="line">	VirtualProtect((LPVOID)pfnOrg, <span class="number">14</span>, dwOldProtect, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line">	return <span class="literal">TRUE</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MyMessageBox(HWND hWnd, LPCTSTR lpText, LPCTSTR lpCaption, UINT uType)</span><br><span class="line">&#123;</span><br><span class="line">	unhook(<span class="string">"user32.dll"</span>, <span class="string">"MessageBoxA"</span>, g_pOrgBytes);</span><br><span class="line">	MessageBoxA(NULL, <span class="string">"Code Patch API Hooking"</span>, <span class="string">"Hook"</span>, MB_OK);</span><br><span class="line">	hook(<span class="string">"user32.dll"</span>, <span class="string">"MessageBoxA"</span>, (PROC)MyMessageBox, g_pOrgBytes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	HMODULE module = LoadLibraryA(<span class="string">"user32.dll"</span>);</span><br><span class="line"></span><br><span class="line">	hook(<span class="string">"user32.dll"</span>, <span class="string">"MessageBoxA"</span>, (PROC)MyMessageBox, g_pOrgBytes);</span><br><span class="line">	MessageBEoxA(NULL, <span class="string">"Hello, World!"</span>, <span class="string">"Earth"</span>, MB_OK);</span><br><span class="line">	unhook(<span class="string">"user32.dll"</span>, <span class="string">"MessageBoxA"</span>, g_pOrgBytes);</span><br><span class="line">	MessageBoxA(NULL, <span class="string">"Hello, World!"</span>, <span class="string">"Earth"</span>, MB_OK);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	FreeLibrary(module);</span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="2-mov-amp-jmp-instruction"><a href="#2-mov-amp-jmp-instruction" class="headerlink" title="2. mov &amp; jmp instruction"></a>2. mov &amp; jmp instruction</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov rax,<span class="built_in"> address </span># <span class="string">"48 b8 000000 000000"</span></span><br><span class="line">jmp rax          # <span class="string">"ff e0"</span></span><br></pre></td></tr></table></figure>

<p>64bit 값을 가질 수 있는 레지스터를 이용해서 레지스터에 후킹 함수 주소값을 집어넣고, JMP 명령어를 통해서 후킹 함수쪽으로 실행흐름을 바꾸는 방법이다.</p>
<p>어떤 레지스터를 사용할 것인지에 따라서 machine code는 달라질 수 있다. mov 명령어를 통해 immu64 값을 rax의 집어 넣는 machine code 는 “48 b8 XXXXXXXX XXXXXXXX” 이고, rax 레지스터 값으로 이동하는 JMP의 machine code는 “ff e0” 이다.</p>
<br>

<h4 id="테스트-코드-1"><a href="#테스트-코드-1" class="headerlink" title="테스트 코드"></a>테스트 코드</h4><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">#include <span class="string">"Windows.h"</span></span><br><span class="line">#include <span class="string">"stdio.h"</span></span><br><span class="line"></span><br><span class="line">BYTE g_pOrgBytes[<span class="number">12</span>] = &#123; <span class="number">0</span>, &#125;;</span><br><span class="line"></span><br><span class="line">BOOL hook(LPCSTR szDllName, LPCSTR szFuncName, PROC pfnNew, PBYTE pOrgBytes)</span><br><span class="line">&#123;</span><br><span class="line">	FARPROC pfnOrg;</span><br><span class="line">	DWORD dwOldProtect;</span><br><span class="line">	BYTE pBuf1[<span class="number">10</span>] = &#123; <span class="number">0x48</span>, <span class="number">0xb8</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span> &#125;;</span><br><span class="line">	BYTE pBuf2[<span class="number">2</span>] = &#123; <span class="number">0xff</span>, <span class="number">0xe0</span>&#125;;</span><br><span class="line">	PBYTE pByte;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 후킹 대상 API 주소를 구한다</span></span><br><span class="line">	GetModuleHandleA(szDllName);</span><br><span class="line">	pfnOrg = (FARPROC)GetProcAddress(GetModuleHandleA(szDllName), szFuncName);</span><br><span class="line">	pByte = (PBYTE)pfnOrg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 만약 후킹되어 있다면 return FALSE</span></span><br><span class="line">	if (pByte[<span class="number">0</span>] == <span class="number">0x48</span> &amp;&amp; pByte[<span class="number">1</span>] == <span class="number">0xb8</span>)</span><br><span class="line">		return <span class="literal">FALSE</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 기존코드 12바이트 백업 및 후킹 함수 시작 주소 구하기</span></span><br><span class="line">	memcpy(pOrgBytes, pfnOrg, <span class="number">12</span>);</span><br><span class="line">	memcpy(pBuf1+<span class="number">2</span>, &amp;pfnNew, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 12바이트 패치를 위하여 메모리에 Write 속성 추가</span></span><br><span class="line">	VirtualProtect((LPVOID)pfnOrg, <span class="number">12</span>, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Hook: 12바이트 패치</span></span><br><span class="line">	memcpy(pfnOrg, pBuf1, <span class="number">10</span>);</span><br><span class="line">	memcpy((LPVOID)((DWORD_PTR)pfnOrg + <span class="number">10</span>), pBuf2, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 메모리에 속성 복원</span></span><br><span class="line">	VirtualProtect((LPVOID)pfnOrg, <span class="number">12</span>, dwOldProtect, &amp;dwOldProtect);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOL unhook(LPCSTR szDllName, LPCSTR szFuncName, PBYTE pOrgBytes)</span><br><span class="line">&#123;</span><br><span class="line">	FARPROC pfnOrg;</span><br><span class="line">	DWORD dwOldProtect;</span><br><span class="line">	PBYTE pByte;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// API 주소를 구한다.</span></span><br><span class="line">	pfnOrg = GetProcAddress(GetModuleHandleA(szDllName), szFuncName);</span><br><span class="line">	pByte = (PBYTE)pfnOrg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 만약 이미 언후킹되어 있다면 FALSE</span></span><br><span class="line">	if (pByte[<span class="number">0</span>] != <span class="number">0x48</span> &amp;&amp; pByte[<span class="number">1</span>] != <span class="number">0xb8</span>)</span><br><span class="line">		return <span class="literal">FALSE</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 기존 코드 12바이트를 덮어쓰기 위헤 메모리에 WRITE 속성 추가</span></span><br><span class="line">	VirtualProtect((LPVOID)pfnOrg, <span class="number">12</span>, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// unHook: 12바이트 패치</span></span><br><span class="line">	memcpy(pfnOrg, pOrgBytes, <span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 메모리 속성 복원</span></span><br><span class="line">	VirtualProtect((LPVOID)pfnOrg, <span class="number">12</span>, dwOldProtect, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MyMessageBox(HWND hWnd, LPCTSTR lpText, LPCTSTR lpCaption, UINT uType)</span><br><span class="line">&#123;</span><br><span class="line">	unhook(<span class="string">"user32.dll"</span>, <span class="string">"MessageBoxA"</span>, g_pOrgBytes);</span><br><span class="line">	MessageBoxA(NULL, <span class="string">"Code Patch API Hooking"</span>, <span class="string">"Hook"</span>, MB_OK);</span><br><span class="line">	hook(<span class="string">"user32.dll"</span>, <span class="string">"MessageBoxA"</span>, (PROC)MyMessageBox, g_pOrgBytes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	HMODULE module = LoadLibraryA(<span class="string">"user32.dll"</span>);</span><br><span class="line"></span><br><span class="line">	hook(<span class="string">"user32.dll"</span>, <span class="string">"MessageBoxA"</span>, (PROC)MyMessageBox, g_pOrgBytes);</span><br><span class="line">	MessageBoxA(NULL, <span class="string">"Hello, World!"</span>, <span class="string">"Earth"</span>, MB_OK);</span><br><span class="line">	unhook(<span class="string">"user32.dll"</span>, <span class="string">"MessageBoxA"</span>, g_pOrgBytes);</span><br><span class="line">	MessageBoxA(NULL, <span class="string">"Hello, World!"</span>, <span class="string">"Earth"</span>, MB_OK);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	FreeLibrary(module);</span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="3-push-amp-mov-amp-ret-instruction"><a href="#3-push-amp-mov-amp-ret-instruction" class="headerlink" title="3. push &amp; mov &amp; ret instruction"></a>3. push &amp; mov &amp; ret instruction</h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">push</span> 4byte_low_address</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">dword</span> <span class="built_in">ptr</span>[<span class="built_in">rsp</span>+<span class="number">4</span>], 4byte_high_address</span><br><span class="line"><span class="keyword">ret</span></span><br></pre></td></tr></table></figure>

<p>64bit에서는 64bit 레지스터 값을 push할 수 있는 명령어는 있지만, immu64 값을 push 할수 있는 명령어가 없다. 따라서 스택에 후킹 함수를 주소를 집어 넣으러면 push 4byte_low_address를 넣고, mov dword ptr[rsp+4], 4byte_high_address를 통해서 rsp값에 후킹 함수 주소를 설정해야 한다. 그 이후 ret 명령어를 통해서 후킹 함수쪽으로 실행흐름을 바꾸는 기법이다.</p>
<br>

<h4 id="테스트-코드-2"><a href="#테스트-코드-2" class="headerlink" title="테스트 코드"></a>테스트 코드</h4><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">#include <span class="string">"Windows.h"</span></span><br><span class="line">#include <span class="string">"stdio.h"</span></span><br><span class="line"></span><br><span class="line">BYTE g_pOrgBytes[<span class="number">14</span>] = &#123; <span class="number">0</span>, &#125;;</span><br><span class="line"></span><br><span class="line">void hook(LPCSTR szDllName, LPCSTR szFuncName, PROC pfnNew, PBYTE pOrgBytes)</span><br><span class="line">&#123;</span><br><span class="line">	FARPROC pfnOrg;</span><br><span class="line">	DWORD dwOldProtect;</span><br><span class="line">	BYTE pBuf1[<span class="number">5</span>] = &#123; <span class="number">0x68</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>&#125;;</span><br><span class="line">	BYTE pBuf2[<span class="number">8</span>] = &#123; <span class="number">0xc7</span>, <span class="number">0x44</span>, <span class="number">0x24</span> ,<span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span> &#125;;</span><br><span class="line">	BYTE pBuf3[<span class="number">1</span>] = &#123; <span class="number">0xc3</span> &#125;;</span><br><span class="line">	<span class="comment">//PBYTE pByte;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 후킹 대상 API 주소를 구한다</span></span><br><span class="line">	GetModuleHandleA(szDllName);</span><br><span class="line">	pfnOrg = (FARPROC)GetProcAddress(GetModuleHandleA(szDllName), szFuncName);</span><br><span class="line">	<span class="comment">//pByte = (PBYTE)pfnOrg;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 기존코드 14바이트 백업 및 후킹 함수 시작 주소 구하기</span></span><br><span class="line">	memcpy(pOrgBytes, pfnOrg, <span class="number">14</span>);</span><br><span class="line">	memcpy(pBuf1 + <span class="number">1</span>, &amp;pfnNew, <span class="number">4</span>);</span><br><span class="line">	for (int i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">		pBuf2[i + <span class="number">4</span>] = (BYTE)((DWORD_PTR)pfnNew &gt;&gt; <span class="number">32</span> + i * <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 14바이트 패치를 위하여 메모리에 Write 속성 추가</span></span><br><span class="line">	VirtualProtect((LPVOID)pfnOrg, <span class="number">14</span>, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Hook: 14바이트 패치</span></span><br><span class="line">	memcpy(pfnOrg, pBuf1, <span class="number">5</span>);</span><br><span class="line">	memcpy((LPVOID)((DWORD_PTR)pfnOrg + <span class="number">5</span>), pBuf2, <span class="number">8</span>);</span><br><span class="line">	memcpy((LPVOID)((DWORD_PTR)pfnOrg + <span class="number">13</span>), pBuf3, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 메모리에 속성 복원</span></span><br><span class="line">	VirtualProtect((LPVOID)pfnOrg, <span class="number">14</span>, dwOldProtect, &amp;dwOldProtect);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void unhook(LPCSTR szDllName, LPCSTR szFuncName, PBYTE pOrgBytes)</span><br><span class="line">&#123;</span><br><span class="line">	FARPROC pfnOrg;</span><br><span class="line">	DWORD dwOldProtect;</span><br><span class="line">	PBYTE pByte;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// API 주소를 구한다.</span></span><br><span class="line">	pfnOrg = GetProcAddress(GetModuleHandleA(szDllName), szFuncName);</span><br><span class="line">	pByte = (PBYTE)pfnOrg;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 기존 코드 14바이트를 덮어쓰기 위헤 메모리에 WRITE 속성 추가</span></span><br><span class="line">	VirtualProtect((LPVOID)pfnOrg, <span class="number">14</span>, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// unHook: 14바이트 패치</span></span><br><span class="line">	memcpy(pfnOrg, pOrgBytes, <span class="number">14</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 메모리 속성 복원</span></span><br><span class="line">	VirtualProtect((LPVOID)pfnOrg, <span class="number">14</span>, dwOldProtect, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MyMessageBox(HWND hWnd, LPCTSTR lpText, LPCTSTR lpCaption, UINT uType)</span><br><span class="line">&#123;</span><br><span class="line">	unhook(<span class="string">"user32.dll"</span>, <span class="string">"MessageBoxA"</span>, g_pOrgBytes);</span><br><span class="line">	MessageBoxA(NULL, <span class="string">"Code Patch API Hooking"</span>, <span class="string">"Hook"</span>, MB_OK);</span><br><span class="line">	hook(<span class="string">"user32.dll"</span>, <span class="string">"MessageBoxA"</span>, (PROC)MyMessageBox, g_pOrgBytes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	HMODULE module = LoadLibraryA(<span class="string">"user32.dll"</span>);</span><br><span class="line"></span><br><span class="line">	hook(<span class="string">"user32.dll"</span>, <span class="string">"MessageBoxA"</span>, (PROC)MyMessageBox, g_pOrgBytes);</span><br><span class="line">	MessageBoxA(NULL, <span class="string">"Hello, World!"</span>, <span class="string">"Earth"</span>, MB_OK);</span><br><span class="line">	unhook(<span class="string">"user32.dll"</span>, <span class="string">"MessageBoxA"</span>, g_pOrgBytes);</span><br><span class="line">	MessageBoxA(NULL, <span class="string">"Hello, World!"</span>, <span class="string">"Earth"</span>, MB_OK);</span><br><span class="line"></span><br><span class="line">	FreeLibrary(module);</span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>


<h2 id="참고자료"><a href="#참고자료" class="headerlink" title="참고자료"></a>참고자료</h2><p><a href="https://www.felixcloutier.com/x86/call" target="_blank" rel="noopener">CALL - Call Procedure</a></p>
<p><a href="https://www.felixcloutier.com/x86/jmp" target="_blank" rel="noopener">JMP - Jump</a></p>
<p><a href="https://www.felixcloutier.com/x86/push" target="_blank" rel="noopener">PUSH instruction</a></p>
<p><a href="https://eram.tistory.com/entry/API-Hooking-x86?category=564239" target="_blank" rel="noopener">API Hooking x86 x64</a></p>
<p><a href="https://shhoya.github.io/2019/03/27/64bitHook.html" target="_blank" rel="noopener">x64 Hooking</a></p>
<p><a href="https://5kyc1ad.tistory.com/354" target="_blank" rel="noopener">x86, x64 API HOOKING</a></p>
<p><a href="https://www.sysnet.pe.kr/2/0/1231" target="_blank" rel="noopener">Win32 API 후킹 - Trampoline API Hooking</a></p>
<p><a href="https://ezbeat.tistory.com/453" target="_blank" rel="noopener">Windows x64 binary 모듈 단위 이동</a></p>
<p><a href="http://sandsprite.com/blogs/index.php?uid=7&pid=235" target="_blank" rel="noopener">x64 Hooks</a></p>
<p><a href="https://rayanfam.com/topics/assembly-challenge-jump-to-a-non-relative-address-without-using-registers/" target="_blank" rel="noopener">Assembly Challenge : Jump to a non-relative address without using registers</a></p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://777bareman777.github.io/2020/01/15/WindowsAPIHookingUsingCodePatch/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="777bareman777">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="777bareman777 Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2020/01/15/WindowsAPIHookingUsingCodePatch/" class="post-title-link" itemprop="url">Windows API Hooking - Code Patch</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2020-01-15 20:15:39" itemprop="dateCreated datePublished" datetime="2020-01-15T20:15:39+09:00">2020-01-15</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-01-16 17:51:13" itemprop="dateModified" datetime="2020-01-16T17:51:13+09:00">2020-01-16</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Windows-Reversing/" itemprop="url" rel="index"><span itemprop="name">Windows Reversing</span></a></span>

                
                
              
            </span>
          

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
        
      
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2020/01/15/WindowsAPIHookingUsingCodePatch/#comments" itemprop="discussionUrl"><span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/01/15/WindowsAPIHookingUsingCodePatch/" itemprop="commentCount"></span></a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>일명 나뭇잎 책이라고 불리는 리버싱 핵심 원리 책을 보면서, 배운 내용을 정리하는 포스팅입니다.</p>
<p>해당 포스팅에서는 API 후킹 방법중 하나인 코드 패치 내용 정리입니다.</p>
<br>

<h2 id="API-코드-패치"><a href="#API-코드-패치" class="headerlink" title="API 코드 패치"></a>API 코드 패치</h2><p>API 코드 패치 기법은 프로세스 메모리에 로딩된 라이브러리 이미지에서 후킹을 원하는 API 코드 자체를 수정하는 방법을 말합니다. 이 기법은 API 후킹에서 널리 사용된다고 하는데, 그 이유가 대부분의 API를 후킹할 수 있기 때문이라고 합니다.</p>
<p>하지만 후킹하려면 API의 코드의 길이가 최소 5바이트보다 커야 한다고 합니다. 하지만 대부분의 모든 API의 코드 크기는 5바이트보다 크기 때문에 사실상 제한이 없다고 보면 됩니다.</p>
<br>

<h2 id="API-코드-패치-동작-원리"><a href="#API-코드-패치-동작-원리" class="headerlink" title="API 코드 패치 동작 원리"></a>API 코드 패치 동작 원리</h2><p>IAT 후킹 방식이 프로세스의 특정 IAT 값을 조작해서 후킹하는 방식이라면, 코드 패치 방식은 실제 API 코드 시작 바이트가 JMP 명령어로 패치합니다. 후킹된 API가 호출되면 JMP 명령어가 실행되어 후킹 함수로 제어가 넘어오는 방식입니다.</p>
<p>이때, 사용되는 JMP 명령어의 Instruction을 살펴보면, “E9 XXXXXXXX” 형태라는 것을 알 수 있습니다. 해당 기법을 통해서는 32bit에서는 통하지만, 64bit에서는 통하지가 않습니다.</p>
<p>그 이유는 32bit에서는 가상메모리 공간이 4GB로서, 2GB는 커널 영역이 사용하고, 2GB는 유저 영역이 사용합니다. 이때, 32비트의 크기로는 2GB정도되는 영역을 왔다갔다 할 수 있습니다. 따라서 “E9 XXXXXXXX” 명령어로는 32bit에서는 충분히 사용을 할 수가 있습니다.</p>
<p>하지만 64bit에서는 가상메모리 공간이 일반적으로 16TB를 사용하고 있으며 최대 16EB 까지 사용이 가능합니다. 따라서 JMP 명령어의 Instruction “E9 XXXXXXXX” 으로는 커버를 할 수가 없습니다.</p>
<p>64bit에서는 이를 해결 하기 위해서 Instruction을 섞어서 사용하는 요령이 필요합니다. 해당 부분은 따로 포스팅 해서 업데이트를 할 예정입니다. 해당 부분은 <a href="../WindowsX64Hooking">x64 hooking - code patch</a> 에서 보시면 됩니다.</p>
<br>

<h2 id="분석"><a href="#분석" class="headerlink" title="분석"></a>분석</h2><p>기본적으로 DLL 인젝션을 통해 API 후킹을 하기 위해서는 DLL Injector는 필요합니다. 어떤 DLL Injector를 사용해도 상관없습니다. 여기서 사용한 DLL Injector는 나뭇잎 책에서 제공하는 것을 사용했습니다.</p>
<p>여기서 후킹할 API는 MessageBox 입니다.  MyMessageBox 를 만들어서 MeesageBox 후킹해서 MyMeesageBox로 실행흐름을 바꿔서 원하는 메시지 박스를 표시하도록 할 것입니다. </p>
<p>소스 코드를 보면서, 실습을 진행해봅시다.</p>
<br>

<h3 id="DllMain"><a href="#DllMain" class="headerlink" title="DllMain()"></a>DllMain()</h3><p>실행 파일에서 늘 작성하던 main() 함수처럼 DLL 파일에서도 마찬가지로 늘 작성해야하는 DllMain() 함수가 있습니다. DllMain() 함수에서 늘 시작한다고 보면 됩니다.</p>
<p>후킹 하고자 하는 함수는 ExitProcess 입니다. 모든 프로세스에서 종료할 때, 이 함수를 이용합니다. 프로그램 종료만으로도 후킹 성공 여부를 확실하게 알 수 있기 때문에 해당 API를 선택했습니다.</p>
<p>제가 제작한 후킹 함수는 MyExitProcess 입니다. 해당 함수에서는 후킹 되었다는 메시지 박스를 표시하고 ExitProcess API가 정상적으로 호출되도록 작성을 했습니다.</p>
<p>DllMain() 함수에서는 DLL이 인젝션이 되면, Code Patch 기법을 이용해서  API의 실행흐름을 MyExitProcess 로 바꿉니다. DLL이 이젝션되면 ExitProcess의 본래의 실행흐름으로 복원합니다.</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">switch</span> (fdwReason)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">DLL_PROCESS_ATTACH:</span></span><br><span class="line">		hook(<span class="string">"kernel32.dll"</span>, <span class="string">"ExitProcess"</span>, (PROC)MyExitProcess, g_pOrgBytes);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">DLL_PROCESS_DETACH:</span></span><br><span class="line">		unhook(<span class="string">"kernel32.dll"</span>, <span class="string">"ExitProcess"</span>, g_pOrgBytes);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>코드를 보시면, DLL이 로딩될 때, kernel32.dll에서 ExitProcess API를 후킹 한다는 것을 볼 수 있고, DLL이 언로딩될 때 본래의 실행흐름으로 바꾸는 것을 볼 수 있습니다.</p>
<br>

<h3 id="MyExitProcess-후킹-함수-구현"><a href="#MyExitProcess-후킹-함수-구현" class="headerlink" title="MyExitProcess 후킹 함수 구현"></a>MyExitProcess 후킹 함수 구현</h3><p>ExitProcess API를 대신 사용할 MyExitProcess 함수를 구현을 해야 합니다. 본래 ExitProcess API 대신 호출이 되는 것이기 때문에 함수 인자 같은 경우에는 동일하게 해줘야 합니다. 그래야지 MyExitProcess 함수를 호출하고 나서 정상적으로 ExitProcess API를 호출할 수 있습니다.</p>
<p>MyExitProcess 후킹 함수는 다음과 같습니다.</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">void</span> <span class="selector-tag">WINAPI</span> <span class="selector-tag">MyExitProcess</span>(UINT uExitCode)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="selector-tag">MessageBoxA</span>(NULL, <span class="string">"API hooking - code patch"</span>, <span class="string">"hook"</span>, MB_OK);</span><br><span class="line">	<span class="selector-tag">unhook</span>(<span class="string">"kernel32.dll"</span>, <span class="string">"ExitProcess"</span>, g_pOrgBytes);</span><br><span class="line">	<span class="selector-tag">ExitProcess</span>(uExitCode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="후킹-로직-구현"><a href="#후킹-로직-구현" class="headerlink" title="후킹 로직 구현"></a>후킹 로직 구현</h3><p>다음 부분은 코드 패치 기법을 이용하여 API를 후킹하는 hook() 함수입니다.</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">BOOL hook(LPCSTR szDllName, LPCSTR szFuncName, PROC pfnNew, PBYTE pOrgBytes)</span><br><span class="line">&#123;</span><br><span class="line">	FARPROC pfnOrg;</span><br><span class="line">	DWORD dwOldProtect, dwAddress;</span><br><span class="line">	BYTE pBuf[<span class="number">5</span>] = &#123; <span class="number">0xE9</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span> &#125;;</span><br><span class="line">	PBYTE pByte;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 후킹 대상 API 주소를 구한다</span></span><br><span class="line">	pfnOrg = (FARPROC)GetProcAddress(GetModuleHandleA(szDllName), szFuncName);</span><br><span class="line">	pByte = (PBYTE)pfnOrg;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 만약 이미 후킹되어 있다면 return FALSE</span></span><br><span class="line">	if (pByte[<span class="number">0</span>] == <span class="number">0xE9</span>)</span><br><span class="line">		return <span class="literal">FALSE</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 5바이트 패치를 위하여 메모리에 WRITE 속성 추가</span></span><br><span class="line">	VirtualProtect((LPVOID)pfnOrg, <span class="number">5</span>, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 원본코드(5바이트) 백업</span></span><br><span class="line">	memcpy(pOrgBytes, pfnOrg, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// JMP 주소 계산(E9 XXXXXXXX)</span></span><br><span class="line">	<span class="comment">// XXXXXXXX = (DWORD)pfnNew - (DWORD)pfnOrg - 5;</span></span><br><span class="line">	dwAddress = (DWORD)pfnNew - (DWORD)pfnOrg - <span class="number">5</span>;</span><br><span class="line">	memcpy(&amp;pBuf[<span class="number">1</span>], &amp;dwAddress, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Hook: 5바이트 패치(JMP XXXXXXXX)</span></span><br><span class="line">	memcpy(pfnOrg, pBuf, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 메모리 속성 복원</span></span><br><span class="line">	VirtualProtect((LPVOID)pfnOrg, <span class="number">5</span>, dwOldProtect, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line">	return <span class="literal">TRUE</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>hook() 함수의 기능은 원본 코드 시작부분의 5바이트를 “JMP XXXXXXXX”명령어로 변경시켜서 코드의 실행 흐름을 바꿔서 후킹하는 것입니다. 후킹은 다음의 순서로 동작이 됩니다.</p>
<ul>
<li><p>후킹 대상 API 주소(ExitProcess)를 구한다. </p>
</li>
<li><p>만약 이미 후킹이되었다면, 후킹을 하지 않는다. </p>
</li>
<li><p>후킹 대상 API 메모리에 5바이트 패치를 위하여 메모리에 WRITE 속성을 추가한다.</p>
</li>
<li><p>언훅을 할 때, 원본 코드를 복원하기 위해서 5바이트를 백업한다.</p>
</li>
<li><p>JMP 주소를 계산한다.</p>
</li>
<li><p>후킹 대상 API 메모리에 5바이트 패치를 한다.(JMP XXXXXXXX)</p>
</li>
<li><p>메모리 속성을 원래대로 복원한다.</p>
</li>
</ul>
<br>

<p>여기서 중요한 부분은 JMP 명령어에 사용할 상대 주소 값을 어떻게 구하는 것 입니다. 점프할 위치 까지의 상대 거리 주소 값은 다음같은 방식으로 구할 수 있습니다.</p>
<blockquote>
<p>XXXXXXXX = 다음 명령어 주소 - 현재 명령어 주소 - 현재 명령어 길이</p>
</blockquote>
<p>여기서 명령어의 길이를 빼주는 이유는 CPU가 명령어 주소를 계산할 떄 다음같은 방식으로 구하기 때문입니다.</p>
<blockquote>
<p>다음 명령어주소(IP) = 현재 명령어주소(IP) + relative_offset + 현재 명령어 길이</p>
</blockquote>
<p>따라서 점프할 위치 까지의 상대 거리 주소 값을 구하기 위해서는 다음 명령어 주소 값에서 현재 명령어 주소 값을 뺴주고 현재 명령어 길이(5바이트)를 빼줘야합니다.</p>
<p>이러한 방식 말고도 절대주소로도 점프할 수 있습니다. (ex. “PUSH+RET”, “MOV+JMP”) 하지만 이러한 방식을 이용할 경우 명령어 길이가 늘어납니다. 64비트에서는 상대 거리 주소값을 이용해서 점프할 수 없기 때문에 어쩔 수 없이 절대주소로 점프하는 기법을 이용합니다.</p>
<br>

<h3 id="언훅-동작-원리"><a href="#언훅-동작-원리" class="headerlink" title="언훅 동작 원리"></a>언훅 동작 원리</h3><p>다음 부분은 언훅을 하는 unhook() 함수입니다. 해당 함수에서는 원래 코드의 5바이트를 복원하는 것입니다. 아까전에 원본 코드의 5바이트를 저장한 것을 이용해서 후킹 대상 API의 주소에서 패치한 5바이트를 복원을 하면 됩니다.</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">BOOL unhook(LPCSTR szDllName, LPCSTR szFuncName, PBYTE pOrgBytes)</span><br><span class="line">&#123;</span><br><span class="line">	FARPROC pFunc;</span><br><span class="line">	DWORD dwOldProtect;</span><br><span class="line">	PBYTE pByte;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// API 주소를 구한다 </span></span><br><span class="line">	pFunc = GetProcAddress(GetModuleHandleA(szDllName), szFuncName);</span><br><span class="line">	pByte = (PBYTE)pFunc;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 만약 이미 언후킹 되어있다면 return FALSE</span></span><br><span class="line">	if (pByte[<span class="number">0</span>] != <span class="number">0xE9</span>)</span><br><span class="line">		return <span class="literal">FALSE</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 원래 코드(5바이트) 패치를 하기 위해서 메모리에 Write 속성 추가</span></span><br><span class="line">	VirtualProtect((LPVOID)pFunc, <span class="number">5</span>, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// unhook</span></span><br><span class="line">	memcpy(pFunc, g_pOrgBytes, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 메모리 속성 복원</span></span><br><span class="line">	VirtualProtect((LPVOID)pFunc, <span class="number">5</span>, dwOldProtect, &amp;dwOldProtect);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="실행"><a href="#실행" class="headerlink" title="실행"></a>실행</h3><img src="/2020/01/15/WindowsAPIHookingUsingCodePatch/1.png" title="후킹">

<br>

<h3 id="전체-소스-코드"><a href="#전체-소스-코드" class="headerlink" title="전체 소스 코드"></a>전체 소스 코드</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Windows.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"></span><br><span class="line">BYTE g_pOrgBytes[<span class="number">5</span>] = &#123; <span class="number">0</span>, &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">hook</span><span class="params">(LPCSTR szDllName, LPCSTR szFuncName, PROC pfnNew, PBYTE pOrgBytes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	FARPROC pfnOrg;</span><br><span class="line">	DWORD dwOldProtect, dwAddress;</span><br><span class="line">	BYTE pBuf[<span class="number">5</span>] = &#123; <span class="number">0xE9</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span> &#125;;</span><br><span class="line">	PBYTE pByte;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 후킹 대상 API 주소를 구한다</span></span><br><span class="line">	pfnOrg = (FARPROC)GetProcAddress(GetModuleHandleA(szDllName), szFuncName);</span><br><span class="line">	pByte = (PBYTE)pfnOrg;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 만약 이미 후킹되어 있다면 return FALSE</span></span><br><span class="line">	<span class="keyword">if</span> (pByte[<span class="number">0</span>] == <span class="number">0xE9</span>)</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 5바이트 패치를 위하여 메모리에 WRITE 속성 추가</span></span><br><span class="line">	VirtualProtect((LPVOID)pfnOrg, <span class="number">5</span>, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 원본코드(5바이트) 백업</span></span><br><span class="line">	<span class="built_in">memcpy</span>(pOrgBytes, pfnOrg, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// JMP 주소 계산(E9 XXXXXXXX)</span></span><br><span class="line">	<span class="comment">// XXXXXXXX = (DWORD)pfnNew - (DWORD)pfnOrg - 5;</span></span><br><span class="line">	dwAddress = (DWORD)pfnNew - (DWORD)pfnOrg - <span class="number">5</span>;</span><br><span class="line">	<span class="built_in">memcpy</span>(&amp;pBuf[<span class="number">1</span>], &amp;dwAddress, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Hook: 5바이트 패치(JMP XXXXXXXX)</span></span><br><span class="line">	<span class="built_in">memcpy</span>(pfnOrg, pBuf, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 메모리 속성 복원</span></span><br><span class="line">	VirtualProtect((LPVOID)pfnOrg, <span class="number">5</span>, dwOldProtect, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">unhook</span><span class="params">(LPCSTR szDllName, LPCSTR szFuncName, PBYTE pOrgBytes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	FARPROC pFunc;</span><br><span class="line">	DWORD dwOldProtect;</span><br><span class="line">	PBYTE pByte;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// API 주소를 구한다 </span></span><br><span class="line">	pFunc = GetProcAddress(GetModuleHandleA(szDllName), szFuncName);</span><br><span class="line">	pByte = (PBYTE)pFunc;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 만약 이미 언후킹 되어있다면 return FALSE</span></span><br><span class="line">	<span class="keyword">if</span> (pByte[<span class="number">0</span>] != <span class="number">0xE9</span>)</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 원래 코드(5바이트) 패치를 하기 위해서 메모리에 Write 속성 추가</span></span><br><span class="line">	VirtualProtect((LPVOID)pFunc, <span class="number">5</span>, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// unhook</span></span><br><span class="line">	<span class="built_in">memcpy</span>(pFunc, g_pOrgBytes, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 메모리 속성 복원</span></span><br><span class="line">	VirtualProtect((LPVOID)pFunc, <span class="number">5</span>, dwOldProtect, &amp;dwOldProtect);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> WINAPI <span class="title">MyExitProcess</span><span class="params">(UINT uExitCode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MessageBoxA(<span class="literal">NULL</span>, <span class="string">"API hooking - code patch"</span>, <span class="string">"hook"</span>, MB_OK);</span><br><span class="line">	unhook(<span class="string">"kernel32.dll"</span>, <span class="string">"ExitProcess"</span>, g_pOrgBytes);</span><br><span class="line">	ExitProcess(uExitCode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL WINAPI <span class="title">DllMain</span><span class="params">(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">switch</span> (fdwReason)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">		hook(<span class="string">"kernel32.dll"</span>, <span class="string">"ExitProcess"</span>, (PROC)MyExitProcess, g_pOrgBytes);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">		unhook(<span class="string">"kernel32.dll"</span>, <span class="string">"ExitProcess"</span>, g_pOrgBytes);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="참고자료"><a href="#참고자료" class="headerlink" title="참고자료"></a>참고자료</h2><p><a href="https://www.felixcloutier.com/x86/call" target="_blank" rel="noopener">CALL - Call Procedure</a></p>
<p><a href="https://www.felixcloutier.com/x86/jmp" target="_blank" rel="noopener">JMP - Jump</a></p>
<p><a href="https://eram.tistory.com/entry/API-Hooking-x86?category=564239" target="_blank" rel="noopener">API Hooking x86 x64</a></p>
<p><a href="https://shhoya.github.io/2019/03/27/64bitHook.html" target="_blank" rel="noopener">x64 Hooking</a></p>
<p><a href="https://5kyc1ad.tistory.com/354" target="_blank" rel="noopener">x86, x64 API HOOKING</a></p>
<p><a href="https://www.sysnet.pe.kr/2/0/1231" target="_blank" rel="noopener">Win32 API 후킹 - Trampoline API Hooking</a></p>
<p><a href="https://ezbeat.tistory.com/453" target="_blank" rel="noopener">Windows x64 binary 모듈 단위 이동</a></p>
<p><a href="http://sandsprite.com/blogs/index.php?uid=7&pid=235" target="_blank" rel="noopener">x64 Hooks</a></p>
<p><a href="https://rayanfam.com/topics/assembly-challenge-jump-to-a-non-relative-address-without-using-registers/" target="_blank" rel="noopener">Assembly Challenge : Jump to a non-relative address without using registers</a></p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://777bareman777.github.io/2020/01/15/DifferenceBetweenFarCallandNearCAll/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="777bareman777">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="777bareman777 Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2020/01/15/DifferenceBetweenFarCallandNearCAll/" class="post-title-link" itemprop="url">DifferenceBetweenFarCallandNearCAll</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2020-01-15 12:55:19 / Modified: 17:21:06" itemprop="dateCreated datePublished" datetime="2020-01-15T12:55:19+09:00">2020-01-15</time>
            </span>
          
            

            
          

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
        
      
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2020/01/15/DifferenceBetweenFarCallandNearCAll/#comments" itemprop="discussionUrl"><span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/01/15/DifferenceBetweenFarCallandNearCAll/" itemprop="commentCount"></span></a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="FAR-CALL-NEAR-CALL"><a href="#FAR-CALL-NEAR-CALL" class="headerlink" title="FAR CALL, NEAR CALL ??"></a>FAR CALL, NEAR CALL ??</h1><p>프로그래밍에서 CALL 이란 서브루틴 또는 서브 프로그램에 프로그램의 실행을 넘기는 것 또는 그 조작을 위해서 사용되는 명령어로서 생각을 하면 됩니다.</p>
<p>세그먼트 영역이 생겨나면서, 코드, 데이터등을 분리시켜서, 샌드박스화를 시켰을 때, 현재 세그먼트 영역을 벗어난 JUMP, CALL 명령어를 하기 위해서 생겨난 개념이라고 합니다.</p>
<p>여기서 세그먼트란 프로그램이나 메모리의 부분을 말하며, 프로그램의 경우는 주기억에 탑재하는 단위를 세그먼트라고 생각하시면 됩니다. 메모리의 경우는 하나의 주소 레지스터로 지정되는 메모리 영역을 말합니다.</p>
<p><strong>세그먼트 외부의 세그먼트를 호출할 때는 FAR CALL</strong>을 사용하고, <strong>세그먼트 내부에서 호출 할 때는 NEAR CALL</strong>을 사용합니다.</p>
<h2 id="FAR-CALL-과-NEAR-CALL의-차이점"><a href="#FAR-CALL-과-NEAR-CALL의-차이점" class="headerlink" title="FAR CALL 과 NEAR CALL의 차이점"></a>FAR CALL 과 NEAR CALL의 차이점</h2><p>FAR CALL 과 NEAR CALL의 차이점은 CS(Code Segment Register)의 저장여부에 있습니다.</p>
<p>예를 들어, Kernel 구현시 CALL 0x0900:offset으로 넘기면, CS에 0x0900이 들어가게 됩니다. 그리고 CS에 들어간 주소가 복귀 주소가 되는데, 이 경우 FAR CALL을 뜻합니다. 반대로 CALL 0x0900 으로 하면 NEAR CALL을 뜻합니다.</p>
<p>즉, <strong>FAR CALL은 Stack에 CS:IP 값을 저장하고 지정된 곳으로 분기하는 상대 주소 지정 방식(Relative Address Mode)</strong> 입니다.</p>
<p>그리고 <strong>NEAR CALL은 Stack에 IP 값을 저장하고 지정된 곳으로 분기하는 간접 주소 지정 방식(Indirect Address Mode)</strong> 입니다.</p>
<br>

<h3 id="참고문헌"><a href="#참고문헌" class="headerlink" title="참고문헌"></a>참고문헌</h3><p>본 내용은 새한CLL아카데미(<a href="http://shcll.wo.to)에서" target="_blank" rel="noopener">http://shcll.wo.to)에서</a> 발췌했음을 알립니다.<br>[출처] Far Call, Near call 완전정복 (전자계산기 기사/산업기사) |작성자 ddaroapt</p>
<p><a href="https://m.blog.naver.com/PostView.nhn?blogId=eom913&amp;logNo=113939652&amp;proxyReferer=https%3A%2F%2Fwww.google.com%2F" target="_blank" rel="noopener">https://m.blog.naver.com/PostView.nhn?blogId=eom913&amp;logNo=113939652&amp;proxyReferer=https%3A%2F%2Fwww.google.com%2F</a></p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://777bareman777.github.io/2020/01/14/WindowsAPIHookingUsingIAT/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="777bareman777">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="777bareman777 Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2020/01/14/WindowsAPIHookingUsingIAT/" class="post-title-link" itemprop="url">Windows API Hooking - IAT hooking</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2020-01-14 16:13:13" itemprop="dateCreated datePublished" datetime="2020-01-14T16:13:13+09:00">2020-01-14</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-01-16 17:35:52" itemprop="dateModified" datetime="2020-01-16T17:35:52+09:00">2020-01-16</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Windows-Reversing/" itemprop="url" rel="index"><span itemprop="name">Windows Reversing</span></a></span>

                
                
              
            </span>
          

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
        
      
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2020/01/14/WindowsAPIHookingUsingIAT/#comments" itemprop="discussionUrl"><span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/01/14/WindowsAPIHookingUsingIAT/" itemprop="commentCount"></span></a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>일명 나뭇잎 책이라고 불리는 리버싱 핵심 원리 책을 보면서, 배운 내용을 정리하는 포스팅입니다.</p>
<p>해당 포스팅에서는 API 후킹중 IAT 후킹에 대한 내용 정리입니다.</p>
<br>

<h2 id="IAT-Hooking"><a href="#IAT-Hooking" class="headerlink" title="IAT Hooking"></a>IAT Hooking</h2><p>이번 포스팅에서는 DLL 인젝션을 이용해서 IAT를 후킹해서 프로세스에서 호출되는 특정 API의 기능을 변경을 해보는 것을 할 것입니다.</p>
<p>API 후킹중에서 IAT 후킹 기법은 동작 원리와 비교적 구현이 간단한 것이 특징이라고 합니다. 단순히 후킹 하고 싶은 API를 사용자 DLL에 재정의하고 프로세스에 인젝션하면 끝입니다. 하지만, IAT에 실제 함수의 주소를 조작해서 함수 실행 흐름을 바꾸는 것이니 후킹을 원하는 API 대상 프로세스의 IAT에 존재하지 않다면 사용할 수 없습니다. 즉, 동적으로 DLL을 로딩해서 사용하는 API의 경우에는 해당 방법으로는 후킹을 할 수가 없다는 것입니다.</p>
<br>

<h3 id="후킹-API-선정"><a href="#후킹-API-선정" class="headerlink" title="후킹 API 선정"></a>후킹 API 선정</h3><p>어떤 작업을 할건지에 따라서 후킹 대상 API를 선정을 해야 합니다. 하지만 이것은 만만치 않은 작업입니다. 내가 조작하고 싶은 부분이 어떤 API를 통해서 작동되는지, 어떤 알고리즘을 통해서 작동되는지 파악하기 어렵기 때문입니다. 해당 부분은 개발/리버싱 경험이 많아야지 쉽게 선택할 수 있습니다.</p>
<br>

<h3 id="IAT-후킹-동작-원리"><a href="#IAT-후킹-동작-원리" class="headerlink" title="IAT 후킹 동작 원리"></a>IAT 후킹 동작 원리</h3><p>IAT는 PE 파일을 공부했으면 알다시피 프로그램에서 호출되는 API들의 실제 주소가 저장이 되는 영역입니다. IAT 후킹이란 IAT에 저장된 API들의 실제 주소 값을 주소를 바꾸는 것입니다.</p>
<p>정상적인 프로그램 같은 경우에는 본래 호출하고자 했던 API를 호출하고, 함수 실행이 완료되면 돌아오는 것이 일반적입니다. 하지만 IAT 후킹을 당한 프로세스 같은 경우에는 본래 호출하고자 했던 API의 주소가 바뀌었기 때문에 후킹 API가 먼저 호출되고, 작업에 따라서 본래 API의 기능을 무시하고 새로운 기능을 만들 수 있고, 값을 조작할 수 있고, 여러가지 일을 할 수 있게 됩니다.</p>
<p>정리하자면, 타겟 프로세스에 후킹 DLL을 인젝션하고 타켓 프로세스의 IAT영역에서 API의 실제 주소 크기만큼만 변경하면 API 후킹을 할 수 있다는 말입니다.</p>


<br>

<h2 id="분석"><a href="#분석" class="headerlink" title="분석"></a>분석</h2><p>기본적으로 DLL 인젝션을 통해 API 후킹을 하기 위해서는 DLL Injector는 필요합니다. 어떤 DLL Injector를 사용해도 상관없습니다. 여기서 사용한 DLL Injector는 나뭇잎 책에서 제공하는 것을 사용했습니다.</p>
<p>여기서 후킹할 API는 ExitProcess 입니다. ExitProcess API 같은 경우에는 프로그램이 종료될 때 호출되는 API 인데, 대부분의 프로그램이 종료될 때 해당 함수를 호출합니다.</p>
<p>API 후킹을 통해서 MyExitProcess API를 만들고, 메시지 박스를 표시한 다음에 본래의 ExitProcess API를 호출하도록 실습을 할 것입니다.</p>
<p>소스 코드를 보면서, 실습을 진행해봅시다.</p>
<br>

<h3 id="DllMain"><a href="#DllMain" class="headerlink" title="DllMain()"></a>DllMain()</h3><p>실행 파일에서 늘 작성하던 main() 함수처럼 DLL 파일에서도 마찬가지로 늘 작성해야하는 DllMain() 함수가 있습니다. DllMain() 함수에서 늘 시작한다고 보면 됩니다. DllMain() 함수에서는 다음과 같은 작업을 합니다.</p>
<p>DllMain() 함수에서는 DLL이 인젝션이 되면, original API를 어딘가에 저장을 하고 IAT 후킹을 통해서 Hooking API의 주소로 대체합니다. DLL이 이젝션 되면 original API의 주소를 가지고 와서 본래의 IAT로 백업을 합니다.</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">switch</span> (fdwReason)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">DLL_PROCESS_ATTACH:</span></span><br><span class="line">		<span class="comment">// original API 주소 저장</span></span><br><span class="line">		g_pOrgFunc = GetProcAddress(GetModuleHandleA(<span class="string">"kernel32.dll"</span>), <span class="string">"ExitProcess"</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// ntdll!RtlExitUserProcess() 를 hook!hooking() 로 후킹</span></span><br><span class="line">		hook_iat(<span class="string">"kernel32.dll"</span>, g_pOrgFunc, (PROC)MyExitProcess);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">case</span> <span class="string">DLL_PROCESS_DETACH:</span></span><br><span class="line">		<span class="comment">// IAT를 원래 대로 복원</span></span><br><span class="line">		hook_iat(<span class="string">"kernel32.dll"</span>, (PROC)MyExitProcess, g_pOrgFunc);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>코드를 보시면, DLL이 로딩될 때, kernel32.dll에서 ExitProcess API의 주소를 가지고 와서 저장을 하고, hook_iat() 함수를 호출을 통해서 ExitProcess API를 후킹하는 것을 알 수 있습니다. 그리고 DLL이 언로딩될 때, IAT를 원래 대로 복원하는 것을 볼 수 있습니다.</p>
<br>

<h3 id="MyExitProcess-후킹-함수-구현"><a href="#MyExitProcess-후킹-함수-구현" class="headerlink" title="MyExitProcess 후킹 함수 구현"></a>MyExitProcess 후킹 함수 구현</h3><p>ExitProcess API를 대신 사용할 MyExitProcess 함수를 구현을 해야 합니다. 본래 ExitProcess API 대신 호출이 되는 것이기 때문에 함수 인자 같은 경우에는 동일하게 해줘야 합니다. 그래야지 MyExitProcess 함수를 호출하고 나서 정상적으로 ExitProcess API를 호출할 수 있습니다.</p>
<p>ExitProcess API는 원래 리턴 타입이 void 타입이지만 직접 만든 MyExitProcess 함수는 ExitProcess API를 호출 할 수 있도록 하기 위해서 BOOL 타입으로 만들었습니다.</p>
<p>MyExitProcess 후킹 함수는 다음과 같습니다.</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">BOOL</span> <span class="selector-tag">WINAPI</span> <span class="selector-tag">MyExitProcess</span>(UINT uExitCode)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="selector-tag">MessageBoxA</span>(NULL, <span class="string">"IAT hooking"</span>, <span class="string">"hook"</span>, MB_OK);</span><br><span class="line">	<span class="selector-tag">return</span> ((PFEXITPROCESS)g_pOrgFunc)(uExitCode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="후킹-로직-구현"><a href="#후킹-로직-구현" class="headerlink" title="후킹 로직 구현"></a>후킹 로직 구현</h3><p>hook_iat() 함수는 실질적인 후킹 로직이 담겨 있습니다. 해당 함수에서 실질적으로 ExitProcess API를 후킹을 합니다.</p>
<p>구현하고자 하는 API 후킹 기법은 IAT를 이용해서 후킹을 하는 것이기 때문에 메모리에 매핑된 IAT의 주소를 알아야 합니다. 구하는 방법은 다음과 같습니다.</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">hMod = GetModuleHandle(<span class="name">NULL</span>)<span class="comment">;			// hMod = ImageBase</span></span><br><span class="line">pAddr = (<span class="name">PBYTE</span>)hMod<span class="comment">;					// pAddr = ImageBase</span></span><br><span class="line">pAddr += *((<span class="name">DWORD*</span>)<span class="symbol">&amp;pAddr</span>[<span class="number">0</span>x3C])<span class="comment">;		// pAddr = "PE" Signature</span></span><br><span class="line">#ifdef _WIN32</span><br><span class="line">	#ifdef _WIN64</span><br><span class="line">	dwRVA = *((<span class="name">DWORD*</span>)<span class="symbol">&amp;pAddr</span>[<span class="number">0</span>x90])<span class="comment">;		// dwRVA = RVA of IMAGE_IMPORT_DESCRIPTOR -&gt; 64bit</span></span><br><span class="line">	#else</span><br><span class="line">	dwRVA = *((<span class="name">DWORD*</span>)<span class="symbol">&amp;pAddr</span>[<span class="number">0</span>x80])<span class="comment">;		// dwRVA = RVA of IMAGE_IMPORT_DESCRIPTOR -&gt; 32bit</span></span><br><span class="line">	#endif</span><br><span class="line">#endif</span><br><span class="line">pImportDesc = (<span class="name">PIMAGE_IMPORT_DESCRIPTOR</span>)((<span class="name">DWORD_PTR</span>)hMod + dwRVA)<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>먼저, GetModuleHandle API를 통해서 프로세스의 Image base address를 구하고, IMAGE_DOS_HEADER 구조체의 e_lfanew 멤버를 통해서 IMAGE_NT_HEADER 구조체를 구합니다. 그다음으로 IMAGE_IMPORT_DESCRIPTOR의 RVA를 구하기 위해서 해당 위치에서 32bit 기준 0x80, 64bit 기준 0x90 만큼 offset값을 계산해서 IMAGE_IMPORT_DESCRIPTOR의 RVA를 구한 다음에 Image base Address + RVA 를 더해서 IMAGE_IMPORT_DESCRIPTOR 구조체 배열의 주소를 찾습니다.</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">for (<span class="comment">; pImportDesc-&gt;Name; pImportDesc++)</span></span><br><span class="line">&#123;</span><br><span class="line">szLibName = (<span class="name">LPCSTR</span>)((<span class="name">DWORD_PTR</span>)hMod + (<span class="name">DWORD</span>)pImportDesc-&gt;Name)<span class="comment">;</span></span><br><span class="line">		</span><br><span class="line">	if (!_stricmp(<span class="name">szLibName</span>, szDllName))</span><br><span class="line">	&#123;</span><br><span class="line">		pThunk = (<span class="name">PIMAGE_THUNK_DATA</span>)((<span class="name">DWORD_PTR</span>)hMod + (<span class="name">DWORD</span>)pImportDesc-&gt;FirstThunk)<span class="comment">;</span></span><br><span class="line">		for (<span class="comment">; pThunk-&gt;u1.Function; pThunk++)</span></span><br><span class="line">		&#123;</span><br><span class="line">			if (<span class="name">pThunk-&gt;u1</span>.Function == (<span class="name">DWORD_PTR</span>)pfnOrg)</span><br><span class="line">			&#123;</span><br><span class="line">				VirtualProtect((<span class="name">LPVOID</span>)<span class="symbol">&amp;pThunk-&gt;u1</span>.Function, <span class="number">8</span>, PAGE_EXECUTE_READWRITE, <span class="symbol">&amp;dwOldProtect</span>)<span class="comment">;</span></span><br><span class="line">				pThunk-&gt;u1.Function = (<span class="name">DWORD_PTR</span>)pfnNew<span class="comment">;</span></span><br><span class="line">				VirtualProtect((<span class="name">LPVOID</span>)<span class="symbol">&amp;pThunk-&gt;u1</span>.Function, <span class="number">8</span>, dwOldProtect, <span class="symbol">&amp;dwOldProtect</span>)<span class="comment">;</span></span><br><span class="line">					</span><br><span class="line">				return TRUE<span class="comment">;</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IMAGE_IMPORT_DESCRIPTOR 구조체 배열의 주소 까지 찾으면 다 한거나 마찬가지입니다. 다음으로, 내가 후킹하고 싶은 API가 들어있는 DLL 이름을 찾아내고, pImportDesc-&gt;FirstThunk를 이용해서 IAT의 RVA 값을 찾아내서 IAT의 주소를 구하고, 후킹하고 싶은 ExitProcess API의 주소를 찾아 낸다음 후킹을 하면 됩니다.</p>
<p>이때, VirtualProtect API를 사용하는 이유는 일반적으로 IAT는 쓰기 권한이 없기 때문에 IAT의 값을 변조를 할수가 없습니다. 그래서 해당 API를 이용하면 일시적으로 쓰기 권한이 생기기 떄문에 IAT 영역내 ExitProcess API의 주소값을 MyExitProcess API의 주소값으로 바꿀수 있게 되고, 후킹을 성공할 수 있게 됩니다.</p>
<br>

<h3 id="실행"><a href="#실행" class="headerlink" title="실행"></a>실행</h3><img src="/2020/01/14/WindowsAPIHookingUsingIAT/2.png" title="후킹">

<br>

<h3 id="전체-소스-코드"><a href="#전체-소스-코드" class="headerlink" title="전체 소스 코드"></a>전체 소스 코드</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"tchar.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"windows.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(WINAPI* PFEXITPROCESS)</span><span class="params">(UINT uExitCode)</span></span>;</span><br><span class="line"></span><br><span class="line">FARPROC g_pOrgFunc = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL WINAPI <span class="title">MyExitProcess</span><span class="params">(UINT uExitCode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MessageBoxA(<span class="literal">NULL</span>, <span class="string">"IAT hooking"</span>, <span class="string">"hook"</span>, MB_OK);</span><br><span class="line">	<span class="keyword">return</span> ((PFEXITPROCESS)g_pOrgFunc)(uExitCode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">hook_iat</span><span class="params">(LPCSTR szDllName, PROC pfnOrg, PROC pfnNew)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HMODULE hMod;</span><br><span class="line">	LPCSTR szLibName;</span><br><span class="line">	PIMAGE_IMPORT_DESCRIPTOR pImportDesc;</span><br><span class="line">	PIMAGE_THUNK_DATA pThunk;</span><br><span class="line">	DWORD dwOldProtect, dwRVA;</span><br><span class="line">	PBYTE pAddr;</span><br><span class="line"></span><br><span class="line">	hMod = GetModuleHandle(<span class="literal">NULL</span>);			<span class="comment">// hMod = ImageBase</span></span><br><span class="line">	pAddr = (PBYTE)hMod;					<span class="comment">// pAddr = ImageBase</span></span><br><span class="line">	pAddr += *((DWORD*)&amp;pAddr[<span class="number">0x3C</span>]);		<span class="comment">// pAddr = "PE" Signature</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _WIN32</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">ifdef</span> _WIN64</span></span><br><span class="line">	dwRVA = *((DWORD*)&amp;pAddr[<span class="number">0x90</span>]);		<span class="comment">// dwRVA = RVA of IMAGE_IMPORT_DESCRIPTOR -&gt; 64bit</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	dwRVA = *((DWORD*)&amp;pAddr[<span class="number">0x80</span>]);		<span class="comment">// dwRVA = RVA of IMAGE_IMPORT_DESCRIPTOR -&gt; 32bit</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	pImportDesc = (PIMAGE_IMPORT_DESCRIPTOR)((DWORD_PTR)hMod + dwRVA);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (; pImportDesc-&gt;Name; pImportDesc++)</span><br><span class="line">	&#123;</span><br><span class="line">		szLibName = (LPCSTR)((DWORD_PTR)hMod + (DWORD)pImportDesc-&gt;Name);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (!_stricmp(szLibName, szDllName))</span><br><span class="line">		&#123;</span><br><span class="line">			pThunk = (PIMAGE_THUNK_DATA)((DWORD_PTR)hMod + (DWORD)pImportDesc-&gt;FirstThunk);</span><br><span class="line">			<span class="keyword">for</span> (; pThunk-&gt;u1.Function; pThunk++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (pThunk-&gt;u1.Function == (DWORD_PTR)pfnOrg)</span><br><span class="line">				&#123;</span><br><span class="line">					VirtualProtect((LPVOID)&amp;pThunk-&gt;u1.Function, <span class="number">8</span>, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</span><br><span class="line">					pThunk-&gt;u1.Function = (DWORD_PTR)pfnNew;</span><br><span class="line">					VirtualProtect((LPVOID)&amp;pThunk-&gt;u1.Function, <span class="number">8</span>, dwOldProtect, &amp;dwOldProtect);</span><br><span class="line">					</span><br><span class="line">					<span class="keyword">return</span> TRUE;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL WINAPI <span class="title">DllMain</span><span class="params">(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">switch</span> (fdwReason)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">		<span class="comment">// original API 주소 저장</span></span><br><span class="line">		g_pOrgFunc = GetProcAddress(GetModuleHandleA(<span class="string">"kernel32.dll"</span>), <span class="string">"ExitProcess"</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// ntdll!RtlExitUserProcess() 를 hook!hooking() 로 후킹</span></span><br><span class="line">		hook_iat(<span class="string">"kernel32.dll"</span>, g_pOrgFunc, (PROC)MyExitProcess);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">		<span class="comment">// IAT를 원래 대로 복원</span></span><br><span class="line">		hook_iat(<span class="string">"kernel32.dll"</span>, (PROC)MyExitProcess, g_pOrgFunc);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://777bareman777.github.io/2019/09/28/UnderstandC2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="777bareman777">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="777bareman777 Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/09/28/UnderstandC2/" class="post-title-link" itemprop="url">C언어 포인터와 배열의 관계 이해하기</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-09-28 22:06:02" itemprop="dateCreated datePublished" datetime="2019-09-28T22:06:02+09:00">2019-09-28</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-10-04 13:25:14" itemprop="dateModified" datetime="2019-10-04T13:25:14+09:00">2019-10-04</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C-language/" itemprop="url" rel="index"><span itemprop="name">C language</span></a></span>

                
                
              
            </span>
          

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
        
      
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2019/09/28/UnderstandC2/#comments" itemprop="discussionUrl"><span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/09/28/UnderstandC2/" itemprop="commentCount"></span></a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>강의, 책을 보면서 노트화 했던 것을 정리하는 포스팅입니다.</p>
<br>

<h2 id="포인터-배열-어떤-관계가-있지"><a href="#포인터-배열-어떤-관계가-있지" class="headerlink" title="포인터? 배열? 어떤 관계가 있지?"></a>포인터? 배열? 어떤 관계가 있지?</h2><p>저번시간에 포인터는 메모리 주소 값을 가질 수 있는 녀석이라고 설명했어요.</p>
<p>그렇다면 배열은 어떤 녀석일까요? 배열은 여러 개의 데이터들을 한꺼번에 관리할 수 있는 녀석이에요.</p>
<p>배열은 어떻게 여러 개의 데이터들을 한꺼번에 관리할 수 있는 걸까요?</p>
<p>그리고 단일 포인터에 일차원 배열을 대입하면 포인터를 배열처럼 사용할 수 있어요.<br>어떻게 그렇게 할 수 있는 걸까요?</p>
<p>아래의 코드를 보면, 배열과 포인터는 가리키는 대상체가 다르다는 것을 알 수가 있는데 말이죠.</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> a[<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125; =&gt; <span class="built_in">array</span> <span class="keyword">of</span> <span class="number">4</span> <span class="built_in">int</span></span><br><span class="line"><span class="built_in">int</span> *p=a; =&gt; pointer <span class="keyword">to</span> <span class="built_in">int</span></span><br><span class="line"></span><br><span class="line">sizeof(p) =&gt; <span class="number">8</span></span><br><span class="line">sizeof( <span class="built_in">int</span> * ) =&gt; <span class="number">8</span></span><br><span class="line"></span><br><span class="line">sizeof(a) =&gt; <span class="number">16</span></span><br><span class="line">sizeof(<span class="built_in">int</span> [<span class="number">4</span>]) =&gt; <span class="number">16</span></span><br></pre></td></tr></table></figure>

<p>배열이 여러 개의 데이터들을 한꺼번에 관리할 수 있는 이유는 배열의 크기만큼 메모리에 공간을 할당하고, 배열 이름 그 자체가 첫번째 데이터 시작지점의 주소 값을 가지고 있기 때문이에요.</p>
<p>단일 포인터에 일차원 배열을 대입하면 포인터를 배열처럼 사용할 수 있는 이유는 형 변환을 통해서 포인터에서 배열로 대입되기 때문이에요.</p>
<p>이런 것을 가능하게 하는 기법이 Decay라고 불려요.<br>Decay 이란 “배열의 이름은 일반적으로 배열의 첫번째 원소의 주소로 해석한다.” 에요.</p>
<p>Decay 문법에서도 예외 조건이 있다고 해요.<br>sizeof() 연산자에서는 대상체의 타입을 구해오는 것이 핵심이고, &amp; 연산자에서는 주소 값을 구하기 때문에 이 두가지는 예외적으로 취급해요.</p>
<p>그래서 sizeof(p)와 sizeof(a)의 크기가 다르고, p=a 와 p=&amp;a[0] 는 똑같은 의미를 가진다는 것을 알 수가 있어요. 그렇다면 p=&amp;a는 어떤 의미를 가지고 있을까요?</p>
<p>아래의 코드를 보면서, 좀 더 자세히 알아봅시다.</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int a[<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">	int (*p)[<span class="number">4</span>]=&amp;a;</span><br><span class="line"></span><br><span class="line">	(*p)[<span class="number">3</span>]=<span class="number">10</span>;  </span><br><span class="line"></span><br><span class="line">	printf(<span class="string">"p=%p<span class="subst">\n</span>"</span>,p);</span><br><span class="line">	printf(<span class="string">"p+1=%p<span class="subst">\n</span>"</span>,p+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	printf(<span class="string">"a[3]: %d<span class="subst">\n</span>"</span>,a[<span class="number">3</span>]);</span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote><p>10 line -&gt; p=0x7ffeec239830<br>11 line -&gt; p+1=0x7ffeec239840<br>13 line -&gt; a[3]: 10</p>
</blockquote>

<p>만약에 int (*p)[4]에 &amp;a를 대입한게 아니라, int *p=&amp;a를 대입했다면, 컴파일 할 때, 경고 문자를 볼 수 있어요. 그 이유는 &amp;연산자는 Decay 문법의 적용 대상이 아니기 때문이죠.</p>
<blockquote><p>warning: incompatible pointer types initializing ‘ int * ‘ with an<br>      expression of type ‘int (*)[4]’ [-Wincompatible-pointer-types]<br>        int *p=&a;</p>
</blockquote>

<br>

<p>int *p=&amp;a 는 int [4] 대상체의 주소를 int * 대상체에 집어 넣는 것이기 때문이죠. 즉, 자료형이 서로 다르기 때문에 경고 문자가 나타나는 거에요.</p>
<p>그에 반면, int (*p)[4]=&amp;a 같은 경우에는 int [4] 대상체의 주소를 int [4]의 메모리 주소 값을 가질 수 있는 대상체에 집어 넣기 때문에 경고 문자 없이 깔끔하게 컴파일이 되는거에요.</p>
<p>그래서 코드의 출력 결과를 보면, p가 가리키고 있는 녀석이 int [4] 이기 때문에 주소 값이 16이 증가한 것을 볼 수 있고, (*p)[3]을 통해 a[3]의 값을 바꿀 수 있는 이유는 int [4]의 메모리 주소 값을 가지고 있는 p를 역참조해서 a의 메모리 주소로 이동하고 첨자 [3]을 통해서 a의 세번째 인덱스를 접근해 값을 변경할 수 있는 거에요.</p>
<br>

<h2 id="포인터를-배열처럼-사용해보자"><a href="#포인터를-배열처럼-사용해보자" class="headerlink" title="포인터를 배열처럼 사용해보자."></a>포인터를 배열처럼 사용해보자.</h2><p>포인터를 어떠게 배열처럼 사용해야 하는지 차근차근 알아봅시다.</p>
<br>

<h3 id="배열을-포인터-접근으로-바꿔보자"><a href="#배열을-포인터-접근으로-바꿔보자" class="headerlink" title="배열을 포인터 접근으로 바꿔보자"></a>배열을 포인터 접근으로 바꿔보자</h3><p>배열로 선언한 것을 포인터를 이용해서 접근을 해봅시다.<br>아래의 처럼 선언했다고 생각해봅시다.</p>
<blockquote><p>int a[5]={1,2,3,4,5};</p>
</blockquote>

<p>이때, a가 요소 1,2,3,4,5를 포인터를 이용해서 어떻게 접근해야할까요?<br>바로 답은 아래와 같습니다.</p>
<blockquote><p>*(a)         // 인덱스 0에 접근<br>*(a + 1)    // 인덱스 1에 접근<br>*(a + 2)    // 인덱스 2에 접근<br>*(a + 3)    // 인덱스 3에 접근<br>*(a + 4)    // 인덱스 4에 접근</p>
</blockquote>

<p>배열의 이름은 배열의 요소의 첫번째 값을 가리키는 주소가 들어가 있습니다.<br>*(a + 1) 을 하면, 배열의 요소의 첫번째 값을 가리키는 주소에 변수 a가 가리키는 대상체인 int형의 크기 * 1을 더한 값을 역참조를 하기 때문에 배열의 요소의 2번째 값을 가리키는 녀석에 접근할 수 있는 것입니다.<br>마찬 가지로 인덱스 4에 접근을 할려면 *(a + 4)를 이용하면 됩니다.</p>
<h3 id="이차원배열과-포인터"><a href="#이차원배열과-포인터" class="headerlink" title="이차원배열과 포인터"></a>이차원배열과 포인터</h3><p>이러한 접근 방식을 이차원 배열에서 적용시켜 봅시다.<br>아래처럼 값을 선언했다고 생각해봐요.</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a[<span class="string">2</span>][<span class="symbol">2</span>]=&#123;1,2,3,4&#125;;</span><br><span class="line">int *p=a;</span><br><span class="line">p[<span class="string">1</span>][<span class="symbol">1</span>]=10;</span><br></pre></td></tr></table></figure>

<p>이때, a의 메모리 주소는 1000이라고 생각해요.</p>
<blockquote><p>p[1][1]<br>( *( p + 1 ) )[1]<br>( *( 1000 + sizeof(int) * 1 ) )[1]<br>( *1004 )[1]<br>*( *1004 + 1 )<br>*( 2 + 1 )<br>*3 // 이 때, 컴파일 에러가 발생, * 연산자를 이상한 주소 값을 가르켰기 때문.</p>
</blockquote>

<p>변수 p의 메모리 번지가 바뀌는 것을 봅시다.<br>p[1][1]은 ( *(p + 1) )[1]로 변경이 가능합니다.<br>그 후에 p가 가지고 있는 값은 1000이 되고, p가 가리키고 있는 대상체는 int형이기 때문에 1은 int형의 크기 * 1 로 변환이 됩니다. -&gt; ( *( 1000 + sizeof(int) * 1) )[1]<br>이를 간략하게 보면, ( *1004 )[1]이 되고, *( *1004 + 1)로도 표현이 가능합니다.<br>1004는 배열의 두번쨰 인덱스의 값인 2를 가리키게 되서, *( 2 + 1) 로 변환이 됩니다.<br>그렇다면, *(3) 이것의 의미는 3이라는 메모리 번지에 접근하는 것이기 때문에, 이상한 주소에 접근하게 되므로 컴파일 에러가 발생합니다.<br>요즘은 컴파일러가 좋아서인지 경고 문자를 보내고, 컴파일이 됩니다.<br>그리고 당연히 포인터를 이차원 배열처럼 사용은 불가능합니다.</p>
<br>

<p>이번에는 이중 포인터를 이용했다고 생각해봐요.</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a[<span class="string">2</span>][<span class="symbol">2</span>]=&#123;1,2,3,4&#125;;</span><br><span class="line">int **p=a;</span><br><span class="line">p[<span class="string">1</span>][<span class="symbol">1</span>]=10;</span><br></pre></td></tr></table></figure>

<p>이때, a의 메모리 주소는 마찬가지로 1000 입니다.</p>
<blockquote><p>p[1][1]<br>*( *(p + 1) + 1)<br>*( *(1000 + 1) + 1)<br>*( *(1000 + sizeof( int * ) * 1) + 1)<br>*( *(1008) + 1)<br>*( 0x0000000300000004 + 1)<br>*( 0x0000000300000004 + sizeof(int) * 1)<br>*( 0x0000000300000008 ) // 이 때, 잘못된 번지에 접근을 하기 때문에 run time 에러가 발생.</p>
</blockquote>

<p>변수 p의 메모리 주소가 바뀌는 것을 봅시다.<br>p[1][1]은 * ( <em>(p + 1) + 1) 변경이 가능합니다.<br>a의 메모리 주소가 1000이므로, *( *(1000 + 1) + 1) 으로도 변경이 가능합니다.<br>그리고 이때 p가 가리키는 대상체는 int * 이므로, *( *(1000 + sizeof( int * ) * 1) + 1) 으로 볼 수 있습니다. 이를 계산하면, *( *(1008) + 1) 으로 표현이 가능합니다.<br>이 때, int *</em> 이므로 이를 역참조하면 int * 이므로, 역참조를 한다고 하더라도 주소 값을 가져오는 것이기 때문에 0x0000000300000004가 되어서, *(0x0000000300000004+1) 으로 표현이 가능합니다. 이 때, 가리키는 대상체가 int형이므로, *(0x0000000300000004+sizeof(int) * 1) 으로 표현이 가능합니다.<br>따라서 *0x0000000300000008 이라는 잘못된 번지에 접근을 하기 때문에 run time 에러가 발생하는 것입니다. 그 뿐만 아니라 컴파일 에러도 발생 합니다.</p>
<br>

<p>그렇다면, 포인터를 이차원 배열처럼 사용할러면 어떻게 선언하면 될까요?<br>아래처럼 선언하면 됩니다.</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a[<span class="string">2</span>][<span class="symbol">2</span>]=&#123;1,2,3,4&#125;;</span><br><span class="line">int (*p)[2]=a;</span><br><span class="line">p[<span class="string">1</span>][<span class="symbol">1</span>]=10;</span><br></pre></td></tr></table></figure>

<p>이번에도 a의 메모리 주소는 이번에도 1000입니다.</p>
<blockquote><p>p[1][1]<br>*( *(p + 1) + 1)<br>*( *(1000 + sizeof(int [2]) * 1 ) + 1)<br>*( *(1008) + 1)<br>*( 1008 + 1)<br>*( 1008 + sizeof(int) * 1)<br>*(1012)</p>
</blockquote>

<p>p의 메모리 주소가 바뀌는 것을 한번더 봅시다.<br>p[1][1]을 포인터 접근으로 변환하면, *( *(p + 1) + 1)로 변환이 가능하고, p는 대상체 int [2]를 가리키기 때문에, *( *(1000 + sizeof(int [2]) * 1) + 1)로 바뀝니다.<br>이걸 간략화하면, *( *(1008) + 1) 으로 바꿀 수 있습니다. p 는 내부에 있는 이름 없는 배열을 가리키고 있기 때문에, Decay 문법에 의해 int [2] 타입이 int * 타입으로 변환되기 때문에 *( 1008 + 1)이 됩니다.<br>이 때, 가리키는 대상체는 int형 이기 때문에 *( 1008 + sizeof(int) * 1) 이 되고, 간략화하면, *(1012)가 되어서, a[1][1]에 해당하는 값인 4를 10으로 바꿀 수 있게 되는 것입니다.</p>
<br>

<p><strong>즉, 배열과 포인터의 관계를 이해하기 위해서는 Decay 에 대해 알아야 하고, Decay 을 이용하면 배열의 이름이 첫 번째 원소의 주소로 해석된다는 것을 알고 있으면 됩니다.</strong></p>
<br>

<h2 id="배열을-포인터적으로-해석해보자"><a href="#배열을-포인터적으로-해석해보자" class="headerlink" title="배열을 포인터적으로 해석해보자"></a>배열을 포인터적으로 해석해보자</h2><p>먼저 기본적으로 단일 포인터를 해석합시다.</p>
<blockquote><p>타입 해석<br>int* p // pointer to int</p>
<p>자체 크기<br>sizeof( p )<br>sizeof( int * )<br>-&gt; 64 bit는 8Byte, 32 bit는 4Byte</p>
<p>한번 움직이는 거리(offset)<br>p + 1<br>p + sizeof( *p ) + 1<br>p + sizeof( int ) * 1<br>p + 4</p>
</blockquote>

<p>int * 타입은 자기 자신의 크기는 64비트 기준 8바이트 이고, 가리키는 대상체가 int 형이기 때문에 offset 값이 4입니다.</p>
<br>

<h3 id="일차원-배열의-포인터적-해석"><a href="#일차원-배열의-포인터적-해석" class="headerlink" title="일차원 배열의 포인터적 해석"></a>일차원 배열의 포인터적 해석</h3><blockquote><p>타입해석<br>int a[2] // array of 2 int<br>자체 크기<br>sizeof( a )<br>sizeof( int [2] ) // 8Byte</p>
<p>한번 움직이는 거리(offset)<br>a + 1<br>a + sizeof( *a ) * 1<br>a + sizeof( int ) * 1<br>a + 4</p>
</blockquote>

<p>int [2] 타입은 자기 자신의 크기는 8바이트이고, 가리키는 대상체가 int 형이기 때문에 offset 값이 4입니다.</p>
<h3 id="포인터-배열의-포인터적-해석"><a href="#포인터-배열의-포인터적-해석" class="headerlink" title="포인터 배열의 포인터적 해석"></a>포인터 배열의 포인터적 해석</h3><blockquote><p>타입 해석<br>int *a[2] // array of 2 pointer to int</p>
<p>자체 크기<br>sizeof( a )<br>sizeof( int *[2] ) // 16Byte</p>
<p>한번 움직이는 거리(offset)<br>a + 1<br>a + sizeof( <em>a ) * 1<br>a + sizeof( int</em> ) * 1<br>a + 8</p>
</blockquote>

<p>전치랑 후치가 존재할 때, 후치가 먼저 해석되기 때문에 배열 포인터가 아니라 포인터 배열로 해석된다.<br>int *[2] 타입은 자기 자신의 크기는 16바이트이고, 가리키는 대상체가 int *형이기 때문에 offset 값기 8입니다.</p>
<h3 id="배열의-포인터의-포인터적-해석"><a href="#배열의-포인터의-포인터적-해석" class="headerlink" title="배열의 포인터의 포인터적 해석"></a>배열의 포인터의 포인터적 해석</h3><blockquote><p>int (*p)[2] // pointer to array of 2 int</p>
<p>자체크기<br>sizeof( p )<br>sizeof( int (*)[2] ) // 8Byte</p>
<p>한번 움직이는 거리(offset)<br>p + 1<br>p + sizeof( *p ) * 1<br>p + sizeof( int [2] ) + 1<br>p + 8</p>
</blockquote>

<p>전치랑 후치가 존재할 때, 후치가 먼저 해석되기 때문에 배열 포인터를 사용하기 위해서는 괄호를 쳐서 우선 순위를 높여줘야 한다.<br>int *[2] 타입은 자기 자신의 크기는 8바이트이고, 가리키는 대창체가 int [2] 형이기 때문에 offset 값은 8입니다.</p>
<h3 id="이중-포인터의-포인터적-해석"><a href="#이중-포인터의-포인터적-해석" class="headerlink" title="이중 포인터의 포인터적 해석"></a>이중 포인터의 포인터적 해석</h3><blockquote><p>타입해석<br>int **p // pointer to pointer to int</p>
<p>자체크기<br>sizeof( p )<br>sizeof( int ** ) // 8Byte</p>
<p>한번 움직인느 거리(offset)<br>p + 1<br>p + sizeof( *p ) * 1<br>p + sizeof( int * ) * 1<br>p + 8</p>
</blockquote>

<p>int ** 타입은 자기 자신의 크기는 8바이트이고, 가리키는 대상체가 int * 형이기 때문에 offset 값은 8입니다.</p>
<h3 id="이차원-배열의-포인터적-해석"><a href="#이차원-배열의-포인터적-해석" class="headerlink" title="이차원 배열의 포인터적 해석"></a>이차원 배열의 포인터적 해석</h3><blockquote><p>타입해석<br>int a[2][2] // array of 2 array of 2 int</p>
<p>자체 크기<br>sizeof( p )<br>sizeof( int [2][2] ) // 16Byte</p>
<p>한번 움직이는 거리(offset)<br>a + 1<br>a + sizeof( *a ) * 1<br>a + sizeof( int [2] ) * 1<br>a + 8</p>
</blockquote>

<p>int [2][2] 타입은 자시 자신의 크기는 16바이트이고, 가리키는 대상체가 int [2] 형이기 때문에 offset 값은 8입니다.</p>
<h3 id="삼차원-배열의-포인터적-해석"><a href="#삼차원-배열의-포인터적-해석" class="headerlink" title="삼차원 배열의 포인터적 해석"></a>삼차원 배열의 포인터적 해석</h3><blockquote><p>int a[2][2][2] // array of 2 array of 2 array of 2 int</p>
<p>자체크기<br>sizeof( a )<br>sizeof( int [2][2][2] ) // 32byte</p>
<p>a[0][0][0] : 0x7ffee4de57b0<br>a[0][0][1] : 0x7ffee4de57b4<br>a[0][1][0] : 0x7ffee4de57b8<br>a[0][1][1] : 0x7ffee4de57bc<br>a[1][0][0] : 0x7ffee4de57c0<br>a[1][0][1] : 0x7ffee4de57c4<br>a[1][1][0] : 0x7ffee4de57c8<br>a[1][1][1] : 0x7ffee4de57cc</p>
<p>한번 움직이는 거리(offset)<br>a + 1<br>a + sizeof( *a ) * 1<br>a + sizeof( int [2][2] ) * 1<br>a + 16</p>
</blockquote>

<p>int [2][2][2] 타입은 자기 자신의 크기는 32바이트이고, 가리키는 대상체가 int [2][2] 형이기 때문에 offset 값은 16입니다.</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://777bareman777.github.io/2019/09/24/UnderstandC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="777bareman777">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="777bareman777 Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/09/24/UnderstandC/" class="post-title-link" itemprop="url">C 언어 포인터 이해하기</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-09-24 10:42:55" itemprop="dateCreated datePublished" datetime="2019-09-24T10:42:55+09:00">2019-09-24</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-10-04 03:25:56" itemprop="dateModified" datetime="2019-10-04T03:25:56+09:00">2019-10-04</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C-language/" itemprop="url" rel="index"><span itemprop="name">C language</span></a></span>

                
                
              
            </span>
          

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
        
      
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2019/09/24/UnderstandC/#comments" itemprop="discussionUrl"><span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/09/24/UnderstandC/" itemprop="commentCount"></span></a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>강의, 책을 보면서 노트화 했던 것을 정리하는 포스팅입니다.</p>
<br>

<h2 id="포인터는-무엇일까"><a href="#포인터는-무엇일까" class="headerlink" title="포인터는 무엇일까?"></a>포인터는 무엇일까?</h2><p>C 언어에서 포인터는 무엇일까요? 개념 자체는 단순해요. 그냥 <strong>메모리의 주소 값을 가질 수 있는 녀석</strong>이죠.</p>
<br>

<h3 id="사용하는-이유는"><a href="#사용하는-이유는" class="headerlink" title="사용하는 이유는?"></a>사용하는 이유는?</h3><p>이러한 포인터를 사용하는 무엇일까요?<br>함수를 사용하지 않고, 동적 할당도 사용하지 않고, 모든 코드를 진입점 함수에 해당하는 main()에 모든 코드를 집어 넣으면 포인터를 사용할 필요가 없을지도 몰라요.</p>
<p>하지만 우리는 그렇게 코딩을 하지 않고, 유지 보수를 용이하게 하기 위해서 기능별로 소스 파일 만들고, 모듈화 하기 위해서 진입점 함수의 부분을 간략화 하는 등 일을 하기 때문에 포인터 라는 것이 필요해요.</p>
<p>포인터라는 문법이 없는 자바, C# 등 에서는 가비지 컬렉션이라고 불리는 녀석들이 알아서 메모리를 관리하기 때문에 필요가 없지만, C/C++ 에서는 메모리 관리를 개발자가 직접하기 때문에 포인터라는 문법이 존재하죠.</p>
<br>

<h2 id="포인터-문법"><a href="#포인터-문법" class="headerlink" title="포인터 문법"></a>포인터 문법</h2><p>포인터는 <strong>“*”</strong> 별표라는 기호를 이용해서 사용해요.</p>
<p>예를 들어서, char *a, int *b, float *c 라고 하면, 순서대로 char 형 포인터로 선언된 a, int형 포인터로 선언된 b, float형 포인터로 선언된 c로 볼 수 있어요.</p>
<p>이렇게 단일 포인터로 사용될 경우에는 포인터가 어떤 식으로 사용되는지 쉽게 알 수 있지만, 포인터를 이중,삼중으로 사용하게 되면, 이 포인터가 무엇을 의미하는지 알기 쉽지 않아요. 그거에 대해서 차근차근 알아볼 거에요.</p>
<p>그리고 <strong>“*”</strong> 별표는 포인터 변수라는 것을 의미하는 것 이외에도, 곱셈 기호로 사용하기도 하고, 역참조해서 해당 주소의 값에 접근할 때도 사용해요.</p>
<p>또한 모든 포인터는 대상체의 크기만큼 이동을 하게 되는데 이게 무슨 의미일까요? 한번 코드를 통해 알아봅시다.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">100</span>;</span><br><span class="line">	<span class="keyword">int</span>* p=&amp;i;</span><br><span class="line">	*p=<span class="number">200</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"sizeof(i): %lu\n"</span>,<span class="keyword">sizeof</span>(i));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"sizeof(int): %lu\n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"sizeof(p): %lu\n"</span>,<span class="keyword">sizeof</span>(p));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"sizeof(int *): %lu\n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>*));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"sizeof(*p): %lu\n"</span>,<span class="keyword">sizeof</span>(*p));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"p=%p\n"</span>,p);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"p+1=%p\n"</span>,p+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote><p>7 line-&gt; 200<br>8 line-&gt; sizeof(i): 4<br>9 line-&gt; sizeof(int): 4<br>10 line-&gt; sizeof(p): 8<br>11 line-&gt; sizeof( int * ): 8<br>12 line-&gt; sizeof( *p ): 4<br>13 line-&gt; p=0x7ffeea9fa848<br>14 line-&gt; p+1=0x7ffeea9fa84c</p>
</blockquote>

<p>맨 마지막의 메모리 주소 값은 환경에 따라 다를 수 있습니다.</p>
<p>변수 i를 100로 초기화를 했지만, 포인터 변수 p에 i의 주소 값을 집어 넣고, 포인터 변수 p를 역참조해서 200라는 값을 대입을 했어요.<br>그래서 변수 i의 값이 100에서 200로 변한 것이죠.</p>
<img src="/2019/09/24/UnderstandC/1.png">

<p>그리고 int 형의 크기, int 형 변수의 크기, int 포인터 형의 크기, int 포인터 형 변수의 크기, int 포인터 형 변수의 역 참조의 크기에 대해 알아봤어요.</p>
<p>int 형 같은 경우에는 IA-64 계열에서는 4바이트의 크기를 가지고 있어요. cpu의 종류에 따라 이 크기는 달라질 수도 있어요.</p>
<p>int 포인터 형 같은 경우에는 IA-64 계열에서는 8바이트, x86 계열에서는 4바이트를 가지고 있어요. 그리고 포인터 같은 경우에는 int 형이든, float 형이든 크기가 동일해요. 그 이유는 메모리 주소를 나타내기 때문이죠. 그렇다고 하더라도 int 포인터 형과 float 포인터 형을 섞어서 써도 된다는 말은 아니에요. 섞어서 사용하면 안됩니다.</p>
<p>제 cpu는 IA-64 계열이라서 int 형의 크기가 4바이트, int 포인터 형의 크기가 8바이트, int 포인터 형의 역참조 크기가 4바이트가 나옵니다.</p>
<p>int 포인터 형의 역참조 크기가 4바이트가 나오는 이유는 int 포인터 형이 가리키고 있는 녀석이 int 형이기 때문입니다. 그래서 4바이트 크기가 나오는 것입니다.</p>
<p>char 포인터 형의 역참조 크기는 몇 바이트가 나올까요? char 포인터 형의 크기는 IA-64 계열에서 int 포인터 형의 크기처럼 8바이트가 나오지만, 역참조의 크기는 4바이트가 아니라 1바이트가 나옵니다. 그 이유는 char 포인터 형의 역참조는 char 형을 가리키기 때문이죠.</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://777bareman777.github.io/2019/09/20/UnderstandPE6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="777bareman777">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="777bareman777 Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/09/20/UnderstandPE6/" class="post-title-link" itemprop="url">PE 구조 이해하기 - IMAGE_SECTION_HEADER 구조</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-09-20 17:00:55" itemprop="dateCreated datePublished" datetime="2019-09-20T17:00:55+09:00">2019-09-20</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-09-24 09:13:51" itemprop="dateModified" datetime="2019-09-24T09:13:51+09:00">2019-09-24</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/PE-file/" itemprop="url" rel="index"><span itemprop="name">PE file</span></a></span>

                
                
              
            </span>
          

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
        
      
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2019/09/20/UnderstandPE6/#comments" itemprop="discussionUrl"><span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/09/20/UnderstandPE6/" itemprop="commentCount"></span></a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>windows 시스템 실행파일의 구조와 원리 책 내용을 요약 및 정리 하는 포스팅이에요.</p>
<p>섹션들의 정보들의 위치와 크기를 나타내는 <strong>IMAGE_SECTION_HEADER</strong>에 대한 내용을 알아볼 거에요.</p>
<br>

<h2 id="IMAGE-SECTION-HEADER의-시작"><a href="#IMAGE-SECTION-HEADER의-시작" class="headerlink" title="IMAGE_SECTION_HEADER의 시작"></a>IMAGE_SECTION_HEADER의 시작</h2><p>IMAGE_NT_HEADER에 대한 설명이 이제 다 끝났어요. 그 다음으로 이어질 구조체인 IMAGE_SECTION_HEADER에 대한 설명을 시작할게요.</p>
<p>여기에서도 섹션들의 정보들의 위치와 크기등 여러가지를 알려주는 IMAGE_SECTION_HEADER에 대해 알아볼 건데요. 섹션들의 정보들의 위차와 크기를 나타내는 IMAGE_DATA_DIRECTORY 구조체와 어떤 차이가 있는 걸까요?</p>
<p>IMAGE_DATA_DIRECTORY 구조체에 있는 섹션들은 IMAGE_SECTION_HEADER 구조체에 있는 섹션들에게 병합되어 있기 때문에 PE 파일 내에 정보가 없어요! 따라서 IMAGE_DATA_DIRECTORY 구조체에 있는 섹션들의 정보를 확인하고 싶으면, IMAGE_SECTION_HEADER 구조체에 있는 정보들과 조합해서 찾아야 합니다!</p>
<p>자 진짜로 IMAGE_SECTION_HEADER에 대한 설명을 시작할게요!</p>
<p><strong>IMAGE_SECTION_HEADER 구조체는 40바이트로 구성되어 있고요. IMAGE_FILE_HEADER의 NumberOfSections 필드에 있는 섹션의 개수만큼 IMAGE_SECTION_HEADER 가 존재해요.</strong><br>이 구조체도 마찬가지로 “WinNT.h” 헤더 파일에 정의되어 있습니다.</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#defome IMAGE_SECTION_HEADER 8</span></span><br><span class="line"></span><br><span class="line">typedef struct _IMAGE_SECTION_HEADER &#123;</span><br><span class="line">  <span class="keyword">BYTE </span> Name[IMAGE_SIZEOF_SHORT_NAME]<span class="comment">;</span></span><br><span class="line">  union &#123;</span><br><span class="line">    DWORD PhysicalAddress<span class="comment">;</span></span><br><span class="line">    DWORD VirtualSize<span class="comment">;</span></span><br><span class="line">  &#125; Misc<span class="comment">;</span></span><br><span class="line">  DWORD VirtualAddress<span class="comment">;</span></span><br><span class="line">  DWORD SizeOfRawData<span class="comment">;</span></span><br><span class="line">  DWORD PointerToRawData<span class="comment">;</span></span><br><span class="line">  DWORD PointerToRelocations<span class="comment">;</span></span><br><span class="line">  DWORD PointerToLinenumbers<span class="comment">;</span></span><br><span class="line">  WORD  NumberOfRelocations<span class="comment">;</span></span><br><span class="line">  WORD  NumberOfLinenumbers<span class="comment">;</span></span><br><span class="line">  DWORD Characteristics<span class="comment">;</span></span><br><span class="line">&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<br>

<h3 id="첫-번째-멤버-BYTE-Name-IMAGE-SIZEOF-SHORT-NAME"><a href="#첫-번째-멤버-BYTE-Name-IMAGE-SIZEOF-SHORT-NAME" class="headerlink" title="첫 번째 멤버, BYTE Name[IMAGE_SIZEOF_SHORT_NAME]"></a>첫 번째 멤버, BYTE Name[IMAGE_SIZEOF_SHORT_NAME]</h3><p><strong>섹션의 아스키 이름</strong>을 나타내요. IMAGE_SIZEOF_SHORT_NAME은 8바이트로 매크로 상수로 정의되어 있고요. 문자열임에도 불구하고 NULL을 신경쓰지 않아요.<br>그 이유가 섹션 이름을 8바이트 이상으로 지정했을 경우 링커가 알아서 8바이트 이후의 문자열은 잘라 버린 후 값을 채우기 때문이에요.</p>
<br>

<h3 id="두-번째-멤버-DOWRD-PhysicalAddress-or-VirtualSize"><a href="#두-번째-멤버-DOWRD-PhysicalAddress-or-VirtualSize" class="headerlink" title="두 번째 멤버, DOWRD PhysicalAddress or VirtualSize"></a>두 번째 멤버, DOWRD PhysicalAddress or VirtualSize</h3><p>이 필드는 OBJ 파일인 경우와 PE의 경우 의미가 달라져요.</p>
<p><strong>PE의 경우 공용체의 VirtualSize 필드를 사용하여 코드와 데이터의 실제 바이트수</strong>를 담고 있어요. 즉, 파일 바이트 정렬의 배수로 라운드업이 되기 전의 실제 바이트 수를 담고 있어요.<br>이 값에 대한 라운드업된 값은 이 구조체의 SizeOfRawData 필드에 저장되요.</p>
<p>이전까지는 OBJ 파일의 경우 공용체의 PhysicalAddress 필드를 통해 섹션의 물리적인 번지를 지정했지만, 현재에는 OBJ의 경우 이 필드는 0으로 세팅되요. 즉, PhysicalAddress 필드는 더 이상 의미가 없어졌어요.</p>
<p>이렇게 물리적인 번지를 직접 사용하지 않는 이유가 현대에는 보호모드가 보편적으로 사용되기 때문이에요.</p>
<br>

<h3 id="세-번째-멤버-DWORD-VirtualAddress"><a href="#세-번째-멤버-DWORD-VirtualAddress" class="headerlink" title="세 번째 멤버, DWORD VirtualAddress"></a>세 번째 멤버, DWORD VirtualAddress</h3><p><strong>PE에서 해당 섹션을 매핑시켜야 할 가상 주소 공간 상의 RVA</strong>를 가지고 있어요.<br>즉, <strong>메모리 상에서의 본 섹션의 시작 주소</strong>를 의미하는 거죠.<br>그리고 <strong>SectionAlignment 필드 값의 배수</strong>가 되어야 한다.</p>
<br>

<h3 id="네-번째-멤버-DWORD-SizeOfRawData"><a href="#네-번째-멤버-DWORD-SizeOfRawData" class="headerlink" title="네 번째 멤버, DWORD SizeOfRawData"></a>네 번째 멤버, DWORD SizeOfRawData</h3><p><strong>VirtualSize 필드 값에 대한 파일 정렬(Alignment) 값의 배수로 라운드업된 값</strong>이다.<br>만약 IMAGE_OPTIONAL_HEADER의 FileAlignment 필드의 값이 0x200 이고, VirtualSize 필드 값이 0x35A이면 SizeOfRawData 필드 값은 0x400이 된다.</p>
<p>OBJ 파일의 경우 이 값은 0이다.</p>
<br>

<h3 id="다섯-번째-멤버-DWORD-PointerToRawData"><a href="#다섯-번째-멤버-DWORD-PointerToRawData" class="headerlink" title="다섯 번째 멤버, DWORD PointerToRawData"></a>다섯 번째 멤버, DWORD PointerToRawData</h3><p><strong>해당 섹션의 PE 파일 내에서 시작하는 실제 파일 오프셋 값</strong>이다.<br>이 값 역시 IMAGE_OPTIONAL_HEADER의 <strong>FileAlignmnet 필드 값의 배수</strong>가 되어야 한다.<br>이 필드의 값은 <strong>VirtualAddress 필드의 값과 같을 수도 있고 다를 수도</strong> 있다.</p>
<p>그렇게 하는 이유가 VirtualAddress 필드는 IMAGE_OPTIONAL_HEADER의 SectionAlignment 필드 값의 배수가 되기 때문에 바이트 정렬 문제로 인하여 하드디스크 상의 공간을 낭비될 수 있고, 이때 PointerToRawData 필드에 실제 섹션의 파일 상의 시작 오프셋을 지정하고 오프셋에 섹션 데이터를 기록함으로써 PE 파일의 크기를 줄일 수 있는 거라고 해요.</p>
<p>따라서 VirtualAddress 필드와 PointerToRawData 필드 사이의 관계를 파악하는 것이 중요하다고 해요.<br>VirtualAddress의 값은 RVA이기 때문에 IMAGE_OPTIONAL_HEADER의 ImageBase 필드 값을 더한 결과가 프로그램 로더가 PE 파일을 위하여 프로세스 커널 객체를 생성한 후 가상 주소 공간을 만들고 나서 이 섹션을 해당 주소 공간에 매핑시킬 실제 번지 값이 되요. 그리고 PointerToRawData의 값은 이 섹션이 위치한 PE 파일 내의 파일 선두로 부터의 오프셋이 되고요.</p>
<p>VirtualAddress 필드와 PointerToRawData 필드는 중요한 필드인 거죠!<br>아래의 사진은 책에 첨부되더 있는 VirtualAddress와 PointerToRawData 사이의 관계에 대한 그림입니다.</p>
<img src="/2019/09/20/UnderstandPE6/1.png">

<br>

<h3 id="여섯-번째-멤버-PointerToRelocations"><a href="#여섯-번째-멤버-PointerToRelocations" class="headerlink" title="여섯 번째 멤버, PointerToRelocations"></a>여섯 번째 멤버, PointerToRelocations</h3><p>본 섹션을 위한 <strong>재배치 파일 오프셋</strong>이에요. 이 필드는 OBJ에서만 사용되고 실행 파일에서는 0으로 세트되요. OBJ 파일에서 이 필드가 0이 아닐 경우 IMAGE_RELOCATION 구조체 배열의 시작 주소를 가리켜요.</p>
<br>

<h3 id="일곱-번째-멤버-PointerToLinenumbers"><a href="#일곱-번째-멤버-PointerToLinenumbers" class="headerlink" title="일곱 번째 멤버, PointerToLinenumbers"></a>일곱 번째 멤버, PointerToLinenumbers</h3><p>본 섹션을 위한 <strong>COFF 스타일의 라인 번호를 위한 파일 오프셋</strong>이에요. 이 필드의 값이 0이 아닐 경우 IMAGE_LINENUMBER 구조체 배열의 시작을 가리키고, COFF 라인 번호가 PE에 첨부되었을 경우에만 사용해요.</p>
<br>

<h3 id="여덟-번째-멤버-NumberOfRelocations"><a href="#여덟-번째-멤버-NumberOfRelocations" class="headerlink" title="여덟 번째 멤버, NumberOfRelocations"></a>여덟 번째 멤버, NumberOfRelocations</h3><p>PointerToRelocations 필드가 가리키는 <strong>IMAGE_RELOCATION 구조체 배열의 원소의 개수</strong>에요. 실행 파일에서는 항상 0이에요!</p>
<br>

<h3 id="아홉-번째-멤버-NumberOfLinenumbers"><a href="#아홉-번째-멤버-NumberOfLinenumbers" class="headerlink" title="아홉 번째 멤버, NumberOfLinenumbers"></a>아홉 번째 멤버, NumberOfLinenumbers</h3><p>PointerToLinenumbers 필드가 가리키는 <strong>IMAGE_LINENUMBER 구조체 배열의 원소의 개수</strong>에요. 마찬가지로 COFF 라인 번호가 PE 파일에 추가 되어쓸 때만 사용해요.</p>
<br>

<h3 id="열-번째-멤버-Characteristics"><a href="#열-번째-멤버-Characteristics" class="headerlink" title="열 번째 멤버, Characteristics"></a>열 번째 멤버, Characteristics</h3><p><strong>이 필드는 해당 섹션의 속성을 나타내는 플래그의 집합</strong>이에요.<br>“WinNT.h” 헤더 파일에 IMAGE_SCN_XXX_XXX의 형태로 매크로로 정의되어 있어요.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Section contains code.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SCN_CNT_CODE 0x00000020</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Section contains ubutuakuzed data</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SCN_CNT_INITIALIZED_DATA 0x00000040</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Section contains uninitialized data</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SCN_CNT_UNINITIALIZED_DATA 0x00000080</span></span><br></pre></td></tr></table></figure>

<p>링커는 링크 시에 필요에 따라서나 혹은 사용자의 지시에 의해 여러 섹션들을 하나로 병합할수 있어요. 병합하는 옵션은 /MERGS:from=to 형식으로 지정하면 되요. 이때 병합된 섹션 내에 특정 섹션이 포함되어 있는지를 확인할 수 있는 플래그 집함을 제공한느데 위의 플래그 집함이 그 목적으로 사용된다고 해요.</p>
<h4 id="IMAGE-SCN-CNT-CODE"><a href="#IMAGE-SCN-CNT-CODE" class="headerlink" title="IMAGE_SCN_CNT_CODE"></a>IMAGE_SCN_CNT_CODE</h4><p>섹션의 코드를 포함하고 있고, 보통 이 플래그는 실행 가능 플래그를 의미하는 IMAGE_SCN_MEM_EXECUTE(0x20000000) 플래그와 함께 저장된다고 해요.</p>
<h4 id="IMAGE-SCN-CNT-INITIALIZED-DATA"><a href="#IMAGE-SCN-CNT-INITIALIZED-DATA" class="headerlink" title="IMAGE_SCN_CNT_INITIALIZED_DATA"></a>IMAGE_SCN_CNT_INITIALIZED_DATA</h4><p>섹션이 초기화된 데이터를 포함하고 있어요. 실행 가능 섹션과 .bss 섹션을 제외한 거의 대부분의 섹션이 이 플래그를 가져요.</p>
<h4 id="IMAGE-SCN-CNT-UNINTIALIZED-DATA"><a href="#IMAGE-SCN-CNT-UNINTIALIZED-DATA" class="headerlink" title="IMAGE_SCN_CNT_UNINTIALIZED_DATA"></a>IMAGE_SCN_CNT_UNINTIALIZED_DATA</h4><p>섹션이 초기화되지 않은 데이터(.bss 섹션 …)들이 가져요.</p>
<br>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SCN_MEM_DISCARDABLE 0x02000000 <span class="comment">// Section can be discared.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SCN_MEM_NOT_CACHED 0x04000000 <span class="comment">// Section is not cachable.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SCN_MEM_NOT_PAGED 0x08000000 <span class="comment">// Section is not pageable.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SCN_MEM_SHARED 0x10000000 <span class="comment">// Section is shareable.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SCN_MEM_EXECUTE 0x20000000 <span class="comment">// Section is readable.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SCN_MEM_READ 0x40000000 <span class="comment">// Section is readable.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SCN_MEM_WRITE 0x80000000 <span class="comment">// Section is writeable.</span></span></span><br></pre></td></tr></table></figure>

<p>위의 매크로 정의들은 메모리 페이지 속성을 나타내는 플래그들이에요.</p>
<h4 id="IMAGE-SCN-MEM-DISCARDABLE"><a href="#IMAGE-SCN-MEM-DISCARDABLE" class="headerlink" title="IMAGE_SCN_MEM_DISCARDABLE"></a>IMAGE_SCN_MEM_DISCARDABLE</h4><p>이 섹션은 실행 이미지가 메모리에 완전히 매핑되고 난 뒤 버려질 수 있다는 것을 의미해요.<br>일단 메모리에 로드(매핑)되고 난 후 프로세스에게 더 이상 의미없는 섹션이며, 가장 일반적인 버릴 수 있는 섹션은 기본 재배치(.reloc)섹션이에요.</p>
<h4 id="IMAGE-SCN-MEM-NOT-CACHD"><a href="#IMAGE-SCN-MEM-NOT-CACHD" class="headerlink" title="IMAGE_SCN_MEM_NOT_CACHD"></a>IMAGE_SCN_MEM_NOT_CACHD</h4><h4 id="IMAGE-SCN-MEM-NOT-PAGED"><a href="#IMAGE-SCN-MEM-NOT-PAGED" class="headerlink" title="IMAGE_SCN_MEM_NOT_PAGED"></a>IMAGE_SCN_MEM_NOT_PAGED</h4><p>해당 섹션은 페이지되지 않거나 캐쉬되지 않아요. 페이지 되지 않는다는 말은 결코 페이지 파일로 스왑되지 않는 다는 것을 의미하며 이는 항상 RAM에 존재하는 섹션임을 의미해요. 이런 종류의 섹션을 필요로 하는 경우는 커널 모드에서 작동하는 디바이스 드라이버 가능 실행 모듈이에요.</p>
<h4 id="IMAGE-SCN-MEM-SHARED"><a href="#IMAGE-SCN-MEM-SHARED" class="headerlink" title="IMAGE_SCN_MEM_SHARED"></a>IMAGE_SCN_MEM_SHARED</h4><p>해당 섹션은 공유 가능한 섹션이라는 것을 의미해요. DLL과 함께 사용될 때 이 섹션에 있는 데이터는 DLL을 사용하는 모든 프로세스들에 의해 공유될 수 있어요.<br>일반적으로 데이터 섹션들은 공유 불가능하다. 이 말은 해당 DLL을 사용하는 각각의 프로세스는 이 섹션의 데이터에 대한 자신만의 사본을 가진다는 의미에요.<br>하지만 공유 가능 섹션은 메모리 매니저에게 해당 섹션을 공유 가능하도록 지시해요. 공유 가능 섹션을 만들려면 링커 시에 SHARED 속성을 주면 되요.</p>
<blockquote><p>LINK /SECTION:MYDATA, RWS …</p>
</blockquote>

<h4 id="IMAGE-SCN-MEM-EXECUTE"><a href="#IMAGE-SCN-MEM-EXECUTE" class="headerlink" title="IMAGE_SCN_MEM_EXECUTE"></a>IMAGE_SCN_MEM_EXECUTE</h4><p>이 섹션은 실행 가능한 섹션임을 의미해요. 이 플래그는 보통 코드 포함 플래그인 IMAGE_SCN_CNT_CODE 플래그와 함께 셋되요.</p>
<h4 id="IMAGE-SCN-MEM-READ"><a href="#IMAGE-SCN-MEM-READ" class="headerlink" title="IMAGE_SCN_MEM_READ"></a>IMAGE_SCN_MEM_READ</h4><p>이 섹션은 읽기 가능한 섹션임을 의미해요. 이 플래그는 언제나 EXE 파일 내의 대부분의 섹션들에 셋되요.</p>
<h4 id="IMAGE-SCN-MEM-WRITE"><a href="#IMAGE-SCN-MEM-WRITE" class="headerlink" title="IMAGE_SCN_MEM_WRITE"></a>IMAGE_SCN_MEM_WRITE</h4><p>이 섹션은 쓰기 가능한 섹션임을 의미해요. 이 플래그가 EXE의 섹션에 세트되지 않으면 로더는 메모리 맵드 페이지를 읽기 전용 또는 실행 전용으로 마크한다고 해요.<br>쓰기 가능한 전형적인 예로 .data와 .bss 섹션이 있고, .idata 섹션 역시 이 플래그를 가져요.</p>
<br>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Section contains comments or some other type of information</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SCN_LNK_INFO 0x00000200</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Section contents will not become of image.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SCN_LNK_REMOVE 0x00000800</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Section contents comdat.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SCN_LNK_COMDAT 0x00010000</span></span><br></pre></td></tr></table></figure>

<p>위의 매크로들은 컴파일 후 생성되는 OBJ 파일 내에서만 설정되는 플래그들로서 후에 링크 시에 링크로 하여금 최종 실행 모듈을 생성하는 데 필요한 정보를 참조할 수 있게 되요.</p>
<h4 id="IMAGE-SCN-LNK-INFO"><a href="#IMAGE-SCN-LNK-INFO" class="headerlink" title="IMAGE_SCN_LNK_INFO"></a>IMAGE_SCN_LNK_INFO</h4><p>해당 섹션이 링커에 의해 사용될 주석이나 다른 어떤 종류의 정보를 가져요. 이 섹션의 전형적인 예는 컴파일러에 의해 생성되며 링커를 위한 명령을 담고 있는 .drectve 섹션이에요.</p>
<h4 id="IMAGE-SCN-LNK-REMOVE"><a href="#IMAGE-SCN-LNK-REMOVE" class="headerlink" title="IMAGE_SCN_LNK_REMOVE"></a>IMAGE_SCN_LNK_REMOVE</h4><p>이 플래그는 링크 시에 최종 실행 파일의 일부가 되지 말아야 할 섹션의 내용들을 지시해요. 이 섹션들은 링커에게 정보를 넘겨주기 위한 컴파일러나 어셈블러에 의해 사용되요.</p>
<h4 id="IMAGE-CSCN-LNK-COMDAT"><a href="#IMAGE-CSCN-LNK-COMDAT" class="headerlink" title="IMAGE_CSCN_LNK_COMDAT"></a>IMAGE_CSCN_LNK_COMDAT</h4><p>해당 섹션의 내용은 공용 데이터라는 것을 의미해요. 이것은 COMDATA 라고 하는데, 공용 데이터나 코드 플래그는 여러 OBJ 파일에 걸쳐서 정의될 수 있어요. 링커는 실행 파일로 포함시키기 위해 하나의 복사본을 선택할 수 있어요.<br>COMDATA는 C++ 템플릿 함수와 함수 레벨 링킹을 지원하는데 매우 중요한 녀석이에요.</p>
<br>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Default alignemnt if no others are sepcifed.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SCN_ALIGN_1BYTES 0x00100000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SCN_ASLIGN_2BYTES 0x00200000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SCN_ALIGN_4BYTES 0x00300000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SCN_ALIGN_8BYTES 0x00400000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SCN_ALIGN_8192BYTES 0x00E00000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SCN_ALIGN_MASK 0x00F00000</span></span><br></pre></td></tr></table></figure>

<p>위의 매크로들은 생성된 실행 파일 내의 해당 섹셔의 데이터 정렬 단위를 나타내는 플래그이며, OBJ 파일 내에서만 셋팅되요.</p>
<h4 id="IMAGE-SCN-ALIGN-XBYTES"><a href="#IMAGE-SCN-ALIGN-XBYTES" class="headerlink" title="IMAGE_SCN_ALIGN_XBYTES"></a>IMAGE_SCN_ALIGN_XBYTES</h4><p>_XBYTES의 값으로 1BYT부터 8192BYTE 까지의 정렬 단위를 사타내요. 특별히 지정되지 않으면 디폴트로 16BYTE에 해당하는 IMAGE_SCN_ALIGN_16BYTES가 되고 이 값은 0x00500000 이에요.</p>
<br>

<h3 id="마지막으로…"><a href="#마지막으로…" class="headerlink" title="마지막으로…"></a>마지막으로…</h3><p>IMAGE_SECTION_HEADER에 있는 멤버들 중, <strong>VirtualSize, VirtualAddress, SizeOfRawData, PointerToRawData, Characteristics</strong> 멤버에 대해서는 확실하게 알아야 해요.</p>
<p>이 멤버들을 이용해서 메모리의 속성이 어떤지 파악할 수 있고, 어떤 부분이 데이터들이 저장되어 있는지 알 수 있거든요. 이 부분을 알아야지 우리가 필요한 데이터들을 찾을 수 있어요.</p>
<br>

<p>PE 파일에서 각 섹션의 실제 내용을 확인하고자 한다면 PointerToRawData가 가리키는 위치로 파일 오프셋을 이동시키고, 그곳에서부터 SizeOfRawData의 바이트 수만큼이 해당 섹션의 실제 내용이 되요.<br>이 섹션이 실제로 가상 주소 공간에 매핑되었을 때의 RVA가 VirtualAddress가 되며 매핑된 후의 <strong>섹션의 실제 시작 포인터를 얻고자 한다면 VirtualAddress 값에다가 IMAGE_OPTIONAL_HEADER의 ImageBase 필드 값을 더하면 되요.</strong> 그리고 매핑된 후에 이 섹션이 차지하고 있는 메모리 상의 크기는 VirtualSize에 명시되어 있어요.</p>
<p>일반적으로 포함되어 있는 섹션의 Charateristics 값을 한번 살펴봐요.</p>
<h4 id="textbss의-속성"><a href="#textbss의-속성" class="headerlink" title=".textbss의 속성"></a>.textbss의 속성</h4><ul>
<li>.textbss -&gt; 0xE0000000<ul>
<li>IMAGE_SCN_MEM__EXECUTE -&gt; 0x20000000</li>
<li>IMAGE_SCN_MEM_READ -&gt; 0x40000000</li>
<li>IMAGE_SCN_MEM_WRITE -&gt; 0x80000000</li>
<li>IMAGE_SCN_CNT_CODE -&gt; 0x00000020</li>
<li>IMAGE_SCN_CNT_UNINITALIZED_DATA -&gt; 0x00000080</li>
</ul>
</li>
</ul>
<p>.textbss 섹션은 코드 섹션과 초기화되지 않은 데이터가 있는 .bss 섹션이 혼합되어 있다는 것을 알 수 있어요. 그래서 메모리 속성으로는 실행, 읽기, 쓰기 속성이 지정되어 있고, 컨테이터 속성 중에서는 코드 속성과 초기화되지 않는 데이터 속성이 지정되어 있죠.</p>
<h4 id="text의-속성"><a href="#text의-속성" class="headerlink" title=".text의 속성"></a>.text의 속성</h4><ul>
<li>.text -&gt; 0x60000020<ul>
<li>IMAGE_SCN_MEM_EXECUTE -&gt; 0x20000000</li>
<li>IMAGE_SCN_MEM_READ -&gt; 0x40000000</li>
<li>IMAGE_SCN_CNT_CODE -&gt; 0x00000020</li>
</ul>
</li>
</ul>
<p>이 섹션은 코드 섹션으로서 전형적인 콛그 섹션의 속성만을 가지고 있어요. 메모리 속성으로는 실행과 읽기 속성을 가지며 컨테이너 속성으로는 코드 속성을 가져요.</p>
<h4 id="rdata의-속성"><a href="#rdata의-속성" class="headerlink" title=".rdata의 속성"></a>.rdata의 속성</h4><ul>
<li>.rdata -&gt; 0x40000040<ul>
<li>IMAGE_SCN_MEM_READ -&gt; 0x40000000</li>
<li>IMAGE_SCN_CNT_INITIALIZED_DATA -&gt; 0x00000040</li>
</ul>
</li>
</ul>
<p>이 섹션은 읽기 전용 데이터 섹션이에요. 따라서 메모리 속성은 읽기 속성만 가지며 컨테이너 속성으로는 초기화된 데이터 속성을 가져요.</p>
<h4 id="data-idata의-속성"><a href="#data-idata의-속성" class="headerlink" title=".data, .idata의 속성"></a>.data, .idata의 속성</h4><ul>
<li>.data, .idata -&gt; 0xC0000040<ul>
<li>IMAGE_SCN_MEM_READ -&gt; 0x40000000</li>
<li>IMAGE_SCN_MEM_WRITE -&gt; 0x80000000</li>
<li>IMAGE_SCN_CNT_INITIALIZED_DATA -&gt; 0x00000040</li>
</ul>
</li>
</ul>
<p>.data 섹션은 전형적인 데이터 섹션이에요. 그래서 읽기 쓰기가 가능하며, 초기화된 전역 변수들은 모두 이 섹션에 자리를 잡아요. 따라서 메모리 속성은 읽기, 쓰기 속성이 모두 지정되어 있으며 컨테이너 속성은 초기화된 데이터 속성이에요.</p>
<p>.idata 섹션은 임포트된 DLL과 그 함수들에 대한 정보를 담고 있는 섹션이에요. 따라서 프로그램 로드 시에 로더는 이 섹션을 참조하여 해당 DLL을 메모리에 매핑을 시켜요. 그렇기 때문에 당연히 메모리 속성은 읽기 속성을 가져야 해요. 그리고 이 정보는 링크 시에 정해지기 때문에 초기화된 데이터 컨테이너 속성을 가질 수밖에 없어요.</p>
<p>하지만 임포트 섹션은 왜 쓰기 속성을 가질까요? 그 이유는 로더가 DLL을 로드한 후에 이 섹션에 존재하는 DLL에 속하는 임포트 함수에 대한 함수 포인터를 임포트 주소 테이블(IAT)라고 하는 곳에 저장하기 떄문이에요.</p>
<p>임포트 주소 테이블(IAT)이 임포트 섹션 내에 존재하기 때문에 임포트 섹션은 쓰기 속성을 가져야만 하고, 임포트 함수를 사용할 때 임포트 주소 테이블(IAT)를 통해서 함수의 포인터를 얻어서 사용해요.</p>
<br>
<br>
<br>
<br>
<br>

<h2 id="참고자료"><a href="#참고자료" class="headerlink" title="참고자료"></a>참고자료</h2><hr>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_section_header" target="_blank" rel="noopener">IMAGE_SECTION_HEADER</a></p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://777bareman777.github.io/2019/09/19/UnderstandPE5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="777bareman777">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="777bareman777 Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/09/19/UnderstandPE5/" class="post-title-link" itemprop="url">PE 구조 이해하기 - IMAGE_DATA_DIRECTORY 구조</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-09-19 16:33:57" itemprop="dateCreated datePublished" datetime="2019-09-19T16:33:57+09:00">2019-09-19</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-09-24 09:13:36" itemprop="dateModified" datetime="2019-09-24T09:13:36+09:00">2019-09-24</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/PE-file/" itemprop="url" rel="index"><span itemprop="name">PE file</span></a></span>

                
                
              
            </span>
          

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
        
      
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2019/09/19/UnderstandPE5/#comments" itemprop="discussionUrl"><span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/09/19/UnderstandPE5/" itemprop="commentCount"></span></a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>windows 시스템 실행파일의 구조와 원리 책 내용을 요약 및 정리 하는 포스팅이에요.</p>
<p>주요 섹션들과 정보들의 위치와 크기를 나타내는 <strong>IMAGE_DATA_DIRECTORAY</strong>에 대한 내용을 알아볼 거에요.</p>
<br>

<h2 id="IMAGE-DATA-DIRECTORY의-시작"><a href="#IMAGE-DATA-DIRECTORY의-시작" class="headerlink" title="IMAGE_DATA_DIRECTORY의 시작"></a>IMAGE_DATA_DIRECTORY의 시작</h2><p><strong>이 구조체에는 주요 섹션들과 정보들의 위치와 크기를 나타내는 값들이 저장되어 있어요.</strong><br>구조체 배열의 크기에 대한 값이 <strong>매크로 상수 값(IMAGE_UNMBEROF_DIRECTROY_ENTRIES)</strong>으로 지정이 되어 있지만, 공식 문서에서는 항상 16개로 고정되어 있지 않다고해요.<br>따라서 <strong>IMAGE_DATA_DIRECTORY 구조체의 배열의 개수를 알기 위해서는 IMAGE_OPTIONAL_HEADER 구조체의 NumberOfRvaAndSizes 멤버를 확인</strong>해야 되요.</p>
<br>

<p>지금은 16개로 고정되있다고 생각을 할게요!<br>16개가 있다면 이 구조체는 128바이트로 이루어진 구조체 배열이에요.<br>그리고 이 배열의 마지막 엔트리, 인덱스 15에 해당하는 엔트리는 언제나 0으로 세팅되야 한다고 해요.</p>
<p>즉, <strong>배열의 인덱스 0부터 NumberOfRvaSizes-1까지의 인덱스가 지정하는 필드가 모두 사용되는 것이 아니라 마지막에 해당하는 인덱스를 제외하고 사용하는 거죠.</strong></p>
<p>각 엔트리들은 나름대로의 의미를 가지고 있고요. 특히 <strong>병합된 섹션과 관련된 정보가 엔트리에 들어가기 때문이에요. 그래서 이 필드는 반드시 참조해야 하는 영역입니다.</strong></p>
<p>각 배열의 엔트리의 의미는 이것 또한 “WinNT.h” 헤더 파일에 정의되어 있어요.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_UNMBEROF_DIRECTORAY_ENTRIES 16</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_DATA_DIRECTORY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	DWORD VirtualAddress;</span><br><span class="line">	DWORD Size;</span><br><span class="line">&#125; IMAGE_DATA_DIRECTROY, *PIMAGE_DATA_DIRECTROY:</span><br></pre></td></tr></table></figure>

<p><strong>VirtualAddress 와 Size는 각각 해당 IMAGE_DATA_DIRECTORY_ENTRY의 인덱스에 해당하는 미리 지정된 섹션 또는 블록의 정보에 대한 시작 주소와 그 크기를 가리키는 RVA</strong> 이에요.</p>
<p>예를 들면, 인덱스 0번은 Export Directory(내보내기 함수 테이블)에 대한 RVA와 크기이고, Import Directory(가져오기 함수 테이블)에 대한 RVA와 크기에요.</p>
<br>

<h2 id="IMAGE-DATA-DIRECTORY-ENTRY의-종류"><a href="#IMAGE-DATA-DIRECTORY-ENTRY의-종류" class="headerlink" title="IMAGE_DATA_DIRECTORY_ENTRY의 종류"></a>IMAGE_DATA_DIRECTORY_ENTRY의 종류</h2><p>이것 또한 각 인덱스의 의미는 “WinNT.h” 헤더 파일에 정의되어 있죠.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Directory Entries</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_EXPORT          0   <span class="comment">// Export Directory</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_IMPORT          1   <span class="comment">// Import Directory</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_RESOURCE        2   <span class="comment">// Resource Directory</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_EXCEPTION       3   <span class="comment">// Exception Directory</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_SECURITY        4   <span class="comment">// Security Directory</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_BASERELOC       5   <span class="comment">// Base Relocation Table</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_DEBUG           6   <span class="comment">// Debug Directory</span></span></span><br><span class="line"><span class="comment">//      IMAGE_DIRECTORY_ENTRY_COPYRIGHT       7   // (X86 usage)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_ARCHITECTURE    7   <span class="comment">// Architecture Specific Data</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_GLOBALPTR       8   <span class="comment">// RVA of GP</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_TLS             9   <span class="comment">// TLS Directory</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG    10   <span class="comment">// Load Configuration Directory</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT   11   <span class="comment">// Bound Import Directory in headers</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_IAT            12   <span class="comment">// Import Address Table</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT   13   <span class="comment">// Delay Load Import Descriptors</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR 14   <span class="comment">// COM Runtime descriptor</span></span></span><br></pre></td></tr></table></figure>

<br>

<h3 id="0번-인덱스-IMAGE-DIRECTORY-ENTRY-EXPORT"><a href="#0번-인덱스-IMAGE-DIRECTORY-ENTRY-EXPORT" class="headerlink" title="0번 인덱스, IMAGE_DIRECTORY_ENTRY_EXPORT"></a>0번 인덱스, IMAGE_DIRECTORY_ENTRY_EXPORT</h3><p>익스포트 테이블(Export Directory Table), IMAGE_EXPORT_DIRECTORY 구조체의 시작 번지를 가리켜요. 이 시작 번지가 <strong>익스포트 섹션의 시작 주소</strong>에요.</p>
<br>

<h3 id="1번-인덱스-IMAGE-DIRECTORY-ENTRY-IMPORT"><a href="#1번-인덱스-IMAGE-DIRECTORY-ENTRY-IMPORT" class="headerlink" title="1번 인덱스, IMAGE_DIRECTORY_ENTRY_IMPORT"></a>1번 인덱스, IMAGE_DIRECTORY_ENTRY_IMPORT</h3><p>임포트 테이블(Import Directory Table), IMAGE_IMPORT_DESCRIPTOR 구조체 배열의 번지를 가리켜요. 이 시작 번지가 <strong>임포트 섹션의 시작 주소</strong>에요.</p>
<br>

<h3 id="2번-인덱스-IMAGE-DIRECTORY-ENTRY-RESOURCE"><a href="#2번-인덱스-IMAGE-DIRECTORY-ENTRY-RESOURCE" class="headerlink" title="2번 인덱스, IMAGE_DIRECTORY_ENTRY_RESOURCE"></a>2번 인덱스, IMAGE_DIRECTORY_ENTRY_RESOURCE</h3><p>리소스, IMAGE_RESOURCE_DIRECTORY 구조체의 시작 번지를 가리켜요. 이 시작 번지가 <strong>리소스 섹션의 시작 주소</strong>에요.</p>
<br>

<h3 id="3번-인덱스-IMAGE-DIRECTORY-ENTRY-EXCEPTION"><a href="#3번-인덱스-IMAGE-DIRECTORY-ENTRY-EXCEPTION" class="headerlink" title="3번 인덱스, IMAGE_DIRECTORY_ENTRY_EXCEPTION"></a>3번 인덱스, IMAGE_DIRECTORY_ENTRY_EXCEPTION</h3><p><strong>예외 핸들러 테이블(Exception Directory Table), IMAGE_RUNTIME_FUNCTION_ENTRY 구조체 배열의 시작 번지</strong>를 가리켜요. CPU에 의존적이고, 테이블 기반 예외 핸들링을 위한 것이죠. x86 계열을 제외한 모든 CPU상에서 사용되는데, X86 기반의 윈도우 PE 파일에서는 의미가 없는 영역이에요.</p>
<p><strong>IA-64 CPU, 64비트 CPU에서는 사용</strong>하는 영역인거죠!!</p>
<br>

<h3 id="4번-인덱스-IMAGE-DIRECTORY-ENTRY-SECURITY"><a href="#4번-인덱스-IMAGE-DIRECTORY-ENTRY-SECURITY" class="headerlink" title="4번 인덱스, IMAGE_DIRECTORY_ENTRY_SECURITY"></a>4번 인덱스, IMAGE_DIRECTORY_ENTRY_SECURITY</h3><p><strong>“WinTrust.h” 헤더 파일에 정의되어 있는 WIN_CRETIFICATEW 구조체들의 리스트 시작 번지</strong>를 가리켜요.<br>이 리스트는 메모리 상에 매핑되지 않기 때문에 <strong>VirtualAddress 필드 값</strong>은 RVA가 아니라 <strong>파일 오프셋</strong>에 해당되요.</p>
<br>

<h3 id="5번-인덱스-IMAGE-DIRECTORY-ENTRY-BASERELOC"><a href="#5번-인덱스-IMAGE-DIRECTORY-ENTRY-BASERELOC" class="headerlink" title="5번 인덱스, IMAGE_DIRECTORY_ENTRY_BASERELOC"></a>5번 인덱스, IMAGE_DIRECTORY_ENTRY_BASERELOC</h3><p><strong>기본 재배치(Base Relocation) 정보</strong>를 가리켜요.</p>
<p><strong>재배치</strong>는 무엇일까요?<br>로더가 실행 모듈을 원하는 위치, 즉 IMAGE_OPTIONAL_HEADER의 <strong>ImageBase 필드에 지정된 가상 주소 공간의 주소에 위치시키지 못했을 때 코드 상의 포인터 연산과 관련된 주소를 다시 갱신해야 하는 경우</strong>를 재배치 라고 불러요!</p>
<p>저번에 말했듯이 EXE의 경우에는 이런 상황이 거의 없어요. 그 이유는 EXE 파일보다 DLL이 먼저 메모리에 로딩되기 때문이에요. 그에 반면 DLL의 경우에는 빈번히 발생하죠.<br>이를 위해 재배치 섹셔이 존재하는데, 이 필드가 재배치 섹션의 시작 주소를 가리켜요.</p>
<br>

<h3 id="6번-인덱스-IMAGE-DIRECTORY-ENTRY-DEBUG"><a href="#6번-인덱스-IMAGE-DIRECTORY-ENTRY-DEBUG" class="headerlink" title="6번 인덱스, IMAGE_DIRECTORY_ENTRY_DEBUG"></a>6번 인덱스, IMAGE_DIRECTORY_ENTRY_DEBUG</h3><p><strong>IMAGE_DEBUG_DIRECTORY 구조체의 배열을 가리키는 번지</strong>에요.<br>각각 해당 <strong>이미지의 디버그 정보를 가지고 있죠.</strong></p>
<p>초기 볼랜드 링커의 경우 이 인덱스에 해당하는 IMAGE_DATA_DIRECTORY 엔트리의 Size 필드를 이 섹션의 바이트 수가 아니라 구조체의 수로 세트했다고 해요.</p>
<p>물론 지금은 섹션의 크기를 가지고 있어요!<br>따라서 IMAGE_DEBUG_DIRECTORY 구조체의 수를 얻기 위해서는 Size 필드의 값을 IMAGE_DEBUG_DIRECTORY 구조체의 바이트 수(28 바이트)로 나누면 되요.</p>
<br>

<h3 id="7번-인덱스-IMAGE-DIRECTORY-ENTRY-ARCHITECTURE"><a href="#7번-인덱스-IMAGE-DIRECTORY-ENTRY-ARCHITECTURE" class="headerlink" title="7번 인덱스, IMAGE_DIRECTORY_ENTRY_ARCHITECTURE"></a>7번 인덱스, IMAGE_DIRECTORY_ENTRY_ARCHITECTURE</h3><p><strong>아키텍처에 대한 구체적인 데이터, IMAGE_ARCHITECTURE_HEADER 구조체의 배열에 대한 시작 번지</strong>를 가리켜요.</p>
<p>X86 또는 IA-64 계열에서는 사용하지 않아요.<br>애초에 인텔 계열 CPU를 위해 만들어진 운영체제 이기 때문에 아키텍처에 대한 구체적인 데이터가 필요가 없는거죠!</p>
<br>

<h3 id="8번-인덱스-IMAGE-DIRECTORY-ENTRY-GLOBALPTR"><a href="#8번-인덱스-IMAGE-DIRECTORY-ENTRY-GLOBALPTR" class="headerlink" title="8번 인덱스, IMAGE_DIRECTORY_ENTRY_GLOBALPTR"></a>8번 인덱스, IMAGE_DIRECTORY_ENTRY_GLOBALPTR</h3><p><strong>글로벌 포인터 레지스터(GP, Global Pointer)로 사용되는 시작 번지</strong>를 가리켜요.<br>x86에서는 사용되지 않지만, IA-64 에서는 사용되요.<br>여기서 Size 필드는 필요가 없어요. 사용되지 않아요.</p>
<br>

<h3 id="9번-인덱스-IMAGE-DIRECTORY-ENTRY-TLS"><a href="#9번-인덱스-IMAGE-DIRECTORY-ENTRY-TLS" class="headerlink" title="9번 인덱스, IMAGE_DIRECTORY_ENTRY_TLS"></a>9번 인덱스, IMAGE_DIRECTORY_ENTRY_TLS</h3><p><strong>스레드 지역 저장소 초기화 섹션에 대한 시작 번지</strong>를 가리켜요.<br>별도의 TLS 함수를 사용하지 않고 __declspec(thread)라는 지시어를 통해 변수가 선언되면 이 변수는 TLS에 들어가게 되고 이를 위해 링커는 별도의 TLS 섹션을 만들게 되죠.</p>
<br>

<h3 id="10번-인덱스-IMAGE-DIRECTROY-ENTRY-LOAD-CONFIG"><a href="#10번-인덱스-IMAGE-DIRECTROY-ENTRY-LOAD-CONFIG" class="headerlink" title="10번 인덱스, IMAGE_DIRECTROY_ENTRY_LOAD_CONFIG"></a>10번 인덱스, IMAGE_DIRECTROY_ENTRY_LOAD_CONFIG</h3><p><strong>IMAGE_LOAD_CONFIG_DIRECTORY 구조체애 대한 시작 번지</strong>를 가리켜요.<br>Windows NT, Windows 2000, Windows XP의 구체적인 정보가 들어가 있다고해요.</p>
<p>이 구조체를 실행 파일에 집어 넣으러면 IMAGE_LOAD_CONFIG_DIRECTORY 구조체를 _load_config_used라는 이름으로 전역적으로 정의 해야 한다고 해요</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">extern <span class="string">"C"</span></span><br><span class="line"></span><br><span class="line"><span class="type">IMAGE_LOAD_CONFIG_DIRECTORY</span> __load_config_used = <span class="meta">&#123;...&#125;</span>;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="11번-인덱스-IMAGE-DIRECTORY-ENTRY-BOUND-IMPORT"><a href="#11번-인덱스-IMAGE-DIRECTORY-ENTRY-BOUND-IMPORT" class="headerlink" title="11번 인덱스, IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT"></a>11번 인덱스, IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT</h3><p><strong>IMAGE_BOUND_IMPORT_DESCRIPTOR 구조체 배열에 대한 시작 번지</strong>를 가리켜요.<br><strong>DLL 바인딩과 관련된 정보</strong>를 가리켜요.</p>
<p>이 필드도 중요한 녀석이죠! 나중에 더 상세하게 다룰 예정입니다!</p>
<br>

<h3 id="12번-인덱스-IMAGE-DIRECTORY-ENTRY-IAT"><a href="#12번-인덱스-IMAGE-DIRECTORY-ENTRY-IAT" class="headerlink" title="12번 인덱스, IMAGE_DIRECTORY_ENTRY_IAT"></a>12번 인덱스, IMAGE_DIRECTORY_ENTRY_IAT</h3><p><strong>첫 번째 임포트 주소 테이블(IAT, Import Address Table)의 시작 번지</strong>를 가리켜요.<br>임포트된 각각의 DLL에 대한 IAT는 메모리 상에서 연속적으로 나타나게 되요.<br>Size 필드는 모든 IAT의 전체 크기를 가리켜요.</p>
<p>로더는 임포트 섹션을 해석할 동안 이 엔트리의 주소와 크기를 이용해서 임시적으로 IAT들을 읽기/쓰기 모드로 마킹한다고 해요.</p>
<br>

<h3 id="13번-인덱스-IMAGE-DIRECTORY-ENTRY-DELAY-IMPORT"><a href="#13번-인덱스-IMAGE-DIRECTORY-ENTRY-DELAY-IMPORT" class="headerlink" title="13번 인덱스, IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT"></a>13번 인덱스, IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT</h3><p>Visual C++ 이 제공하는 DELAYTMP.H 헤더 파일에 정의되어 있는 <strong>ImgDelayDescr 구조체의 배열을 가리키는 시작 번지</strong>에요.</p>
<p><strong>지연 로딩 DLL은 해당 API가 처음으로 호출되기 전까지 로드되지 않아요.</strong><br>윈도우는 지연 로딩 DLL에 대한 어떠한 암시적인 정보고 가지고 있지 않아요.<br>전적으로 지연 로딩의 정보는 링커나 런타임 라이브러리에 구현되어 있죠.</p>
<br>

<h3 id="14번-인덱스-IMAGE-DIRECTORY-ENTRY-COM-DESCRIPTOR"><a href="#14번-인덱스-IMAGE-DIRECTORY-ENTRY-COM-DESCRIPTOR" class="headerlink" title="14번 인덱스, IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR"></a>14번 인덱스, IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR</h3><p>업데이트된 시스템 헤더 파일에 IMAGE_DIRECTORY_ENTRY_COMHEADER 라는 이름으로 변경되었다고 해요.</p>
<p>이 필드의 정보는 .NET 응용 애플리케이션이나 DLL용 PE를 위한 거라고 해요.<br>PE 내의 .NET 정보에 대한 최상위 정보의 시작 번지를 가리킨다고 해요.</p>
<p>이 정보 같은 경우에는 IMAGE_COR20_HEADER 구조체의 형태로 구성되었다고 합니다.</p>
<br>

<h2 id="마지막으로…"><a href="#마지막으로…" class="headerlink" title="마지막으로…"></a>마지막으로…</h2><p>모두 다 알면 좋겠지만, <strong>Export Directory, Import Directory, Exception Directory, Base Relocation Table, Bound Import Directory, Import Address Table(IAT), Delay Load Import Descriptors</strong>에 해당 하는 섹션들은 확실하게 공부를 해야한다고 생각을 합니다!</p>
<br>
<br>
<br>
<br>
<br>

<h2 id="참고자료"><a href="#참고자료" class="headerlink" title="참고자료"></a>참고자료</h2><hr>
<p><a href="https://docs.microsoft.com/ko-kr/windows/win32/api/winnt/ns-winnt-image_data_directory" target="_blank" rel="noopener">IMAGE_DATA_DIRECTORY</a></p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://777bareman777.github.io/2019/09/18/UnderstandPE4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="777bareman777">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="777bareman777 Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/09/18/UnderstandPE4/" class="post-title-link" itemprop="url">PE 구조 이해하기 - IMAGE_OPTIONAL_HEADER 구조</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-09-18 14:46:56" itemprop="dateCreated datePublished" datetime="2019-09-18T14:46:56+09:00">2019-09-18</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-09-24 09:13:27" itemprop="dateModified" datetime="2019-09-24T09:13:27+09:00">2019-09-24</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/PE-file/" itemprop="url" rel="index"><span itemprop="name">PE file</span></a></span>

                
                
              
            </span>
          

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
        
      
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2019/09/18/UnderstandPE4/#comments" itemprop="discussionUrl"><span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/09/18/UnderstandPE4/" itemprop="commentCount"></span></a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>windows 시스템 실행파일의 구조와 원리 책 내용을 요약 및 정리 하는 포스팅이에요.</p>
<p>PE파일의 PE 시그니처 다음에 이어지는 <strong>IMAGE_OPTIONAL_HEADER</strong>에 대한 내용을 알아볼 거에요.</p>
<br>

<h2 id="IMAGE-OPTIONAL-HEADER의-시작"><a href="#IMAGE-OPTIONAL-HEADER의-시작" class="headerlink" title="IMAGE_OPTIONAL_HEADER의 시작"></a>IMAGE_OPTIONAL_HEADER의 시작</h2><p>IMAGE_FILE_HEADER에 이어서 나오는 구조체는 <strong>224바이트</strong>로 구성된 <strong>IMAGE_OPTIONAL_HEADER</strong> 이에요.</p>
<p>IMAGE_OPTIONAL_HEADER 구조체는 <strong>96바이트를 차지하는 30개의 기본 필드</strong>와 <strong>8바이트 크기의 IMAGE_DATA_DIRECTORY 구조체에 대한 엔트리 개수가 16개인 배열 128(=8*16)바이트</strong>로 구성되어 있어요.</p>
<p>-&gt; IMAGE_OPTIONAL_HEADER32 구조체를 가지고 설명. </p>
<p>-&gt; 64비트 같은 경우에는 BaseOfData 부분이 없으며, 메모리 영역 부분이 DWORD 형이 아닌 ULONGLONG 형으로 선언이 되어있고, 데이터 디렉토리 구조체의 크기가 고정되어 있지 않음.</p>
<p>구조체는 다음과 같이 “WinNT.h” 헤더 파일에 정의되어 있음.</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _IMAGE_OPTIONAL_HEADER &#123;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">		<span class="type">Standard</span> fields.</span><br><span class="line">	*/</span><br><span class="line"></span><br><span class="line">  <span class="type">WORD</span>                 <span class="type">Magic</span>;</span><br><span class="line">  <span class="type">BYTE</span>                 <span class="type">MajorLinkerVersion</span>;</span><br><span class="line">  <span class="type">BYTE</span>                 <span class="type">MinorLinkerVersion</span>;</span><br><span class="line">  <span class="type">DWORD</span>                <span class="type">SizeOfCode</span>;</span><br><span class="line">  <span class="type">DWORD</span>                <span class="type">SizeOfInitializedData</span>;</span><br><span class="line">  <span class="type">DWORD</span>                <span class="type">SizeOfUninitializedData</span>;</span><br><span class="line">  <span class="type">DWORD</span>                <span class="type">AddressOfEntryPoint</span>;</span><br><span class="line">  <span class="type">DWORD</span>                <span class="type">BaseOfCode</span>;</span><br><span class="line">  <span class="type">DWORD</span>                <span class="type">BaseOfData</span>;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">		<span class="type">NT</span> additional fields.</span><br><span class="line">	*/</span><br><span class="line"></span><br><span class="line">  <span class="type">DWORD</span>                <span class="type">ImageBase</span>;</span><br><span class="line">  <span class="type">DWORD</span>                <span class="type">SectionAlignment</span>;</span><br><span class="line">  <span class="type">DWORD</span>                <span class="type">FileAlignment</span>;</span><br><span class="line">  <span class="type">WORD</span>                 <span class="type">MajorOperatingSystemVersion</span>;</span><br><span class="line">  <span class="type">WORD</span>                 <span class="type">MinorOperatingSystemVersion</span>;</span><br><span class="line">  <span class="type">WORD</span>                 <span class="type">MajorImageVersion</span>;</span><br><span class="line">  <span class="type">WORD</span>                 <span class="type">MinorImageVersion</span>;</span><br><span class="line">  <span class="type">WORD</span>                 <span class="type">MajorSubsystemVersion</span>;</span><br><span class="line">  <span class="type">WORD</span>                 <span class="type">MinorSubsystemVersion</span>;</span><br><span class="line">  <span class="type">DWORD</span>                <span class="type">Win32VersionValue</span>;</span><br><span class="line">  <span class="type">DWORD</span>                <span class="type">SizeOfImage</span>;</span><br><span class="line">  <span class="type">DWORD</span>                <span class="type">SizeOfHeaders</span>;</span><br><span class="line">  <span class="type">DWORD</span>                <span class="type">CheckSum</span>;</span><br><span class="line">  <span class="type">WORD</span>                 <span class="type">Subsystem</span>;</span><br><span class="line">  <span class="type">WORD</span>                 <span class="type">DllCharacteristics</span>;</span><br><span class="line">  <span class="type">DWORD</span>                <span class="type">SizeOfStackReserve</span>;</span><br><span class="line">  <span class="type">DWORD</span>                <span class="type">SizeOfStackCommit</span>;</span><br><span class="line">  <span class="type">DWORD</span>                <span class="type">SizeOfHeapReserve</span>;</span><br><span class="line">  <span class="type">DWORD</span>                <span class="type">SizeOfHeapCommit</span>;</span><br><span class="line">  <span class="type">DWORD</span>                <span class="type">LoaderFlags</span>;</span><br><span class="line">  <span class="type">DWORD</span>                <span class="type">NumberOfRvaAndSizes</span>;</span><br><span class="line">  <span class="type">IMAGE_DATA_DIRECTORY</span> <span class="type">DataDirectory</span>[<span class="type">IMAGE_NUMBEROF_DIRECTORY_ENTRIES</span>];</span><br><span class="line">&#125; <span class="type">IMAGE_OPTIONAL_HEADER32</span>, *<span class="type">PIMAGE_OPTIONAL_HEADER32</span>;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="첫-번째-멤버-WORD-Magic"><a href="#첫-번째-멤버-WORD-Magic" class="headerlink" title="첫 번째 멤버, WORD Magic"></a>첫 번째 멤버, WORD Magic</h3><p>IMAGE_OPTIONAL_HEADER를 나타내는 <strong>시그니처</strong>에요. 이 값은 3<strong>2비트 PE의 경우 0x010B</strong>이고, <strong>64비트 PE의 경우 0x020B</strong>에요.<br>닷넴 프레임워크 .NET PE의 경우 항상 0x010B 라고 해요.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_NT_OPTIONAL_HDR32 0x10B</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_NT_OPTIONAL_HDR64_MAGIC 0x20B</span></span><br></pre></td></tr></table></figure>

<br>

<h3 id="두-번째-멤버-BYTE-MajorLinkerVersion"><a href="#두-번째-멤버-BYTE-MajorLinkerVersion" class="headerlink" title="두 번째 멤버, BYTE MajorLinkerVersion"></a>두 번째 멤버, BYTE MajorLinkerVersion</h3><h3 id="세-번째-멤버-BYTE-MinorLinkerVersion"><a href="#세-번째-멤버-BYTE-MinorLinkerVersion" class="headerlink" title="세 번째 멤버, BYTE MinorLinkerVersion"></a>세 번째 멤버, BYTE MinorLinkerVersion</h3><p>P<strong>E 파일을 만들어낸 링커의 버전</strong>을 나타내요.<br>예를 드러 메이저 0x09, 마이너 0x0A라면 링커 버전 9.10을 나타내는 거죠.</p>
<p>“Visual Studio.NET Command Prompt”를 실행시켜 Link.exe를 실행시키면 링커의 버전을 확인할 수 있다고 해요.</p>
<br>

<h3 id="네-번째-멤버-DWORD-SizeOfCode"><a href="#네-번째-멤버-DWORD-SizeOfCode" class="headerlink" title="네 번째 멤버, DWORD SizeOfCode"></a>네 번째 멤버, DWORD SizeOfCode</h3><p><strong>모든 코드 섹션들의 사이즈를 합한 라운드업된 크기</strong>에요.<br>일반적으로 실행 파일은 하나의 코드 섹션을 가지기 때문에 이 필드는 .text 섹션의 바이트 수와 동일해요.</p>
<p><strong>정확하게 말하면, 섹션 중 “IMAGE_SCN_CNT_CODE” 속성을 가진 섹션들의 전체 크기</strong>라고 해요.<br>이러한 속성들은 IMAGE_SECTION_HEADER의 Characteristics에서 찾아볼 수 있어요.</p>
<br>

<h3 id="다섯-번째-멤버-DWORD-SizeOfInitializeData"><a href="#다섯-번째-멤버-DWORD-SizeOfInitializeData" class="headerlink" title="다섯 번째 멤버, DWORD SizeOfInitializeData"></a>다섯 번째 멤버, DWORD SizeOfInitializeData</h3><p><strong>코드 섹션을 제외한 초기화된 데이터 섹션의 전체 크기</strong>를 나타내요.<br><strong>초기화된 데이터 섹션은 “IMAGE_SCN_CNT_INITALIZED_DATA” 속성</strong>을 가져요.</p>
<br>

<h3 id="여섯-번째-멤버-DWORD-SizeOfUninitializedData"><a href="#여섯-번째-멤버-DWORD-SizeOfUninitializedData" class="headerlink" title="여섯 번째 멤버, DWORD SizeOfUninitializedData"></a>여섯 번째 멤버, DWORD SizeOfUninitializedData</h3><p><strong>초기화되지 않은 데이터 섹션(일반적으로 .bss 섹션 또는 .textbss 섹션)의 바이트수</strong>를 나타내요.</p>
<p><strong>초기화되지 않은 데이터 섹션은 “IMAGE_SCN_CNT_UNINITALIZED_DATA” 속성</strong>을 가져요.</p>
<p>일반적으로 초기화되지 않은 데이터를 일반 데이터 섹션에 병합시킬 수 있기 때문에 보통 이 필드의 값은 0이 된다.</p>
<br>

<h3 id="일곱-번째-멤버-DWORD-AddressOfEntryPoint"><a href="#일곱-번째-멤버-DWORD-AddressOfEntryPoint" class="headerlink" title="일곱 번째 멤버, DWORD AddressOfEntryPoint"></a>일곱 번째 멤버, DWORD AddressOfEntryPoint</h3><p><strong>로더가 실행을 시작할 주소</strong>를 나타내요. RVA 형태로 값이 저장되고, 일반적으로 <strong>.text 섹션 내의 특정 번지</strong>가 되요.<br>즉, 이 필드의 값은 <strong>프로그램이 처음으로 실행될 코드를 담고 있는 주소</strong>인 거죠.</p>
<p>좀 더 자세히보면, 프로그램이 로드된 후 이 프로세스의 메인 스레드 문맥(Context)의 EIP/RIP 레지스터가 가질 수 있는 최초의 값이에요.<br>일반적으로 이 <strong>번지가 가리키는 값은 소위 말하는 런타임 시작 루틴(EXE의 경우 WinMainCRTStartup 또는 mainCRTStartup, DLL의 경우 DllMainCRTStartup)의 번지 값</strong>이에요.</p>
<p>AddressOfEntryPoint 멤버는 중요한 필드죠!</p>
<br>

<h3 id="여덟-번째-멤버-DWORD-BaseOfCode"><a href="#여덟-번째-멤버-DWORD-BaseOfCode" class="headerlink" title="여덟 번째 멤버, DWORD BaseOfCode"></a>여덟 번째 멤버, DWORD BaseOfCode</h3><p><strong>첫 번째 코드 섹션이 시작 되는 RVA값</strong>을 가지고 있어요.<br>코드 섹션은 전형적으로 PE 헤더 다음, 데이터 섹션 바로 직전에 있어요.</p>
<p>MS 링커가 만들어내는 EXE의 RVA는 보통 0x1000인데, 이 값은 설정에 따라 바뀔 수 있어요.</p>
<br>

<h3 id="아홉-번째-멤버-DWORD-BaseOfData"><a href="#아홉-번째-멤버-DWORD-BaseOfData" class="headerlink" title="아홉 번째 멤버, DWORD BaseOfData"></a>아홉 번째 멤버, DWORD BaseOfData</h3><p>이론적으로 <strong>메모리에 로드될 때 데이터의 첫 번째 바이트의 RVA</strong>를 가리켜요.<br>그리고 이 필드의 값은 MS의 링커 버전에 따라 다르고, 64비트 PE에서는 없는 멤버에요.</p>
<br>

<h3 id="열-번째-멤버-ImageBase"><a href="#열-번째-멤버-ImageBase" class="headerlink" title="열 번째 멤버, ImageBase"></a>열 번째 멤버, ImageBase</h3><p>해당 <strong>PE가 가상 주소 공간에 매핑될 때, 매핑시키고자 하는 메모리 상의 시작 주소</strong>에요.</p>
<p>그 주소가 사용되고 있지 않으면 로더는 이 멤버가 가리키는 값으로 매핑시키기를 원해요.</p>
<p>만약에 PE 파일이 ImageBase가 가리키는 주소에 로드되면 로더는 기본 재배치를 수행하는 과정을 건너뛸 수 있어요.</p>
<p><strong>EXE에 대해서 이 값은 기본 이미지 베이스의 값은 0x00400000</strong> 이고, <strong>DLL의 경우 이 값은 0x10000000</strong> 이에요. 이 값들은 링크 시 옵션 /BASE를 지정함으로써 변결될 수 있어요.</p>
<h4 id="추가적으로…"><a href="#추가적으로…" class="headerlink" title="추가적으로…"></a>추가적으로…</h4><p>일반적으로 PE 파일이 가상 메모리 공간에 매핑될 때, DLL 파일보다 EXE 파일이 먼저 올라가게 되요. 그래서 EXE 파일이 메모리에 올라갈 때 재배치 과정을 거치지 않아요. 하지만 DLL의 경우에는 그 해당하는 위치가 다른 녀석들이 이미 올라가 있는 경우가 많아서 재배치 과정을 거쳐요.</p>
<p>요즘에는 윈도우의 보호기법 중 하나인 ASLR(Address space layout randomization) 때문에 ImageBase에 있는 주소에 PE 파일들이 매핑되지 않고, 랜덤으로 가상 메모리 공간에 매핑이 되요!</p>
<br> 

<h3 id="열한-번째-멤버-SectionAlignment"><a href="#열한-번째-멤버-SectionAlignment" class="headerlink" title="열한 번째 멤버, SectionAlignment"></a>열한 번째 멤버, SectionAlignment</h3><p><strong>PE 파일이 메모리에 매핑될 때</strong> 각 섹션의 시작 주소는 언제나 이 <strong>SectionAlignment 필드에서 지정된 값의 배수가 되는 가상 주소가 되도록 보장되요.</strong></p>
<p>이러한 제한이 바로 <strong>PE 파일 자체가 메모리 맵 파일</strong>임을 말하고 있는 거에요. </p>
<p>일반적인 파일들은 시스템 페이징 파일을 통해서 메모리에 매핑이 되지만, <strong>PE 파일 경우에 PE 파일 자체가 페이징 파일이 되기 떄문에 섹션의 시작 주소는 항상 메모리 페이지의 배수</strong>이어야 되요.</p>
<p>PE 파일 자체가 메모리 맵 파일이라고 하더라도 <strong>메모리에서 PE 파일에 대한 변조가 일어나더라도 실제 파일에는 영향을 끼치지 않아요.</strong></p>
<p>메모리 속성 중 “<strong>실행 가능</strong>“ 속성을 가지게 되면 이 페이지에 대한 “<strong>쓰기</strong>“ 동작에 대한 파일로의 반영은 “<strong>COW</strong>“ 라는 매커니즘을 통해서 페이지에 데이터를 갱신하게 되면 매핑된 파일로의 반영이 아니라 <strong>해당 데이터를 그 페이지에 갱신하기 직전에 페이지 파일(PageFile.sys)로 복사되어서 백업된 뒤 해당 페이지가 갱신</strong>되요.</p>
<p>따라서 <strong>메모리에 매핑된 PE는 “실행 가능”속성을 지니기 때문에 디스크 상의 해당 PE 자체로의 즉각적인 반영이 이루어지지 않는거죠.</strong></p>
<br>

<h3 id="열두-번째-멤버-FileAlignment"><a href="#열두-번째-멤버-FileAlignment" class="headerlink" title="열두 번째 멤버, FileAlignment"></a>열두 번째 멤버, FileAlignment</h3><p><strong>PE 파일 내에서 섹션들의 정렬 단위</strong>를 나타내요.<br><strong>하드 디스크에 저장된 PE 파일 내의 각각의 섹션을 구성하는 바이너리 데이터들은 FileAlignemnt 필드의 값의 배수</strong>로 시작하도록 보장해요.</p>
<p><strong>이 값이 실질적으로 디스크의 섹터 단위</strong>가 되는거죠.<br>NTFS의 경우 한 섹터는 디폴트로 4K이고, <strong>보통 0x200 아니면 0x100의 값</strong>을 가지고 있어요.<br>MS 링커 버전에 따라 기본 값은 변경이 되고, 무조건 이 값은 2의 멱승이 되어야 해요.</p>
<p><strong>만약 SectionAlignment 필드의 값이 CPU 페이지 사이즈보다 작을 경우 이 필드는 SectionAlignment 필드의 값과 같아야 해요.</strong></p>
<br>

<h3 id="열세-번째-멤버-MajorOperatingSystemVersion"><a href="#열세-번째-멤버-MajorOperatingSystemVersion" class="headerlink" title="열세 번째 멤버, MajorOperatingSystemVersion"></a>열세 번째 멤버, MajorOperatingSystemVersion</h3><h3 id="열네-번째-멤버-MinorOperatingSystemVersion"><a href="#열네-번째-멤버-MinorOperatingSystemVersion" class="headerlink" title="열네 번째 멤버, MinorOperatingSystemVersion"></a>열네 번째 멤버, MinorOperatingSystemVersion</h3><p><strong>PE 파일을 실행하는 데 필요한 운영체제의 최소 버전</strong>을 말해요.<br>Windows 10 기반에서 컴파일과 링킹 과정을 거쳤다고 하더라도, 특정 버전 이상에서만 지원되는 기능 같은 것들을 사용하지 않으면 그 이전 버전에서도 돌아갈 수 있기 때문에 운영체제의 최소 버전 값이 정해져요.</p>
<br>

<h3 id="열다섯-번째-멤버-MajorImageVersion"><a href="#열다섯-번째-멤버-MajorImageVersion" class="headerlink" title="열다섯 번째 멤버, MajorImageVersion"></a>열다섯 번째 멤버, MajorImageVersion</h3><h3 id="열여섯-번째-멤버-MinorImageVersion"><a href="#열여섯-번째-멤버-MinorImageVersion" class="headerlink" title="열여섯 번째 멤버, MinorImageVersion"></a>열여섯 번째 멤버, MinorImageVersion</h3><p>유저가 정의 가능한 필드이며, 사<strong>용자가 만드는 EXE나 DLL에 유저 나름대로의 버전</strong>을 넣을 수 있어요.<br>링킹 시에 /VERSION 옵션을 사용해서 링킹을 해주면 되요.</p>
<br>

<h3 id="열일곱-번째-멤버-MajorSubsystemVersion"><a href="#열일곱-번째-멤버-MajorSubsystemVersion" class="headerlink" title="열일곱 번째 멤버, MajorSubsystemVersion"></a>열일곱 번째 멤버, MajorSubsystemVersion</h3><h3 id="열여덟-번째-멤버-MinorSubsystemVersion"><a href="#열여덟-번째-멤버-MinorSubsystemVersion" class="headerlink" title="열여덟 번째 멤버, MinorSubsystemVersion"></a>열여덟 번째 멤버, MinorSubsystemVersion</h3><p><strong>PE 파일을 실행하는 데 필요한 서브시스템의 최소 버전</strong>을 말해요.<br>링킹 시에 /SUBSYSTEM 스위치로 변경할 수 있어요.</p>
<br>

<h3 id="열아홉-번째-멤버-Win32VersionValue"><a href="#열아홉-번째-멤버-Win32VersionValue" class="headerlink" title="열아홉 번째 멤버, Win32VersionValue"></a>열아홉 번째 멤버, Win32VersionValue</h3><p>이 필드는 VC++ 6.0 SDK 까지는 예약 필드였는데, 7.0에 와서 Win32VersionValue 라는 이름을 가진 필드로 바뀌었고, 보통 0으로 결정되요.</p>
<br>

<h3 id="스물-번째-멤버-DWORD-SizeOfImage"><a href="#스물-번째-멤버-DWORD-SizeOfImage" class="headerlink" title="스물 번째 멤버, DWORD SizeOfImage"></a>스물 번째 멤버, DWORD SizeOfImage</h3><p>이 멤버는 <strong>로더가 해당 PE 파일을 메모리 상에 로드할 때 확보/예약해야 할 해당 PE를 위한 충분한 크기 값</strong>을 가져요.<br>PE 파일의 크기와 같을 수도 있지만 <strong>PE 파일 상에서의 섹션의 배치가 메모리에 매핑되면서 달라질 수 있기 때문에 보통은 PE 파일의 크기보다 커요.</strong></p>
<p><strong>이 필드의 값은 반드시 SectionAlignment 필드의 값의 배수</strong>가 되어야 해요.</p>
<br>

<h3 id="스물-첫-번째-멤버-DWORD-SizeOfHeaders"><a href="#스물-첫-번째-멤버-DWORD-SizeOfHeaders" class="headerlink" title="스물 첫 번째 멤버, DWORD SizeOfHeaders"></a>스물 첫 번째 멤버, DWORD SizeOfHeaders</h3><p>이 필드는 <strong>MS-DOS 헤더, PE 헤더, 섹션 테이블들의 크기를 모두 합친 바이트의 수</strong>에요.<br><strong>모든 헤더나 테이블들은 PE 파일 상에서 반드시 코드 또는 데이터 섹션의 앞쪽에 위치</strong>에 있어야 해요.</p>
<p><strong>이 필드의 값은 FilaAlignment 필드 값의 배수</strong>가 되어야 해요.</p>
<br>

<h3 id="스물-두-번째-멤버-DWORD-CheckSum"><a href="#스물-두-번째-멤버-DWORD-CheckSum" class="headerlink" title="스물 두 번째 멤버, DWORD CheckSum"></a>스물 두 번째 멤버, DWORD CheckSum</h3><p>이름 그대로 이미지의 체크섬 값이다. PE 파일의 체크섬 값은 IMAGEHELP.DLL의 CheckSumMAppedFile API를 통해서 얻을 수 있으며, 체크섬 값은 커널 모드 드라이버나 시스템 DLL의 경우 요구 된다.<br>그 외의 경우라면 보통 0으로 설정이 된다.<br>/RELEASE 링커 스위치를 통해 이 필드를 설정을 할 수 있다.</p>
<br>

<h3 id="스물-세-번째-멤버-WORD-Subsystem"><a href="#스물-세-번째-멤버-WORD-Subsystem" class="headerlink" title="스물 세 번째 멤버, WORD Subsystem"></a>스물 세 번째 멤버, WORD Subsystem</h3><p><strong>Win32 아키텍처는 크게 유저 모드와 커널 모드로 나눌 수 있으며, 유저 모드에는 서브시스템이라는 컴포넌트가 존재</strong>해요.</p>
<p>Win32에서 지원하는 기본 서브 시스템은 Win32 서브시스템, 이전 OS/2와의 호환을 위한 OS/2 서브시스템, 이전 UNIX와의 호환을 위해 최소 표준으로 지원되는 POSIX/CUI 서브시스템 이렇게 3가지 정도가 있다고 해요.</p>
<p>어떤 서브시스템을 지원하는지 알고 싶으면, “WinNT.h” 헤더 파일에 정의되어 있으니, 그것을 참고하면 되요.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SUBSYSTEM_UNKNOWN              0   <span class="comment">// Unknown subsystem.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SUBSYSTEM_NATIVE               1   <span class="comment">// Image doesn't require a subsystem.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SUBSYSTEM_WINDOWS_GUI          2   <span class="comment">// Image runs in the Windows GUI subsystem.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SUBSYSTEM_WINDOWS_CUI          3   <span class="comment">// Image runs in the Windows character subsystem.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SUBSYSTEM_OS2_CUI              5   <span class="comment">// image runs in the OS/2 character subsystem.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SUBSYSTEM_POSIX_CUI            7   <span class="comment">// image runs in the Posix character subsystem.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SUBSYSTEM_NATIVE_WINDOWS       8   <span class="comment">// image is a native Win9x driver.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SUBSYSTEM_WINDOWS_CE_GUI       9   <span class="comment">// Image runs in the Windows CE subsystem.</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SUBSYSTEM_EFI_APPLICATION      10  <span class="comment">//</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER  11   <span class="comment">//</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER   12  <span class="comment">//</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SUBSYSTEM_EFI_ROM              13</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SUBSYSTEM_XBOX                 14</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SUBSYSTEM_WINDOWS_BOOT_APPLICATION 16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SUBSYSTEM_XBOX_CODE_CATALOG    17</span></span><br></pre></td></tr></table></figure>

<p>대부분의 경우 IMAGE_SUBSYSTEM_WINDOS_GUI 또는 IMAGE_SUBSYSTEM_WINDOWS_CUI 이에요.</p>
<p>WinMain()으로 시작하는 경우 IMAGE_SUBSYSTEM_WINDOWS_GUI 인 0x0002가 될 것이고, main()으로 시작하는 콘솔 응용 애플리케이션의 경우 IMAGE_SUBSYSTEM_WINDOWS_CUI인 0x0003이 될거에요.</p>
<p>그 이외의 다바이스 드라이버 같이 별도로 서브시스템을 사용하지 않는 경우 IMAGE_SUBSYSTEM_NATIVE인 0x00001의 값을 가지게 되요.</p>
<br>

<h3 id="스물-네-번째-멤버-WORD-DllCharacteristics"><a href="#스물-네-번째-멤버-WORD-DllCharacteristics" class="headerlink" title="스물 네 번째 멤버, WORD DllCharacteristics"></a>스물 네 번째 멤버, WORD DllCharacteristics</h3><p>이 멤버는 <strong>PE가 DLL 이라는 전제 하에 어떤 상황에서 DLL 초기화 함수(DLLMain())을 호출 되어야 하는지를 지시하는 플래그 값</strong>이 저장되어 있어요.</p>
<p>“WinNT.h” 헤더 파일에 이 필드에 집어 넣을 수 있는 매크로 정의가 되어 있어요.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DllCharacteristics Entries</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//      IMAGE_LIBRARY_PROCESS_INIT            0x0001     // Reserved.</span></span><br><span class="line"><span class="comment">//      IMAGE_LIBRARY_PROCESS_TERM            0x0002     // Reserved.</span></span><br><span class="line"><span class="comment">//      IMAGE_LIBRARY_THREAD_INIT             0x0004     // Reserved.</span></span><br><span class="line"><span class="comment">//      IMAGE_LIBRARY_THREAD_TERM             0x0008     // Reserved.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DLLCHARACTERISTICS_HIGH_ENTROPY_VA    0x0020  <span class="comment">// Image can handle a high entropy 64-bit virtual address space.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE 0x0040     <span class="comment">// DLL can move.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DLLCHARACTERISTICS_FORCE_INTEGRITY    0x0080     <span class="comment">// Code Integrity Image</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DLLCHARACTERISTICS_NX_COMPAT    0x0100     <span class="comment">// Image is NX compatible</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DLLCHARACTERISTICS_NO_ISOLATION 0x0200     <span class="comment">// Image understands isolation and doesn't want it</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DLLCHARACTERISTICS_NO_SEH       0x0400     <span class="comment">// Image does not use SEH.  No SE handler may reside in this image</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DLLCHARACTERISTICS_NO_BIND      0x0800     <span class="comment">// Do not bind this image.</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DLLCHARACTERISTICS_APPCONTAINER 0x1000     <span class="comment">// Image should execute in an AppContainer</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DLLCHARACTERISTICS_WDM_DRIVER   0x2000     <span class="comment">// Driver uses WDM model</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DLLCHARACTERISTICS_GUARD_CF     0x4000     <span class="comment">// Image supports Control Flow Guard.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE     0x8000</span></span><br></pre></td></tr></table></figure>

<p>이 중 DllMain() 정의시 아래의 대응 관계처럼 이 진입점 함수의 파라미터로 넘어오는 fdwReason의 가능한 네가지 값과 동일한 위상이라고 볼 수 있어요.</p>
<ul>
<li>IMAGE_LIBRARY_PROCESS_INIT &lt; - &gt; DLL_PROCESS_ATTACH</li>
<li>IMAGE_LIBRARY_PROCESS_TERM &lt; - &gt; DLL_PROCESS_DEATCH</li>
<li>IMAGE_LIBRARY_THREAD_INIT &lt; - &gt; DLL_THREAD_ATTACH</li>
<li>IMAGE_LIBRARY_THREAD_TERM &lt; - &gt; DLL_PROCESS_DETACH</li>
</ul>
<p>하지만 이 필드의 값은 EXE의 경우에도 0이며, DLL의 경우에도 0이에요.<br>MS는 위의 예약어에 해당하는 네 가지 플래그를 더이상 사용하지 않고 IMAGE_DLLCHARACTERISTIC_XXX 라는 플래그들을 추가했어요.</p>
<ul>
<li><p>IMAGE_DLLCHARACTERISTICS_NO_SEH ( 0x0400)</p>
<blockquote><p>구조적 예외 핸들링(SEH, Structured Exception Handling)을 사용하지 않는다. 구조적 예외 핸들링은 Win32 시스템에서 제공하는 기능(C++ 에서의 try{…}catch(…){…{ 예외 제어 구문과 비슷한 기능)이다.</p>
<p>Visual C++ 컴파일러의 경우 이 SEH를 지원하기 위해 <strong>try{…}</strong>except(…){…} 라는 키워드를 제공한다. 이 플래그의 경우 VC++ 6.0에서는 지원하지 않음.</p>
</blockquote>
</li>
<li><p>IMAGE_DLLCHARACTERISTICS_NO_BIND ( 0x0800)</p>
<blockquote><p>이 플래그는 이 이미지를 바인딩하지 않음을 의미함. VC++ 6.0 에서는 없는 정의</p>
</blockquote>
</li>
<li><p>IMAGE_DLLCHARACTERISTICS_WDM_DRIVER ( 0x2000)</p>
<blockquote><p>드라이버가 WDM 모델을 사용한다는 의미. WDM은 Windows Driver Model의 약자로서 모든 Microsoft Windows 운영체제에 걸쳐서 호환 가능한 소스코드로 구성되는 디바이스 드라이버를 작성할 수 있도록 소개된 모델임.</p>
<p>WDM 룰을 따르는 커널 모드 드라이버를 WDM 드라이버라고 부름. DDK의 서브셋의 일종임.</p>
</blockquote></li>
<li><p>IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE ( 0x8000)</p>
<blockquote><p>이 플래그는 터미널 서버가 터미널 서비스가 인식하지 못하는 애플리케이션을 로드시켰을 경우 실행 가능하도록 하기 위해 호환 가능한 코드를 담고 있는 DLL도 같이 로드시킬 수 있음을 의미함.</p>
</blockquote>

</li>
</ul>
<br>

<h3 id="스물-다섯-번째-멤버-DWORD-SizeOfStackReserver"><a href="#스물-다섯-번째-멤버-DWORD-SizeOfStackReserver" class="headerlink" title="스물 다섯 번째 멤버, DWORD SizeOfStackReserver"></a>스물 다섯 번째 멤버, DWORD SizeOfStackReserver</h3><h3 id="스물-여섯-번째-멤버-DWORD-SizeOfStackCommit"><a href="#스물-여섯-번째-멤버-DWORD-SizeOfStackCommit" class="headerlink" title="스물 여섯 번째 멤버, DWORD SizeOfStackCommit"></a>스물 여섯 번째 멤버, DWORD SizeOfStackCommit</h3><h3 id="스물-일곱-번째-멤버-DWORD-SizeOfHeapReserve"><a href="#스물-일곱-번째-멤버-DWORD-SizeOfHeapReserve" class="headerlink" title="스물 일곱 번째 멤버, DWORD SizeOfHeapReserve"></a>스물 일곱 번째 멤버, DWORD SizeOfHeapReserve</h3><h3 id="스물-여덟-번째-멤버-DWORD-SizeOfHeapCommit"><a href="#스물-여덟-번째-멤버-DWORD-SizeOfHeapCommit" class="headerlink" title="스물 여덟 번째 멤버, DWORD SizeOfHeapCommit"></a>스물 여덟 번째 멤버, DWORD SizeOfHeapCommit</h3><p>프로세스는 가상 주소 공간에 자신만의 스택과 힙을 별도로 가져요.<br>프로세스 생성 시 시스템은 언제나 메인 스레드를 위한 디폴트 스택과 프로세스를 위한 디폴트 힙을 해당 프로세스 내에 생성 시켜 주는데, 이 <strong>스택과 힘의 크기와 속성에 관계된 설정</strong>을 이 필드에서 지정해요.</p>
<p>PE 파일의 경우 로드되면서 하나의 프로세스가 되든지, DLL 이라면 특정 프로세스의 주소 공간 내부에 잠입해 들어가게 되는데요.<br>이때 <strong>스택과 힙의 예약 크기와 커밋 크기를 지정</strong>해줄 수 있어요.</p>
<p>PE 파일이 메모리에 로드될 때 시스템은 이 필드들의 값을 참조하여 해당 프로세스에 디폴트 스택과 디폴트 힙을 만들어 줘요.</p>
<p><strong>링커가 만들어낸 디폴트 값은 스택과 힙 모두 예약 크기 1M인 0x00100000 이며 커밋 크기는 1페이지에 해당하는 4K인 0x00001000</strong>이에요.</p>
<br>

<h3 id="스물-아홉-번째-멤버-DWORD-LoaderFlags"><a href="#스물-아홉-번째-멤버-DWORD-LoaderFlags" class="headerlink" title="스물 아홉 번째 멤버, DWORD LoaderFlags"></a>스물 아홉 번째 멤버, DWORD LoaderFlags</h3><p>이 필드는 0으로 설정이되요. 원래 목적은 디버깅 지원에 관계 되었다고 해요.</p>
<br>

<h3 id="서른-번째-멤버-DWORD-NumberOfRvaAndSizes"><a href="#서른-번째-멤버-DWORD-NumberOfRvaAndSizes" class="headerlink" title="서른 번째 멤버, DWORD NumberOfRvaAndSizes"></a>서른 번째 멤버, DWORD NumberOfRvaAndSizes</h3><p>이 필드는 바로 다음에 나올 주요 섹션들과 정보들의 위치와 크기를 나타내는  <strong>IMAGE_DATA_DIRECTORY 구조체 배열의 원소 개수를 의미</strong>해요.<br>책 에서는 이 구조체의 개수는 항상 16라서, 이 멤버의 값은 언제나 0x00000010 이라고 해요.</p>
<p><strong>하지만 공식 문서에서 항상 그렇지 않다고 해요. 따라서 IMAGE_DATA_DIRECTORY 구조체 배열의 개수를 알기 위해서는 이 멤버의 값을 확인 해야 되요.</strong></p>
<br>

<h2 id="마지막으로…"><a href="#마지막으로…" class="headerlink" title="마지막으로…"></a>마지막으로…</h2><p>IMAGE_OPTIONAL_HEADER에서 기억하고 가야할 멤버들은 <strong>AddressOfEntryPoint, ImageBase, SectionAlignment, FileAlignment, SizeOfImage, NumberOfRvaAndSizes</strong> 라고 생각해요.</p>
<p><strong>AddressOfEntryPoint</strong>는 OP의 주소 값이 들어가고,<br><strong>ImageBase</strong>는 가상 주소 공간에 매핑될 때, 매핑시키고자 하는 메모리 상의 주소 값이고,<br><strong>SectionAlignment</strong>는 메모리에 매핑될 때, 섹션의 크기를 확인할 때 사용하는 녀석이고,<br><strong>FileAlignemt</strong>는 파일 내에서, 섹션의 크기를 확인할 때 사용하는 녀석이고,<br><strong>SizeOfImage</strong>는 PE 파일을 메모리 상에 로드할 때 확보해야할 크기 값을 가지고 있는 녀석이고,<br><strong>NumberOfRvaAndSizes</strong>는 PE 파일 안에 있는 섹션들의 위치와 크기를 나타내는 녀석이므로 기억해야 한다고 생각해요!</p>
<br>
<br>
<br>
<br>
<br>

<h2 id="참고자료"><a href="#참고자료" class="headerlink" title="참고자료"></a>참고자료</h2><hr>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_optional_header64" target="_blank" rel="noopener">IMAGE_OPTIONAL_HEADER</a></p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://777bareman777.github.io/2019/09/18/UnderstandPE3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="777bareman777">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="777bareman777 Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/09/18/UnderstandPE3/" class="post-title-link" itemprop="url">PE 구조 이해하기 - IMAGE_FILE_HEADER 구조</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-09-18 01:02:50" itemprop="dateCreated datePublished" datetime="2019-09-18T01:02:50+09:00">2019-09-18</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-09-24 09:13:28" itemprop="dateModified" datetime="2019-09-24T09:13:28+09:00">2019-09-24</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/PE-file/" itemprop="url" rel="index"><span itemprop="name">PE file</span></a></span>

                
                
              
            </span>
          

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
        
      
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2019/09/18/UnderstandPE3/#comments" itemprop="discussionUrl"><span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/09/18/UnderstandPE3/" itemprop="commentCount"></span></a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>windows 시스템 실행파일의 구조와 원리 책 내용을 요약 및 정리 하는 포스팅이에요.</p>
<p>PE파일의 PE 시그니처 다음에 이어지는 <strong>IMAGE_FILE_HEADER</strong>에 대한 내용을 알아볼 거에요.</p>
<br>

<h2 id="IMAGE-FILE-HEADER-구조체"><a href="#IMAGE-FILE-HEADER-구조체" class="headerlink" title="IMAGE_FILE_HEADER 구조체"></a>IMAGE_FILE_HEADER 구조체</h2><p><strong>IMAGE_FILE_HEADER</strong> 구조체는 <strong>20바이트</strong>로 구성이 되어 있어요.<br>이것도 당연히 “WinNT.h” 헤더 파일에 정의되어 있어요.</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _IMAGE_FILE_HEADER &#123;</span><br><span class="line">  <span class="type">WORD</span>  <span class="type">Machine</span>;</span><br><span class="line">  <span class="type">WORD</span>  <span class="type">NumberOfSections</span>;</span><br><span class="line">  <span class="type">DWORD</span> <span class="type">TimeDateStamp</span>;</span><br><span class="line">  <span class="type">DWORD</span> <span class="type">PointerToSymbolTable</span>;</span><br><span class="line">  <span class="type">DWORD</span> <span class="type">NumberOfSymbols</span>;</span><br><span class="line">  <span class="type">WORD</span>  <span class="type">SizeOfOptionalHeader</span>;</span><br><span class="line">  <span class="type">WORD</span>  <span class="type">Characteristics</span>;</span><br><span class="line">&#125; <span class="type">IMAGE_FILE_HEADER</span>, *<span class="type">PIMAGE_FILE_HEADER</span>;</span><br></pre></td></tr></table></figure>

<p>구조체 멤버에 대해 하나씩 설명을 해드릴게요.</p>
<br>

<h3 id="첫-번째-멤버-WORD-Machine"><a href="#첫-번째-멤버-WORD-Machine" class="headerlink" title="첫 번째 멤버, WORD Machine"></a>첫 번째 멤버, WORD Machine</h3><p>Machine 필드는 PE 파일의 CPU ID를 나타내요. 즉, 사용자가 <strong>어떤 CPU를 통해서 PE 파일을 생성했는지 알 수 있어요</strong>.</p>
<p>C언어와 C++로 짜여진 코드 같은 경우에는 CPU 의존적이라서 이런 정보가 들어가 있나봐요.</p>
<p>이것도 CPU ID에 해당하는 매크로 상수가 정의되어 있는데, 자주 사용되는 매크로 상수는 아래와 같아요</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_IA64              0x0200  <span class="comment">// Intel 64</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_AMD64             0x8664  <span class="comment">// AMD64 (K8)</span></span></span><br></pre></td></tr></table></figure>

<br>

<h3 id="두-번째-멤버-WORD-NumberOfSections"><a href="#두-번째-멤버-WORD-NumberOfSections" class="headerlink" title="두 번째 멤버, WORD NumberOfSections"></a>두 번째 멤버, WORD NumberOfSections</h3><p><strong>PE 파일에서의 섹션의 수</strong>를 나타내요. IMAGE_SECTION_HEADER 구조체 배열의 원소의 개수. 즉, 해당 PE 파일의 섹션의 개수를 의미해요.</p>
<br>

<h3 id="세-번째-멤버-DWORD-TimeDateStamp"><a href="#세-번째-멤버-DWORD-TimeDateStamp" class="headerlink" title="세 번째 멤버, DWORD TimeDateStamp"></a>세 번째 멤버, DWORD TimeDateStamp</h3><p>OBj 파일이라면 컴파일러가, EXE 또는 DLL과 같은 PE 파일이라면 링커가 해당 <strong>파일을 만들어낸 시간</strong>을 의미해요.</p>
<p>이 값은 1970년 1월 1일 09시(GMT 시간 기준)로부터 해당 파일을 만들어낸 시점까지의 초 단위로 표현해요.</p>
<br>

<h3 id="네-번째-멤버-DWOARD-PointerToSymbolTable"><a href="#네-번째-멤버-DWOARD-PointerToSymbolTable" class="headerlink" title="네 번째 멤버, DWOARD PointerToSymbolTable"></a>네 번째 멤버, DWOARD PointerToSymbolTable</h3><p>PointerToSymbolTable 필드는 말 그대로 심볼 테이블의 데이터를 가리키는 주소 값이 들어가는 영역이에요. 즉, <strong>COFF 심벌의 파일 오프셋 값</strong>을 가지고 있는 거에요.</p>
<p><strong>이 필드 같은 경우에는 컴파일러에 의해 생성되는 OBJ 파일 또는 디버그 모드로 만들어져서 COFF 디버그 정보를 가진 PE 파일에서만 사용이 되요.</strong></p>
<p>PE 파일은 복수의 디버그 포맷을 지원하기 떄문에 IMAGE_DIRECTORY_ENTRY_DEBUG 엔트리를 참조해야 되고요.</p>
<p><em>요즘에는 COFF 심벌 테이블은 새로운 디버그 포맷에 의해 대체되어서 PE 파일 내에서는 거의 사용하지 않아요.</em><br>물론 링커 스위치를 /DEBUGTYPE:COFF로 지정할 경우 생성할 수 있어요.</p>
<br>

<h3 id="다섯-번째-멤버-DOWRD-NumberOfSymbols"><a href="#다섯-번째-멤버-DOWRD-NumberOfSymbols" class="headerlink" title="다섯 번째 멤버, DOWRD NumberOfSymbols"></a>다섯 번째 멤버, DOWRD NumberOfSymbols</h3><p><strong>PointerToSymbolTable 필드가 가리키는 COFF 심벌 테이블 내에서의 심벌의 수</strong>를 나타냄.</p>
<p><em>이것도 마찬가지로 새로운 디버그 포맷에 의해 대체되어서 사용되지 않음.</em></p>
<br>

<h3 id="여섯-번째-멤버-WORD-SizeOfOptionalHeader"><a href="#여섯-번째-멤버-WORD-SizeOfOptionalHeader" class="headerlink" title="여섯 번째 멤버, WORD SizeOfOptionalHeader"></a>여섯 번째 멤버, WORD SizeOfOptionalHeader</h3><p>IMAGE_FILE_HEADER 구조체 바로 다음에 이어서 나오는 <strong>IMAGE_OPTIONAL_HEADER 구조체의 바이트 수</strong>를 나타내요. </p>
<p>이 필드는 OBJ 파일의 경우 0이고, 실행 파일의 경우는 “sizeof(IMAGE_OPTIONAL_HEADER)”의 값을 가져요.</p>
<p>32비트 PE 파일의 경우 0xE0(224)바이트이고, 64비트 PE 파일의 경우 0xF0(240)바이트에요.</p>
<br>

<h3 id="일곱-번째-멤버-WORD-Characteristics"><a href="#일곱-번째-멤버-WORD-Characteristics" class="headerlink" title="일곱 번째 멤버, WORD Characteristics"></a>일곱 번째 멤버, WORD Characteristics</h3><p><strong>PE 파일에 대한 특정 정보를 나타내는 플래그</strong>에요. 이 필드도 “WinNT.h” 헤더 파일에 정의되어 있어요.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_RELOCS_STRIPPED           0x0001  <span class="comment">// Relocation info stripped from file.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_EXECUTABLE_IMAGE          0x0002  <span class="comment">// File is executable  (i.e. no unresolved external references).</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_LINE_NUMS_STRIPPED        0x0004  <span class="comment">// Line nunbers stripped from file.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_LOCAL_SYMS_STRIPPED       0x0008  <span class="comment">// Local symbols stripped from file.</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_AGGRESIVE_WS_TRIM         0x0010  <span class="comment">// Aggressively trim working set</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_LARGE_ADDRESS_AWARE       0x0020  <span class="comment">// App can handle &gt;2gb addresses</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_BYTES_REVERSED_LO         0x0080  <span class="comment">// Bytes of machine word are reversed.</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_32BIT_MACHINE             0x0100  <span class="comment">// 32 bit word machine.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_DEBUG_STRIPPED            0x0200  <span class="comment">// Debugging info stripped from file in .DBG file</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP   0x0400  <span class="comment">// If Image is on removable media, copy and run from the swap file.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_NET_RUN_FROM_SWAP         0x0800  <span class="comment">// If Image is on Net, copy and run from the swap file.</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_SYSTEM                    0x1000  <span class="comment">// System File.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_DLL                       0x2000  <span class="comment">// File is a DLL.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_UP_SYSTEM_ONLY            0x4000  <span class="comment">// File should only be run on a UP machine</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_BYTES_REVERSED_HI         0x8000  <span class="comment">// Bytes of machine word are reversed.</span></span></span><br></pre></td></tr></table></figure>

<p>이 중에서도 중요한 것은 요것들이에요.</p>
<table>
<thead>
<tr>
<th>매크로명</th>
<th>값</th>
<th>의미</th>
</tr>
</thead>
<tbody><tr>
<td>IMAGE_FILE_RELOCS_STRIPPED</td>
<td>0x0001</td>
<td>현재 파일에 재배치 정보가 없음</td>
</tr>
<tr>
<td>IMAGE_FILE_EXECUTABLE_IMAGE</td>
<td>0x0002</td>
<td>본 파일은 실행 파일 이미지이다.</td>
</tr>
<tr>
<td>IMAGE_FILE_LINE_NUMS_STRIPPED</td>
<td>0x0004</td>
<td>본 파일에 라인 정보가 없다.</td>
</tr>
<tr>
<td>IMAGE_FILE_LOCAL_SYMS_STRIPPED</td>
<td>0x0008</td>
<td>본 파일에 로컬 심벌이 없다.</td>
</tr>
<tr>
<td>IMAGE_FILE_AGGRESIVE</td>
<td>0x0010</td>
<td>OS로 하여금 적극적으로 워킹셋을 정리할 수 있도록 한다</td>
</tr>
<tr>
<td>IMAGE_FILE_LARGE_ADD_RESS_AWARE</td>
<td>0x0020</td>
<td>애플리케이션이 2G 이상의 가상 주소 번지를 제어할 수 있도록한다.</td>
</tr>
<tr>
<td>IMAGE_FILE_32BIT_MACHINE</td>
<td>0x0100</td>
<td>본 PE는 32비트 워드 머신을 필요로 한다.</td>
</tr>
<tr>
<td>IMAGE_FILE_DEBUG_STRIPPED</td>
<td>0x0200</td>
<td>디버그 정보가 본 파일에는 없고 .DBG 파일에 존재한다.</td>
</tr>
<tr>
<td>IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP</td>
<td>0x0400</td>
<td>PE 이미지가 이동 가능한 장치 위에 존재할 때 고정 디스크 상의 스왑 파일로 카피해서 실행한다.</td>
</tr>
<tr>
<td>IMAGE_FILE_NET_RUN_FROM_SWAP</td>
<td>0x0800</td>
<td>PE 이미지가 네트워크 상에 존재할 때 고정 디스크 상의 스왑 파일로 카피해서 실행한다.</td>
</tr>
<tr>
<td>IMAGE_FILE_DLL</td>
<td>0x2000</td>
<td>본 파일은 동적 링크 라이브러리 파일이다.</td>
</tr>
<tr>
<td>IMAGE_FILE_UP_SYSTEM_ONLYT</td>
<td>0x4000</td>
<td>본 파일은 하나의 프로세서만을 장착한 머신에서 실행된다.</td>
</tr>
</tbody></table>
<br>

<h2 id="마지막으로…"><a href="#마지막으로…" class="headerlink" title="마지막으로…"></a>마지막으로…</h2><p>IMAGE_FILE_HEADER에 대해서 살펴봤는데요.<br><strong>여기서 중요한 멤버들은 섹션의 수를 조절할 수 있는 NumberOfSections 하고, PE 파일에 대한 특정 정보는 나타내는 플래그인 Characteristics</strong> 이에요.</p>
<p>NumberOfSections을 조절하면, 우리가 원하는대로 임의의 섹션을 추가할 수 있어요. 이러한 방법을 이용해서 악성코드를 삽입도 가능하다고 해요!</p>
<p>PE 파일에 특정 정보를 나타내는 플래그인 Characteristics 값의 조합을 알고 있으면, PE 파일을 분석할 필요 없이 이 값만을 가지고 PE 파일이 어떤 특징을 가지고 있는지 알 수 있을 거에요.</p>
<br>
<br>
<br>
<br>
<br>

<h2 id="참고자료"><a href="#참고자료" class="headerlink" title="참고자료"></a>참고자료</h2><hr>
<p><a href="https://docs.microsoft.com/ko-kr/windows/win32/api/winnt/ns-winnt-image_file_header" target="_blank" rel="noopener">IMAGE_FILE_HEADER</a></p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">777bareman777</p>
  <div class="site-description" itemprop="description"></div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">16</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">categories</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">tags</span>
        </a>
      </div>
    
  </nav>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">777bareman777</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.4.0</div>

        












        
      </div>
    </footer>
  </div>

  


  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.4.0"></script><script src="/js/motion.js?v=7.4.0"></script>
<script src="/js/schemes/muse.js?v=7.4.0"></script>
<script src="/js/next-boot.js?v=7.4.0"></script>



  





















  

  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://777bareman777.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>

</body>
</html>
