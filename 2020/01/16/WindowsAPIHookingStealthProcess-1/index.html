<!DOCTYPE html>





<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.4.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.4.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.4.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.4.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: 'Copy',
      copy_success: 'Copied',
      copy_failure: 'Copy failed'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="일명 나뭇잎 책이라고 불리는 리버싱 핵심 원리 책을 보면서, 배운 내용을 정리하는 포스팅입니다. 해당 포스팅에서는 API 후킹 방법을 이용해서 유저 모드에서 StealthProcess를 만드는 기법을 배웁니다.   들어가기에 앞서스텔스 프로세스를 만드는 방법을 알기전에 API 후킹 방법중 코드 패치를 이용하는 방식에 대해 알아야 합니다. 핵심 부분을 말하자">
<meta name="keywords" content="Windows,Windows Reversing">
<meta property="og:type" content="article">
<meta property="og:title" content="스텔스 프로세스, 코드 패치 기법을 이용해서 -1">
<meta property="og:url" content="http://777bareman777.github.io/2020/01/16/WindowsAPIHookingStealthProcess-1/index.html">
<meta property="og:site_name" content="777bareman777 Blog">
<meta property="og:description" content="일명 나뭇잎 책이라고 불리는 리버싱 핵심 원리 책을 보면서, 배운 내용을 정리하는 포스팅입니다. 해당 포스팅에서는 API 후킹 방법을 이용해서 유저 모드에서 StealthProcess를 만드는 기법을 배웁니다.   들어가기에 앞서스텔스 프로세스를 만드는 방법을 알기전에 API 후킹 방법중 코드 패치를 이용하는 방식에 대해 알아야 합니다. 핵심 부분을 말하자">
<meta property="og:locale" content="en">
<meta property="og:image" content="http://777bareman777.github.io/2020/01/16/WindowsAPIHookingStealthProcess-1/1.png">
<meta property="og:image" content="http://777bareman777.github.io/2020/01/16/WindowsAPIHookingStealthProcess-1/2.png">
<meta property="og:updated_time" content="2020-01-16T22:24:39.668Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="스텔스 프로세스, 코드 패치 기법을 이용해서 -1">
<meta name="twitter:description" content="일명 나뭇잎 책이라고 불리는 리버싱 핵심 원리 책을 보면서, 배운 내용을 정리하는 포스팅입니다. 해당 포스팅에서는 API 후킹 방법을 이용해서 유저 모드에서 StealthProcess를 만드는 기법을 배웁니다.   들어가기에 앞서스텔스 프로세스를 만드는 방법을 알기전에 API 후킹 방법중 코드 패치를 이용하는 방식에 대해 알아야 합니다. 핵심 부분을 말하자">
<meta name="twitter:image" content="http://777bareman777.github.io/2020/01/16/WindowsAPIHookingStealthProcess-1/1.png">
  <link rel="canonical" href="http://777bareman777.github.io/2020/01/16/WindowsAPIHookingStealthProcess-1/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>스텔스 프로세스, 코드 패치 기법을 이용해서 -1 | 777bareman777 Blog</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">
  <div class="container use-motion">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">777bareman777 Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">켄넬 교육받은 댕댕이</p>
      
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-about">
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>About</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>Tags</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-categories">
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>Categories</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>

  </li>
  </ul>

    

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
      <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block post">
    <link itemprop="mainEntityOfPage" href="http://777bareman777.github.io/2020/01/16/WindowsAPIHookingStealthProcess-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="777bareman777">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="777bareman777 Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">스텔스 프로세스, 코드 패치 기법을 이용해서 -1

          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2020-01-16 17:53:33" itemprop="dateCreated datePublished" datetime="2020-01-16T17:53:33+09:00">2020-01-16</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-01-17 07:24:39" itemprop="dateModified" datetime="2020-01-17T07:24:39+09:00">2020-01-17</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Windows-Reversing/" itemprop="url" rel="index"><span itemprop="name">Windows Reversing</span></a></span>

                
                
              
            </span>
          

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
        
      
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2020/01/16/WindowsAPIHookingStealthProcess-1/#comments" itemprop="discussionUrl"><span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/01/16/WindowsAPIHookingStealthProcess-1/" itemprop="commentCount"></span></a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>일명 나뭇잎 책이라고 불리는 리버싱 핵심 원리 책을 보면서, 배운 내용을 정리하는 포스팅입니다.</p>
<p>해당 포스팅에서는 API 후킹 방법을 이용해서 유저 모드에서 StealthProcess를 만드는 기법을 배웁니다.</p>
<br>

<h2 id="들어가기에-앞서"><a href="#들어가기에-앞서" class="headerlink" title="들어가기에 앞서"></a>들어가기에 앞서</h2><p>스텔스 프로세스를 만드는 방법을 알기전에 API 후킹 방법중 코드 패치를 이용하는 방식에 대해 알아야 합니다. 핵심 부분을 말하자면 프로세스 메모리에 로딩된 라이브러리 이미지에서 후킹을 원하는 API 코드를 수정하는 방법입니다. 해당 내용에 대해 더 자세히 알고 싶다면, <a href="../../15/WindowsAPIHookingUsingCodePatch">Windows API Hooking - Code Patch</a> 참고하시면 됩니다.</p>
<br>

<h2 id="스텔스-프로세스"><a href="#스텔스-프로세스" class="headerlink" title="스텔스 프로세스"></a>스텔스 프로세스</h2><p>특정 프로세스를 은폐시키기 위해서는 다른 모든 프로세스의 메모리에 침투하여 API를 후킹하는 것이 유저 모드에서 구현 가능한 스텔스 프로세스라고 합니다. 작업 대상은 자기 자신이 아니라 다른 프로세스입니다.</p>
<p>프로세스는 커널 객체이기 때문에 유저 모드 프로그램에서는 직접적으로 접근할 수 있는 방법이 없습니다. 따라서 API를 통해서만 검색 및 접근을 할 수 있다. 일반적으로 유저 모드에서 프로세스를 검색하기 위한 API가 2종류가 있다고 합니다.</p>
<ul>
<li><ol>
<li>CreateToolhelp32Snapshot() &amp; EnumProcesses()</li>
</ol>
</li>
</ul>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HANDLE CreateToolhelp32Snapshot(</span><br><span class="line">  <span class="built_in">DWORD</span> dwFlags,</span><br><span class="line">  <span class="built_in">DWORD</span> th32ProcessID</span><br><span class="line">)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">BOOL EnumProcesses(</span><br><span class="line">  <span class="built_in">DWORD</span>   *lpidProcess,</span><br><span class="line">  <span class="built_in">DWORD</span>   cb,</span><br><span class="line">  LPDWORD lpcbNeeded</span><br><span class="line">)<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p><strong>CreateToolhelp32Snapshot</strong>() API 같은 경우에는 프로세스에서 사용되는 힙, 모듈, 및 스레드의 스냅샷을 찍어서 프로세스에 대한 정보를 추출할 떄 사용하는 함수입니다. 프로세스와 관련된 모든 부분을 검색할 수도 있고, 일부분만 검색을 할 수 있습니다. 자세한 사항은 <a href="https://docs.microsoft.com/en-us/windows/win32/api/tlhelp32/nf-tlhelp32-createtoolhelp32snapshot" target="_blank" rel="noopener">MSDN</a>에서 검색해보시면 알 수 있습니다.</p>
<p><strong>EnumProcesses</strong>() API 같은 경우에는 프로세스 ID의 정보를 넘겨 받을 수 있는 함수이다. 이를 이용해서 MSDN에서 제공해주는 <a href="https://docs.microsoft.com/ko-kr/windows/win32/psapi/enumerating-all-processes?redirectedfrom=MSDN" target="_blank" rel="noopener">예제</a>처럼 프로세스 이름과 ID를 알아낼 수 있습니다.</p>
<p>-&gt; <a href="../ProcessSearch">해당 예제 실습은 여기서 확인.</a></p>
<p>위 2가지 API들은 모두 내부적으로 ntdll.ZwQuerySystemInformation() API를 호출한다고 합니다.</p>
<ul>
<li><ol start="2">
<li>ZwQuerySystemInformation()</li>
</ol>
</li>
</ul>
<figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS WINAPI ZwQuerySystemInformation(</span><br><span class="line">  <span class="variable">_In_</span>      SYSTEM_INFORMATION_CLASS SystemInformationClass,</span><br><span class="line">  <span class="variable">_Inout_</span>   PVOID                    SystemInformation,</span><br><span class="line">  <span class="variable">_In_</span>      ULONG                    SystemInformationLength,</span><br><span class="line">  <span class="variable">_Out_opt_</span> PULONG                   ReturnLength</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><strong>ZwQuerySystemInformation</strong>() API를 이용하면 실행 중인 모든 프로세스의 구조체를 연결 리스트 형태로 얻을 수 있다고 합니다. 그 연결 리스트를 조작하면 해당 프로세스를 은폐 시킬 수 있게 됩니다.</p>
<p>그렇기에 유저 모드에서는 CreateToolhelp32Snpshort() 또는 EnumProcesses() API를 따로 후킹할 필요 없이 ZwQuerySystemInformation() API 하나만 후킹하면 확실하게 원하는 프로세스를 은폐 시킬 수 있다고 합니다.</p>
<br>

<h2 id="해당-기법의-문제점"><a href="#해당-기법의-문제점" class="headerlink" title="해당 기법의 문제점"></a>해당 기법의 문제점</h2><p>해당 기법을 통해서 하고 싶은 행위는 procexp.exe(프로세스 익스플로러), taskmgr.exe(윈도우 작업 관리자) 같은 프로세스 검색 유틸리티한테서 특정 프로세스를 숨기고 싶은 것입니다.</p>
<p>하지만 프로세스 검색 유틸리티는 이 두가지만 있는 것이 아닙니다. 수많은 프로세스 검색 유틸리티가 존재할 수도 있고, 사용자가 직접 만든 유틸리티도 있을 수 있습니다. 따라서<br><strong>시스템에 실행 중인 모든 프로세스를 후킹해야만 특정 프로세스가 은폐되었다고 볼 수 있습니다.</strong> 또한, 후킹을 하고 난후에 나중에 프로세스 검색 유틸리티가 실행이 되었다면, 나중에 실행된 유틸리티는 후킹되지 않았으므로 특정 프로세스를 검색할 수 있습니다. 따라서 <strong>나중에 실행되는 프로세스 검색 유틸리티 또한 자동으로 후킹될 수 있도록 작성해야지 특정 프로세스가 은폐되었다고 볼 수 있습니다.</strong></p>
<p>이러한 문제점을 가지고 있기 때문에 글로벌 후킹의 개념이 생겨났습니다. 시스템에 실행 중인 모든 프로세스를 후킹하고, 나중에 실행되는 모든 프로세스에 대해서도 후킹을 하는 것이 글로벌 후킹입니다.</p>
<p>먼저, 단순한 코드 패치를 통해서 스텔스 프로세스를 만드는 방법을 익히고, 다음 포스팅에서 글로벌 후킹을 통해서 문제점을 해결하는 방법을 익힐 예정입니다.</p>
<br>

<h2 id="분석"><a href="#분석" class="headerlink" title="분석"></a>분석</h2><p>나뭇잎 책에서 실습할 수 있도록, DLL을 인젝션할 수 있는 HideProc.exe 와 Stealth.dll 파일을 제공을 했습니다. Stealth.dll은 인젝션된 프로세스의 ntdll.ZwQuerySystemInformation() API를 후킹하는 역할을 합니다.</p>
<br>

<h3 id="HideProc-exe-gt-HookProc-cpp"><a href="#HideProc-exe-gt-HookProc-cpp" class="headerlink" title="HideProc.exe -&gt; HookProc.cpp"></a>HideProc.exe -&gt; HookProc.cpp</h3><p>HideProc.exe은 DLL을 인젝션 할 수 있는 인젝터입니다. 나뭇잎책에서 제공되어진 인젝터랑 다른 점은 InjectAllProcess() 함수 부분입니다.</p>
<p>InjectAllProcess() 함수에서 CreateTool32SnapShot() API를 이용해서 시스템에 실행 중인 모든 프로레스 리스트를 얻어내고, Process32First()와 Process32Next() API를 이용해서 프로세스 PID를 구하는 것을 확인할 수 있습니다.</p>
<p>이렇게 구해진 프로세스 PID를 가지고, 모든 프로세스한테 DLL을 인젝션합니다. 이때, 시스템 PID가 100 미만 프로세스들은 인젝션을 수행하지 않는데, 시스템 안정성 떄문에 그렇습니다. 실습 환경에 따라서 해당 부분은 적절하게 조절하면 됩니다.</p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BOOL</span> <span class="built_in">InjectAllProcess</span>(int nMode, LPCTSTR szDllPath)</span><br><span class="line">&#123;</span><br><span class="line">	DWORD                   dwPID = <span class="number">0</span>;</span><br><span class="line">	HANDLE                  hSnapShot = INVALID_HANDLE_VALUE;</span><br><span class="line">	PROCESSENTRY32          pe;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Get the snapshot of the system</span></span><br><span class="line">	pe.dwSize = <span class="built_in">sizeof</span>(PROCESSENTRY32);</span><br><span class="line">	hSnapShot = <span class="built_in">CreateToolhelp32Snapshot</span>(TH32CS_SNAPALL, <span class="built_in">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// find process</span></span><br><span class="line">	<span class="built_in">Process32First</span>(hSnapShot, &amp;pe);</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		dwPID = pe.th32ProcessID;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 시스템의 안정성을 위해서</span></span><br><span class="line">		<span class="comment">// PID 가 100 보다 작은 시스템 프로세스에 대해서는</span></span><br><span class="line">		<span class="comment">// DLL Injection 을 수행하지 않는다.</span></span><br><span class="line">		<span class="keyword">if</span> (dwPID &lt; <span class="number">100</span>)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (nMode == INJECTION_MODE)</span><br><span class="line">			<span class="built_in">InjectDll</span>(dwPID, szDllPath);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">EjectDll</span>(dwPID, szDllPath);</span><br><span class="line">	&#125; <span class="keyword">while</span> (<span class="built_in">Process32Next</span>(hSnapShot, &amp;pe));</span><br><span class="line"></span><br><span class="line">	<span class="built_in">CloseHandle</span>(hSnapShot);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>하지만 Windows10 64bit 환경에서 인젝터가 중간에 멈추는 현상을 발견을 했습니다. 해당 코드를 확인 해보니 InjectDll() 함수내의 코드중 WaitForSingleObject()에서 쓰레드가 종료될 떄까지 무한히 기다리고 있다는 것을 알게 되었습니다. 그래서 시스템에서 실행 되고 있는 프로세스 중에서 CreateRemoteThread() API를 이용해서 DLL 인젝션이 되지 않는 프로세스가 있구나를 알게 되었습니다. 여기서의 목적은 프로세스 검색 유틸리티에 Stealth.dll을 인젝션해서 은폐 프로세스를 못보게 하는 것이라서 WaitForSingleObject(hThread,INFINITE); 를 WaitForSingleObject(hThread,1000); 으로 바꿨습니다. 이때, DLL 인젝션이 되지 않는 프로세스가 프로세스 검색 유틸리티가 아니라서 가능한 방법이었습니다.</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BOOL </span>InjectDll(DWORD dwPID, LPCTSTR szDllPath)</span><br><span class="line">&#123;</span><br><span class="line">	HANDLE                  hProcess, hThread<span class="comment">;</span></span><br><span class="line">	LPVOID                  pRemoteBuf<span class="comment">;</span></span><br><span class="line">	DWORD                   dwBufSize = (DWORD)(_tcslen(szDllPath) + <span class="number">1</span>) * sizeof(TCHAR)<span class="comment">;</span></span><br><span class="line">	LPTHREAD_START_ROUTINE  pThreadProc<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">	if (!(hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID)))</span><br><span class="line">	&#123;</span><br><span class="line">		printf(<span class="string">"OpenProcess(%d) failed!!!\n"</span>, dwPID)<span class="comment">;</span></span><br><span class="line">		return FALSE<span class="comment">;</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pRemoteBuf = VirtualAllocEx(hProcess, NULL, dwBufSize,</span><br><span class="line">		MEM_COMMIT, PAGE_READWRITE)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">	WriteProcessMemory(hProcess, pRemoteBuf,</span><br><span class="line">		(LPVOID)szDllPath, dwBufSize, NULL)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">	pThreadProc = (LPTHREAD_START_ROUTINE)</span><br><span class="line">		GetProcAddress(GetModuleHandle(L<span class="string">"kernel32.dll"</span>),</span><br><span class="line">			<span class="string">"LoadLibraryW"</span>)<span class="comment">;</span></span><br><span class="line">	hThread = CreateRemoteThread(hProcess, NULL, <span class="number">0</span>,</span><br><span class="line">		pThreadProc, pRemoteBuf, <span class="number">0</span>, NULL)<span class="comment">;</span></span><br><span class="line">	<span class="keyword">WaitForSingleObject(hThread, </span><span class="number">1000</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">	VirtualFreeEx(hProcess, pRemoteBuf, <span class="number">0</span>, MEM_RELEASE)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">CloseHandle(hThread);</span></span><br><span class="line"><span class="keyword">	</span><span class="keyword">CloseHandle(hProcess);</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">	</span>return TRUE<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>그리고, 그전에 HideProc.exe 프로세스의 권한을 상승시켜 놓아야지 전체 프로세스의 리스트를 정확하게 얻을 수 있습니다. 해당 코드에서 SetPrivilege() 함수를 보면, 내부적으로 AdjustTokenPrivileges() API 호출을 이용하여 프로세스의 권한을 상승시키는 것을 볼 수 있습니다. 하지만 프로세스의 권한을 상승시키지 않아도 프로세스의 리스트를 어느정도 뽑을 수 있고, DLL 인젝션도 정상적으로 동작합니다.</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">BOOL</span> SetPrivilege(LPCTSTR lpszPrivilege, <span class="built_in">BOOL</span> bEnablePrivilege)</span><br><span class="line">&#123;</span><br><span class="line">	TOKEN_PRIVILEGES tp;</span><br><span class="line">	HANDLE hToken;</span><br><span class="line">	LUID luid;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!OpenProcessToken(GetCurrentProcess(),</span><br><span class="line">		TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,</span><br><span class="line">		&amp;hToken))</span><br><span class="line">	&#123;</span><br><span class="line">		printf(<span class="string">"OpenProcessToken error: %u\n"</span>, GetLastError());</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">FALSE</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!LookupPrivilegeValue(<span class="literal">NULL</span>,            <span class="comment">// lookup privilege on local system</span></span><br><span class="line">		lpszPrivilege,   <span class="comment">// privilege to lookup </span></span><br><span class="line">		&amp;luid))        <span class="comment">// receives LUID of privilege</span></span><br><span class="line">	&#123;</span><br><span class="line">		printf(<span class="string">"LookupPrivilegeValue error: %u\n"</span>, GetLastError());</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">FALSE</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	tp.PrivilegeCount = <span class="number">1</span>;</span><br><span class="line">	tp.Privileges[<span class="number">0</span>].Luid = luid;</span><br><span class="line">	<span class="keyword">if</span> (bEnablePrivilege)</span><br><span class="line">		tp.Privileges[<span class="number">0</span>].Attributes = SE_PRIVILEGE_ENABLED;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		tp.Privileges[<span class="number">0</span>].Attributes = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Enable the privilege or disable all privileges.</span></span><br><span class="line">	<span class="keyword">if</span> (!AdjustTokenPrivileges(hToken,</span><br><span class="line">		<span class="literal">FALSE</span>,</span><br><span class="line">		&amp;tp,</span><br><span class="line">		<span class="keyword">sizeof</span>(TOKEN_PRIVILEGES),</span><br><span class="line">		(PTOKEN_PRIVILEGES)<span class="literal">NULL</span>,</span><br><span class="line">		(PDWORD)<span class="literal">NULL</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		printf(<span class="string">"AdjustTokenPrivileges error: %u\n"</span>, GetLastError());</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">FALSE</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (GetLastError() == ERROR_NOT_ALL_ASSIGNED)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(<span class="string">"The token does not have the specified privilege. \n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">FALSE</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">TRUE</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="전체-소스-코드"><a href="#전체-소스-코드" class="headerlink" title="전체 소스 코드"></a>전체 소스 코드</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#include <span class="meta-string">"windows.h"</span></span></span><br><span class="line"><span class="meta">#include <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#include <span class="meta-string">"tlhelp32.h"</span></span></span><br><span class="line"><span class="meta">#include <span class="meta-string">"tchar.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (*PFN_SetProcName)(LPCTSTR szProcName);</span><br><span class="line"><span class="keyword">enum</span> &#123; INJECTION_MODE = <span class="number">0</span>, EJECTION_MODE &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">BOOL</span> SetPrivilege(LPCTSTR lpszPrivilege, <span class="built_in">BOOL</span> bEnablePrivilege)</span><br><span class="line">&#123;</span><br><span class="line">	TOKEN_PRIVILEGES tp;</span><br><span class="line">	HANDLE hToken;</span><br><span class="line">	LUID luid;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!OpenProcessToken(GetCurrentProcess(),</span><br><span class="line">		TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,</span><br><span class="line">		&amp;hToken))</span><br><span class="line">	&#123;</span><br><span class="line">		printf(<span class="string">"OpenProcessToken error: %u\n"</span>, GetLastError());</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">FALSE</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!LookupPrivilegeValue(<span class="literal">NULL</span>,            <span class="comment">// lookup privilege on local system</span></span><br><span class="line">		lpszPrivilege,   <span class="comment">// privilege to lookup </span></span><br><span class="line">		&amp;luid))        <span class="comment">// receives LUID of privilege</span></span><br><span class="line">	&#123;</span><br><span class="line">		printf(<span class="string">"LookupPrivilegeValue error: %u\n"</span>, GetLastError());</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">FALSE</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	tp.PrivilegeCount = <span class="number">1</span>;</span><br><span class="line">	tp.Privileges[<span class="number">0</span>].Luid = luid;</span><br><span class="line">	<span class="keyword">if</span> (bEnablePrivilege)</span><br><span class="line">		tp.Privileges[<span class="number">0</span>].Attributes = SE_PRIVILEGE_ENABLED;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		tp.Privileges[<span class="number">0</span>].Attributes = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Enable the privilege or disable all privileges.</span></span><br><span class="line">	<span class="keyword">if</span> (!AdjustTokenPrivileges(hToken,</span><br><span class="line">		<span class="literal">FALSE</span>,</span><br><span class="line">		&amp;tp,</span><br><span class="line">		<span class="keyword">sizeof</span>(TOKEN_PRIVILEGES),</span><br><span class="line">		(PTOKEN_PRIVILEGES)<span class="literal">NULL</span>,</span><br><span class="line">		(PDWORD)<span class="literal">NULL</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		printf(<span class="string">"AdjustTokenPrivileges error: %u\n"</span>, GetLastError());</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">FALSE</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (GetLastError() == ERROR_NOT_ALL_ASSIGNED)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(<span class="string">"The token does not have the specified privilege. \n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">FALSE</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">TRUE</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">BOOL</span> InjectDll(DWORD dwPID, LPCTSTR szDllPath)</span><br><span class="line">&#123;</span><br><span class="line">	HANDLE                  hProcess, hThread;</span><br><span class="line">	LPVOID                  pRemoteBuf;</span><br><span class="line">	DWORD                   dwBufSize = (DWORD)(_tcslen(szDllPath) + <span class="number">1</span>) * <span class="keyword">sizeof</span>(TCHAR);</span><br><span class="line">	LPTHREAD_START_ROUTINE  pThreadProc;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!(hProcess = OpenProcess(PROCESS_ALL_ACCESS, <span class="literal">FALSE</span>, dwPID)))</span><br><span class="line">	&#123;</span><br><span class="line">		printf(<span class="string">"OpenProcess(%d) failed!!!\n"</span>, dwPID);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">FALSE</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pRemoteBuf = VirtualAllocEx(hProcess, <span class="literal">NULL</span>, dwBufSize,</span><br><span class="line">		MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line"></span><br><span class="line">	WriteProcessMemory(hProcess, pRemoteBuf,</span><br><span class="line">		(LPVOID)szDllPath, dwBufSize, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	pThreadProc = (LPTHREAD_START_ROUTINE)</span><br><span class="line">		GetProcAddress(GetModuleHandle(L<span class="string">"kernel32.dll"</span>),</span><br><span class="line">			<span class="string">"LoadLibraryW"</span>);</span><br><span class="line">	hThread = CreateRemoteThread(hProcess, <span class="literal">NULL</span>, <span class="number">0</span>,</span><br><span class="line">		pThreadProc, pRemoteBuf, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">	WaitForSingleObject(hThread, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">	VirtualFreeEx(hProcess, pRemoteBuf, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line"></span><br><span class="line">	CloseHandle(hThread);</span><br><span class="line">	CloseHandle(hProcess);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">TRUE</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">BOOL</span> EjectDll(DWORD dwPID, LPCTSTR szDllPath)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">BOOL</span>                    bMore = <span class="literal">FALSE</span>, bFound = <span class="literal">FALSE</span>;</span><br><span class="line">	HANDLE                  hSnapshot, hProcess, hThread;</span><br><span class="line">	MODULEENTRY32           me = &#123; <span class="keyword">sizeof</span>(me) &#125;;</span><br><span class="line">	LPTHREAD_START_ROUTINE  pThreadProc;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (INVALID_HANDLE_VALUE ==</span><br><span class="line">		(hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, dwPID)))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">FALSE</span>;</span><br><span class="line"></span><br><span class="line">	bMore = Module32First(hSnapshot, &amp;me);</span><br><span class="line">	<span class="keyword">for</span> (; bMore; bMore = Module32Next(hSnapshot, &amp;me))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!_tcsicmp(me.szModule, szDllPath) ||</span><br><span class="line">			!_tcsicmp(me.szExePath, szDllPath))</span><br><span class="line">		&#123;</span><br><span class="line">			bFound = <span class="literal">TRUE</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!bFound)</span><br><span class="line">	&#123;</span><br><span class="line">		CloseHandle(hSnapshot);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">FALSE</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!(hProcess = OpenProcess(PROCESS_ALL_ACCESS, <span class="literal">FALSE</span>, dwPID)))</span><br><span class="line">	&#123;</span><br><span class="line">		CloseHandle(hSnapshot);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">FALSE</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pThreadProc = (LPTHREAD_START_ROUTINE)</span><br><span class="line">		GetProcAddress(GetModuleHandle(L<span class="string">"kernel32.dll"</span>),</span><br><span class="line">			<span class="string">"FreeLibrary"</span>);</span><br><span class="line">	hThread = CreateRemoteThread(hProcess, <span class="literal">NULL</span>, <span class="number">0</span>,</span><br><span class="line">		pThreadProc, me.modBaseAddr, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">	WaitForSingleObject(hThread, INFINITE);</span><br><span class="line"></span><br><span class="line">	CloseHandle(hThread);</span><br><span class="line">	CloseHandle(hProcess);</span><br><span class="line">	CloseHandle(hSnapshot);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">TRUE</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">BOOL</span> InjectAllProcess(<span class="keyword">int</span> nMode, LPCTSTR szDllPath)</span><br><span class="line">&#123;</span><br><span class="line">	DWORD                   dwPID = <span class="number">0</span>;</span><br><span class="line">	HANDLE                  hSnapShot = INVALID_HANDLE_VALUE;</span><br><span class="line">	PROCESSENTRY32          pe;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Get the snapshot of the system</span></span><br><span class="line">	pe.dwSize = <span class="keyword">sizeof</span>(PROCESSENTRY32);</span><br><span class="line">	hSnapShot = CreateToolhelp32Snapshot(TH32CS_SNAPALL, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// find process</span></span><br><span class="line">	Process32First(hSnapShot, &amp;pe);</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		dwPID = pe.th32ProcessID;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 시스템의 안정성을 위해서</span></span><br><span class="line">		<span class="comment">// PID 가 100 보다 작은 시스템 프로세스에 대해서는</span></span><br><span class="line">		<span class="comment">// DLL Injection 을 수행하지 않는다.</span></span><br><span class="line">		<span class="keyword">if</span> (dwPID &lt; <span class="number">100</span>)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (nMode == INJECTION_MODE)</span><br><span class="line">			InjectDll(dwPID, szDllPath);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			EjectDll(dwPID, szDllPath);</span><br><span class="line">	&#125; <span class="keyword">while</span> (Process32Next(hSnapShot, &amp;pe));</span><br><span class="line"></span><br><span class="line">	CloseHandle(hSnapShot);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">TRUE</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span>                     nMode = INJECTION_MODE;</span><br><span class="line">	HMODULE                 hLib = <span class="literal">NULL</span>;</span><br><span class="line">	PFN_SetProcName         SetProcName = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">4</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(<span class="string">"\n Usage  : HideProc.exe &lt;-hide|-show&gt; "</span>\</span><br><span class="line">			<span class="string">"&lt;process name&gt; &lt;dll path&gt;\n\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// change privilege</span></span><br><span class="line">	SetPrivilege(SE_DEBUG_NAME, <span class="literal">TRUE</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// load library</span></span><br><span class="line">	hLib = LoadLibrary(argv[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// set process name to hide</span></span><br><span class="line">	SetProcName = (PFN_SetProcName)GetProcAddress(hLib, <span class="string">"SetProcName"</span>);</span><br><span class="line">	SetProcName(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Inject(Eject) Dll to all process</span></span><br><span class="line">	<span class="keyword">if</span> (!_tcsicmp(argv[<span class="number">1</span>], L<span class="string">"-show"</span>))</span><br><span class="line">		nMode = EJECTION_MODE;</span><br><span class="line"></span><br><span class="line">	InjectAllProcess(nMode, argv[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// free library</span></span><br><span class="line">	FreeLibrary(hLib);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="Stealth-dll-gt-stealth-cpp"><a href="#Stealth-dll-gt-stealth-cpp" class="headerlink" title="Stealth.dll -&gt; stealth.cpp"></a>Stealth.dll -&gt; stealth.cpp</h3><p>실제 API 후킹을 당담하는 DLL 파일입니다.</p>
<br>

<h4 id="SetProcName"><a href="#SetProcName" class="headerlink" title="SetProcName()"></a>SetProcName()</h4><p>SetProcName 함수는 export 함수이다.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// global variable (in sharing memory)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(linker, <span class="meta-string">"/SECTION:.SHARE,RWS"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> data_seg(<span class="meta-string">".SHARE"</span>)</span></span><br><span class="line">	TCHAR g_szProcName[MAX_PATH] = &#123; <span class="number">0</span>, &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> data_seg()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// export function</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">__declspec(dllexport) <span class="function"><span class="keyword">void</span> <span class="title">SetProcName</span><span class="params">(LPCTSTR szProcName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	_tcscpy_s(g_szProcName, szProcName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>소스 코드를 보면, #pragma comment(linker, “/SECTION:.SHARE,RWS”) 전처리 구문을 통해서 “.SHARE”라는 데이터가 공유 가능한 메모리 섹션을 만들고, g_szProcName 버퍼를 생성을 한다는 것을 알 수 있습니다. 즉, 읽기, 쓰기, 공유 권한을 가진 데이터 섹션인 .SHARE를 만들어서 DLL 에 있는 데이터들을 공유할 때 사용하는 기법입니다. 이를 통해서 Stealth.dll이 모든 프로세스에 인젝션될 때 은폐 프로세스의 이름을 쉽게 공유할 수 있습니다.</p>
<p>#pragma comment() 전처리 구문을 통해서는 여러가지 일을 할 수 있습니다. 서브시스템을 설정한다거나 섹션을 설정한다거나 명시적으로 라이브러리를 링크한다거나 등을 할 수 있습니다. 프로젝트 관리에 들어가서 설정을 통해서 할 수 있는 부분들을 #pragma comment()를 통해서 편하게 설정을 할 수 있게 한 것입니다.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(linker, <span class="meta-string">"/SECTION:.SHARE,RWS"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> data_seg(<span class="meta-string">".SHARE"</span>)</span></span><br><span class="line">	TCHAR g_szProcName[MAX_PATH] = &#123; <span class="number">0</span>, &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> data_seg()</span></span><br></pre></td></tr></table></figure>

<p>다음 부분은 export 함수를 만드는 부분이다. C++과 C는 네임맹글링(Name Mangling) 많은 차이가 있습니다. C언어의 네임맹글링은 <em>cdecl 방식으로 컴파일 되었을 경우 단순히 함수 이름 앞에 “</em>“를 붙여주거나, <em>stdcall 방식으로 컴파일 되었을 경우 함수 이름 앞에 “</em>“을 붙여주고 함수 이름 마지막에 “@ordinal”을 붙여주는 방식으로 컴파일이 됩니다. 그에 반면 C++은 컴파일마다 네임맹글링 하는 방식이 다르며, 네임맹글링 하는 방식이 다르면 DLL을 만들 때, 링킹을 할 수 없는 상황이 벌어지기도 합니다. 따라서 C++을 이용해서 DLL을 만들었다고 하더라도 C module과 C++ module의 호환성을 위해서 extern “C” 키워를 사용을 하는 것입니다.</p>
<p>해당 관련 문서는 <a href="https://blueskywithyou.tistory.com/48" target="_blank" rel="noopener">이곳</a>을 찾아보면 된다. </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">__declspec(dllexport) <span class="function"><span class="keyword">void</span> <span class="title">SetProcName</span><span class="params">(LPCTSTR szProcName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	_tcscpy_s(g_szProcName, szProcName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h4 id="DllMain"><a href="#DllMain" class="headerlink" title="DllMain()"></a>DllMain()</h4><p>다음은 DllMain() 함수이다.</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BOOL</span> WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span>            szCurProc[MAX_PATH] = &#123;<span class="number">0</span>,&#125;;</span><br><span class="line">    <span class="keyword">char</span>            *p = <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// #1. 예외처리</span></span><br><span class="line">    <span class="comment">// 현재 프로세스가 HookProc.exe 라면 후킹하지 않고 종료</span></span><br><span class="line">    GetModuleFileNameA(<span class="keyword">NULL</span>, szCurProc, MAX_PATH);</span><br><span class="line">    p = strrchr(szCurProc, <span class="string">'\\'</span>);</span><br><span class="line">    <span class="keyword">if</span>( (p != <span class="keyword">NULL</span>) &amp;&amp; !_stricmp(p+<span class="number">1</span>, <span class="string">"HideProc.exe"</span>) )</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">TRUE</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>( fdwReason )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// #2. API Hooking</span></span><br><span class="line">        <span class="keyword">case</span> DLL_PROCESS_ATTACH : </span><br><span class="line">        hook_by_code(DEF_NTDLL, DEF_ZWQUERYSYSTEMINFORMATION, </span><br><span class="line">                     (PROC)NewZwQuerySystemInformation, g_pOrgBytes);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// #3. API Unhooking </span></span><br><span class="line">        <span class="keyword">case</span> DLL_PROCESS_DETACH :</span><br><span class="line">        unhook_by_code(DEF_NTDLL, DEF_ZWQUERYSYSTEMINFORMATION, </span><br><span class="line">                       g_pOrgBytes);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">TRUE</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>코드를 보면, 문자열 비교를 통해 프로세스 이름이 “HookProc.exe” 인젝터라면 API 후킹하지 않도록 예외 처리를 하는 것을 알 수 있습니다. 그리고 DLL_PROCESS_ATACH 이벤트를 통해 hook_by_code() 함수로 API 후킹을 하고, unhook_by_code() 홤수를 통해 API 후킹을 해제하는 것을 볼 수 있습니다.</p>
<h4 id="hook-by-code"><a href="#hook-by-code" class="headerlink" title="hook_by_code()"></a>hook_by_code()</h4><p>다음은 코드 패치 기법을 이용해서 API 후킹하는 함수입니다. x86비트에서 후킹 하는 방법은 <a href="../15/WindowsAPIHookingUsingCodePatch">Windows API Hooking Code Patch</a> 글을 보면 된다. 현재 여기서는 코드를 살짝 수정해서 x64비트에서 API 후킹을 했습니다.</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">BYTE g_pOrgBytes[<span class="number">14</span>] = &#123; <span class="number">0</span>, &#125;;</span><br><span class="line">BOOL hook_by_code(LPCSTR szDllName, LPCSTR szFuncName, PROC pfnNew, PBYTE pOrgBytes)</span><br><span class="line">&#123;</span><br><span class="line">    FARPROC pfnOrg;</span><br><span class="line">    DWORD dwOldProtect;</span><br><span class="line">    BYTE pBuf1[<span class="number">6</span>] = &#123; <span class="number">0xFF</span>, <span class="number">0x25</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span> &#125;;</span><br><span class="line">    BYTE pBuf2[<span class="number">8</span>] = &#123; <span class="number">0</span>, &#125;;</span><br><span class="line">    PBYTE pByte;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 후킹 대상 API 주소를 구한다</span></span><br><span class="line">    pfnOrg = (FARPROC)GetProcAddress(GetModuleHandleA(szDllName), szFuncName);</span><br><span class="line">    pByte = (PBYTE)pfnOrg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 만약 후킹되어 있다면 return FALSE</span></span><br><span class="line">    if (pByte[<span class="number">0</span>] == <span class="number">0xFF</span> &amp;&amp; pByte[<span class="number">1</span>] == <span class="number">0x25</span>)</span><br><span class="line">        return <span class="literal">FALSE</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 기존코드 14바이트 백업 및 후킹 함수 시작 주소 구하기</span></span><br><span class="line">    memcpy(pOrgBytes, pfnOrg, <span class="number">14</span>);</span><br><span class="line">    memcpy(pBuf2, &amp;pfnNew, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 14바이트 패치를 위하여 메모리에 Write 속성 추가</span></span><br><span class="line">    VirtualProtect((LPVOID)pfnOrg, <span class="number">14</span>, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Hook: 14바이트 패치</span></span><br><span class="line">    memcpy(pfnOrg, pBuf1, <span class="number">6</span>);</span><br><span class="line">    memcpy((LPVOID)((DWORD_PTR)pfnOrg + <span class="number">6</span>), pBuf2, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 메모리에 속성 복원</span></span><br><span class="line">    VirtualProtect((LPVOID)pfnOrg, <span class="number">14</span>, dwOldProtect, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line">    return <span class="literal">TRUE</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Code Patch를 통해서 API 후킹할 떄, 32bit 환경에서는 JMP 명령어중 “E9 XXXXXXXX”를 사용 했었으면 되었습니다. 하지만 64bit 환경에서는 32bit 환경보다 가상메모리 공간이 훨씬 더 커지면서 해당 JMP 명령어를 통해서 후킹을 할 수가 없게 되었습니다. (32bit 가상메모리공간 -&gt; 4GB, 64bit 가상메모리공간 -&gt; 16TB)</p>
<p>따라서 새로운 방법을 찾아야 했는데, 그 중 한가지가 JMP 명령어중 <strong>“FF 25 XXXXXXXX”</strong>을 이용해서 패치하는 방식입니다. 이를 이용하면 8Byte 크기의 주소 공간을 이동할 수가 있습니다.</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x00007FFF</span> <span class="number">00000001</span> <span class="string">'FF 25 00000000'</span> <span class="keyword">JMP</span> <span class="built_in">QWORD</span> <span class="built_in">PTR</span> <span class="built_in">ds</span>:[7FFF00000007] # <span class="keyword">JMP</span> <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">RIP</span>+addr0]</span><br><span class="line"><span class="number">0x00007FFF</span> <span class="number">00000007</span> <span class="string">'XXXXXXXX XXXXXXXX'</span> # 후킹 함수 주소</span><br></pre></td></tr></table></figure>

<p>FF25로 시작하는 JMP 명령어는 레지스터 RIP + offset(XXXXXXXX)을 더한 주소로 이동하는 방식입니다. 이를 통해서 RIP+offset(XXXXXXXX) 주소에다가 후킹 함수 주소를 넣음으로써, 후킹 함수로 이동하게 되는 테크닉입니다.</p>
<p>이외에도 여러가지 방법이 존재하는데, 다른 방법은 <a href="../../15/WindowsX64Hooking">WindowsX64Hooking</a> 글을 참고하면 됩니다.</p>
<br>

<h5 id="unhook-by-code"><a href="#unhook-by-code" class="headerlink" title="unhook_by_code()"></a>unhook_by_code()</h5><p>다음은 후킹을 해제하는 unhook_by_code() 함수입니다.</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">BOOL unhook_by_code(LPCSTR szDllName, LPCSTR szFuncName, PBYTE pOrgBytes)</span><br><span class="line">&#123;</span><br><span class="line">    FARPROC pfnOrg;</span><br><span class="line">    DWORD dwOldProtect;</span><br><span class="line">    PBYTE pByte;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// API 주소를 구한다.</span></span><br><span class="line">    pfnOrg = GetProcAddress(GetModuleHandleA(szDllName), szFuncName);</span><br><span class="line">    pByte = (PBYTE)pfnOrg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 만약 이미 언후킹되어 있다면 FALSE</span></span><br><span class="line">    if (pByte[<span class="number">0</span>] != <span class="number">0xFF</span> &amp;&amp; pByte[<span class="number">1</span>] != <span class="number">0x25</span>)</span><br><span class="line">        return <span class="literal">FALSE</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 기존 코드 14바이트를 덮어쓰기 위헤 메모리에 WRITE 속성 추가</span></span><br><span class="line">    VirtualProtect((LPVOID)pfnOrg, <span class="number">14</span>, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// unHook: 14바이트 패치</span></span><br><span class="line">    memcpy(pfnOrg, pOrgBytes, <span class="number">14</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 메모리 속성 복원</span></span><br><span class="line">    VirtualProtect((LPVOID)pfnOrg, <span class="number">14</span>, dwOldProtect, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line">    return <span class="literal">TRUE</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>언훅의 동작 원리는 원래 코드의 14바이트를 복원을 하는 것입니다.</p>
<br>

<h4 id="NewZwQuerySystemInformation"><a href="#NewZwQuerySystemInformation" class="headerlink" title="NewZwQuerySystemInformation()"></a>NewZwQuerySystemInformation()</h4><p>다음은 후킹 함수 NewZwQuerySystemInformation() 입니다. 해당 함수의 동작원리를 알기 위해서는 ntdll.ZwQuerySystemInformation() API에 대해 먼저 알아야 합니다.</p>
<figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS WINAPI ZwQuerySystemInformation(</span><br><span class="line">  <span class="variable">_In_</span>      SYSTEM_INFORMATION_CLASS SystemInformationClass,</span><br><span class="line">  <span class="variable">_Inout_</span>   PVOID                    SystemInformation,</span><br><span class="line">  <span class="variable">_In_</span>      ULONG                    SystemInformationLength,</span><br><span class="line">  <span class="variable">_Out_opt_</span> PULONG                   ReturnLength</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>ntdll.ZwQuerySystemInformation() 은 지정된 시스템 정보를 검색하는데 사용하는 API 라고 합니다. 근데 Windows 8부터는 사용할 수 없다고 합니다. 하지만 Windows 10 64bit에서도 사용이 가능했습니다. 그 이유는 …? 새롭게 Windows 10 64bit에서 사용할 수 있게 하고 MSDN을 업데이트 하지 않은 것인가?</p>
<p>그리고 ntdll.ZwQuerySystemInformation() API의 MSDN 보다 ntdll.NtQuerySystemInformation() API의 MSDN에 내용이 더 자세합니다. 따라서 해당 함수를 이용할 때,<br><a href="https://docs.microsoft.com/en-us/windows/win32/api/winternl/nf-winternl-ntquerysysteminformation" target="_blank" rel="noopener">NtQuerySystemInformation - MSDN</a>글 또한 참고하는 것이 좋은 것 같습니다.</p>
<p>Nt와 Zw의 차이점을 검색을 해보니 둘다 똑같은 커널 모드에서 동작하도록 설계된 루틴들의 집합체라고 합니다. 시스템콜, 즉 커널함수 라고 볼 수 있습니다. 예를 들어, CreateFile()을 호출을 하면, NtCreateFile() 또는 ZwCreateFile()을 내부적으로 호출을 하는 것입니다.</p>
<p>이러한 Native Service API들은 거의 동일한 동작을 수행한다고 합니다. 하지만, 커널 모드에서 파라미터들을 다루는 방식이 다르다고 합니다. 커널 모드에서 Zw루틴이 호출되면, 파라미터들이 이미 검증된 파라미터라고 생각하고 파라미터 검증과정을 건더뛰고 수행된다고 합니따 반면에 Nt루틴이 호출되면, 유저모드이건 커널모드이건 Nt루틴 내부적으로 파리미터를 검증한느 과정을 거치고 호출이 되는 방식이라고 합니다.</p>
<p>참고한 부분은 <a href="https://sone.tistory.com/235" target="_blank" rel="noopener">참고 자료</a>에도 링크를 걸었습니다. 다음은 함수 파라미터에 대한 설명입니다.</p>
<ul>
<li>SystemInformationClass</li>
</ul>
<p>검색 할 시스템 정보의 종류를 나타내는 SYSTEM_INFORMATION_CLASS에 열겨된 값중 하나를 지정합니다. SystemBasicInformation, SystemCodeIntegrityInformation, SystemProcessInformation 등 여러가지가 있다. 더 자세한 사항은 MSDN을 참고 하면 됩니다.</p>
<p>여기서 사용할 값은 <strong>SystmeProcessInformation</strong> 입니다. 해당 값을 지정하면, 시스템에서 실행중인 각 프로세스마다 하나씩 <strong>SYSTEM_PROCESS_INFORMATION 구조체 배열을 리턴</strong>합니다. 해당 구조체에는 프로세스에 사용된 스레드 및 핸들 수,  peak 페이지 파일 사용량 및 프로세스가 할당 한 메모리 페이지 수를 포함하여 각 <strong>프로세스의 자원 사용량에 대한 정보</strong>가 포함된다고 합니다.</p>
<ul>
<li>SystemInformation</li>
</ul>
<p>요청된 정보를 받는 버퍼에 대한 포인터를 지정합니다. 해당 파라미터는 SystemInformationClass 파라미터에서 어떤 시스템 종류를 나타낼지 선택한 거에 따라서 달라집니다. </p>
<p>SystemProcessInformation을 선택했다면, 해당 파리미터는 각각의 프로세스를 위한 프로세스 정보를 가지고 있는 SYSTEM_PROCESS_INFORMATION 구조체를 가지고 있다고 합니다. 또한 SYSTEM_THREAD_INFORMATION 구조체 메모리로 이어질 수 있다고 합니다. 즉, 프로세스 정보 뿐만 아니라 쓰레드 정보 뿐만 얻을 수 있습니다.</p>
<p>그리고, SystemInformation 파라미터가 가라키는 버퍼가 실행중인 프로세스 및 스레드 만큼 많은 SYSTEM_PROCESS_INFORMATION 및 SYSTEM_THREAD_INFORMATION 구조체를 포함하는 배열을 보유할 수 있을 정도로 커야한다는 점에서 SystemInformation 파라미터에 SYSTEM_PROCESS_INFORMATION 구조체가 배열처럼 쭈욱 기다랗게 연결되어 있다는 것을 알 수 있습니다.</p>
<p>ZwQuerySystemInformation 과 NtQuerySystemInformation에서의 SYSTEM_PROCESS_INFORMATION의 레이아웃이 다르므로 MSDN을 참고하셔야 합니다. ZwQuerySystemInformation의 SYSTEM_PROCESS_INFORMATION 은 다음과 같습니다.</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _SYSTEM_PROCESS_INFORMATION &#123;</span><br><span class="line">    <span class="type">ULONG</span> <span class="type">NextEntryOffset</span>;</span><br><span class="line">    <span class="type">ULONG</span> <span class="type">NumberOfThreads</span>;</span><br><span class="line">    <span class="type">BYTE</span> <span class="type">Reserved1</span>[48];</span><br><span class="line">    <span class="type">PVOID</span> <span class="type">Reserved2</span>[3];</span><br><span class="line">    <span class="type">HANDLE</span> <span class="type">UniqueProcessId</span>;</span><br><span class="line">    <span class="type">PVOID</span> <span class="type">Reserved3</span>;</span><br><span class="line">    <span class="type">ULONG</span> <span class="type">HandleCount</span>;</span><br><span class="line">    <span class="type">BYTE</span> <span class="type">Reserved4</span>[4];</span><br><span class="line">    <span class="type">PVOID</span> <span class="type">Reserved5</span>[11];</span><br><span class="line">    <span class="type">SIZE_T</span> <span class="type">PeakPagefileUsage</span>;</span><br><span class="line">    <span class="type">SIZE_T</span> <span class="type">PrivatePageCount</span>;</span><br><span class="line">    <span class="type">LARGE_INTEGER</span> <span class="type">Reserved6</span>[6];</span><br><span class="line">&#125; <span class="type">SYSTEM_PROCESS_INFORMATION</span>, *<span class="type">PSYSTEM_PROCESS_INFORMATION</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>SystemInformationLength</li>
</ul>
<p>해당 파라미터는 SystemInformation 파라미터가 가리키는 버퍼 크기를 지정하면 됩니다.</p>
<ul>
<li>ReturnLength</li>
</ul>
<p>요정된 정보의 실제 크기를 반환 받고 싶을 때, 선택적으로 사용하는 파라미터입니다. 반환 값이 SystemInformationLength 파라미터 보다 작거나 같은 경우, 데이터를 SystemInformation 버퍼에 복사를 하고, 그렇지 않을 경우 NTSTATUS 오류 코드를 반환하고 요청된 데이터를 받는데 필요한 크기를 ReturnLength에 반환을 한다고 합니다.</p>
<br>

<p>즉, 책에서 설명했던 것처럼 ZwQuerySystemInformation() API를 호출할 때, SystemInformationClass 파라미터를 SystemProcessInformation(enum 값 : 5) 과 SystemInformationLength 파라미터에 충분한 크기를 입력하면, SystemInformation[inout] 파라미터에 SYSTEM_PROCESS_INFORMATION 구조체 싱글 링크드 리스트의 시작 주소가 저장된다는 것이 이해가 됩니다. 근데 해당 구조체내의 다음 구조체를 가리키는 값이 포인터가 아니고 NextEntryOffset 더해서 다음 구조체를 가리키는 것을 보아 연결 리스트가 아니라 배열 형태로 이루어진게 아닐까 생각이 듭니다. 배열 형태로 이루어진 것을 연결 리스트로 구현한 것처럼 다루는 느낌이 들었다. 그리고 해당 구조체 연결 리스트에 실행 중인 모든 프로세스의 정보가 담겨 있다는 것도 이해가 됩니다.</p>
<p>그래서 은폐하고 싶은 프로세스에 해당 하는 리스트 멤버를 찾아서 연결을 끊어버리면, 해당 항목이 유실되어있기 때문에 프로세스 검색 유틸리티가 CreateToolhelp32Snapshot() 또는 EnumProcesses() API를 통해서 은폐 프로세스에 대한 정보를 검색할 수 없게 되어서 자기 자신을 숨길 수 있게 되는 것입니다.</p>
<p>다음은 NewZwQuerySystemInformation() 소스 코드입니다.</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS WINAPI NewZwQuerySystemInformation(</span><br><span class="line">    SYSTEM_INFORMATION_CLASS SystemInformationClass,</span><br><span class="line">    PVOID SystemInformation,</span><br><span class="line">    <span class="keyword">ULONG</span> SystemInformationLength,</span><br><span class="line">    PULONG ReturnLength)</span><br><span class="line">&#123;</span><br><span class="line">    NTSTATUS status;</span><br><span class="line">    FARPROC pFunc;</span><br><span class="line">    PSYSTEM_PROCESS_INFORMATION pCur, pPrev = &#123; <span class="number">0</span>, &#125;;</span><br><span class="line">    <span class="keyword">char</span> szProcName[MAX_PATH] = &#123; <span class="number">0</span>, &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 작업 전에 unhook</span></span><br><span class="line">    unhook_by_code(DEF_NTDLL, DEF_ZWQUERYSYSTEMINFORMATION, g_pOrgBytes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// original API 호출</span></span><br><span class="line">    pFunc = GetProcAddress(GetModuleHandleA(DEF_NTDLL),</span><br><span class="line">        DEF_ZWQUERYSYSTEMINFORMATION);</span><br><span class="line">    status = ((PFZWQUERYSYSTEMINFORMATION)pFunc)</span><br><span class="line">        (SystemInformationClass, SystemInformation,</span><br><span class="line">            SystemInformationLength, ReturnLength);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (status != STATUS_SUCCESS)</span><br><span class="line">        <span class="keyword">goto</span> __NTQUERYSYSTEMINFORMATION_END;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// SystemProcessInformation 인 경우만 작업함</span></span><br><span class="line">    <span class="keyword">if</span> (SystemInformationClass == SystemProcessInformation)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// SYSTEM_PROCESS_INFORMATION 타입 캐스팅</span></span><br><span class="line">        <span class="comment">// pCur 는 single linked list 의 head</span></span><br><span class="line">        pCur = (PSYSTEM_PROCESS_INFORMATION)SystemInformation;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">TRUE</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 프로세스 이름 비교</span></span><br><span class="line">            <span class="comment">// g_szProcName = 은폐하려는 프로세스 이름</span></span><br><span class="line">            <span class="comment">// (=&gt; SetProcName() 에서 세팅됨)</span></span><br><span class="line">            <span class="keyword">if</span> (pCur-&gt;Reserved2[<span class="number">1</span>] != <span class="keyword">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!_tcsicmp((PWSTR)pCur-&gt;Reserved2[<span class="number">1</span>], g_szProcName))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 연결 리스트에서 은폐 프로세스 제거</span></span><br><span class="line">                    <span class="keyword">if</span> (pCur-&gt;NextEntryOffset == <span class="number">0</span>)</span><br><span class="line">                        pPrev-&gt;NextEntryOffset = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        pPrev-&gt;NextEntryOffset += pCur-&gt;NextEntryOffset;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    pPrev = pCur;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (pCur-&gt;NextEntryOffset == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 연결 리스트의 다음 항목</span></span><br><span class="line">            pCur = (PSYSTEM_PROCESS_INFORMATION)</span><br><span class="line">                ((DWORD_PTR)pCur + pCur-&gt;NextEntryOffset);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">__NTQUERYSYSTEMINFORMATION_END:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 함수 종료 전에 다시 API Hooking</span></span><br><span class="line">    hook_by_code(DEF_NTDLL, DEF_ZWQUERYSYSTEMINFORMATION,</span><br><span class="line">        (PROC)NewZwQuerySystemInformation, g_pOrgBytes);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>후킹 함수 NewZwQuerySystemInformation()의 로직은 주석 처리가 되있어서 알아보기 쉽게 되어 있습니다. 또한 자료구조 연결 리스트를 구현해본 경험이 있다면, 그렇게 어렵지 않은 코드인 것 같습니다.</p>
<p>먼저, 언훅을 통해서 원본 ZwQuerySystemInformation() API로 돌려놓고, 해당 API를 호출을 합니다. 호출을 통해서 얻은 SystemProcessInformation 구조체를 연결 리스트 형식으로 검사하면서 은폐 시키고 싶은 프로세스 이름을 찾습니다. 찾았다면 SystemProcessInformation 구조체 연결을 끊어버립니다. 그리고 나서 후킹을 다시 걸고 status(NTSTATUS) 값을 반환해주면 됩니다. </p>
<br>

<h4 id="Stealth-cpp-소스코드"><a href="#Stealth-cpp-소스코드" class="headerlink" title="Stealth.cpp 소스코드"></a>Stealth.cpp 소스코드</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"windows.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"tchar.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STATUS_SUCCESS                      (0x00000000L) </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> LONG NTSTATUS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> _SYSTEM_INFORMATION_CLASS &#123;</span><br><span class="line">    SystemBasicInformation = <span class="number">0</span>,</span><br><span class="line">    SystemPerformanceInformation = <span class="number">2</span>,</span><br><span class="line">    SystemTimeOfDayInformation = <span class="number">3</span>,</span><br><span class="line">    SystemProcessInformation = <span class="number">5</span>,</span><br><span class="line">    SystemProcessorPerformanceInformation = <span class="number">8</span>,</span><br><span class="line">    SystemInterruptInformation = <span class="number">23</span>,</span><br><span class="line">    SystemExceptionInformation = <span class="number">33</span>,</span><br><span class="line">    SystemRegistryQuotaInformation = <span class="number">37</span>,</span><br><span class="line">    SystemLookasideInformation = <span class="number">45</span></span><br><span class="line">&#125; SYSTEM_INFORMATION_CLASS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SYSTEM_PROCESS_INFORMATION</span> &#123;</span></span><br><span class="line">    ULONG NextEntryOffset;</span><br><span class="line">    ULONG NumberOfThreads;</span><br><span class="line">    BYTE Reserved1[<span class="number">48</span>];</span><br><span class="line">    PVOID Reserved2[<span class="number">3</span>];</span><br><span class="line">    HANDLE UniqueProcessId;</span><br><span class="line">    PVOID Reserved3;</span><br><span class="line">    ULONG HandleCount;</span><br><span class="line">    BYTE Reserved4[<span class="number">4</span>];</span><br><span class="line">    PVOID Reserved5[<span class="number">11</span>];</span><br><span class="line">    SIZE_T PeakPagefileUsage;</span><br><span class="line">    SIZE_T PrivatePageCount;</span><br><span class="line">    LARGE_INTEGER Reserved6[<span class="number">6</span>];</span><br><span class="line">&#125; SYSTEM_PROCESS_INFORMATION, * PSYSTEM_PROCESS_INFORMATION;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NTSTATUS</span><span class="params">(WINAPI* PFZWQUERYSYSTEMINFORMATION)</span></span></span><br><span class="line"><span class="function"><span class="params">(SYSTEM_INFORMATION_CLASS SystemInformationClass,</span></span></span><br><span class="line"><span class="function"><span class="params">    PVOID SystemInformation,</span></span></span><br><span class="line"><span class="function"><span class="params">    ULONG SystemInformationLength,</span></span></span><br><span class="line"><span class="function"><span class="params">    PULONG ReturnLength)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEF_NTDLL                       (<span class="meta-string">"ntdll.dll"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEF_ZWQUERYSYSTEMINFORMATION    (<span class="meta-string">"ZwQuerySystemInformation"</span>)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// global variable (in sharing memory)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(linker, <span class="meta-string">"/SECTION:.SHARE,RWS"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> data_seg(<span class="meta-string">".SHARE"</span>)</span></span><br><span class="line">TCHAR g_szProcName[MAX_PATH] = &#123; <span class="number">0</span>, &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> data_seg()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// global variable</span></span><br><span class="line">BYTE g_pOrgBytes[<span class="number">14</span>] = &#123; <span class="number">0</span>, &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">hook_by_code</span><span class="params">(LPCSTR szDllName, LPCSTR szFuncName, PROC pfnNew, PBYTE pOrgBytes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FARPROC pfnOrg;</span><br><span class="line">    DWORD dwOldProtect;</span><br><span class="line">    BYTE pBuf1[<span class="number">6</span>] = &#123; <span class="number">0xFF</span>, <span class="number">0x25</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span> &#125;;</span><br><span class="line">    BYTE pBuf2[<span class="number">8</span>] = &#123; <span class="number">0</span>, &#125;;</span><br><span class="line">    PBYTE pByte;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 후킹 대상 API 주소를 구한다</span></span><br><span class="line">    pfnOrg = (FARPROC)GetProcAddress(GetModuleHandleA(szDllName), szFuncName);</span><br><span class="line">    pByte = (PBYTE)pfnOrg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 만약 후킹되어 있다면 return FALSE</span></span><br><span class="line">    <span class="keyword">if</span> (pByte[<span class="number">0</span>] == <span class="number">0xFF</span> &amp;&amp; pByte[<span class="number">1</span>] == <span class="number">0x25</span>)</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 기존코드 14바이트 백업 및 후킹 함수 시작 주소 구하기</span></span><br><span class="line">    <span class="built_in">memcpy</span>(pOrgBytes, pfnOrg, <span class="number">14</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(pBuf2, &amp;pfnNew, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 14바이트 패치를 위하여 메모리에 Write 속성 추가</span></span><br><span class="line">    VirtualProtect((LPVOID)pfnOrg, <span class="number">14</span>, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Hook: 14바이트 패치</span></span><br><span class="line">    <span class="built_in">memcpy</span>(pfnOrg, pBuf1, <span class="number">6</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>((LPVOID)((DWORD_PTR)pfnOrg + <span class="number">6</span>), pBuf2, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 메모리에 속성 복원</span></span><br><span class="line">    VirtualProtect((LPVOID)pfnOrg, <span class="number">14</span>, dwOldProtect, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">unhook_by_code</span><span class="params">(LPCSTR szDllName, LPCSTR szFuncName, PBYTE pOrgBytes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FARPROC pfnOrg;</span><br><span class="line">    DWORD dwOldProtect;</span><br><span class="line">    PBYTE pByte;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// API 주소를 구한다.</span></span><br><span class="line">    pfnOrg = GetProcAddress(GetModuleHandleA(szDllName), szFuncName);</span><br><span class="line">    pByte = (PBYTE)pfnOrg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 만약 이미 언후킹되어 있다면 FALSE</span></span><br><span class="line">    <span class="keyword">if</span> (pByte[<span class="number">0</span>] != <span class="number">0xFF</span> &amp;&amp; pByte[<span class="number">1</span>] != <span class="number">0x25</span>)</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 기존 코드 14바이트를 덮어쓰기 위헤 메모리에 WRITE 속성 추가</span></span><br><span class="line">    VirtualProtect((LPVOID)pfnOrg, <span class="number">14</span>, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// unHook: 14바이트 패치</span></span><br><span class="line">    <span class="built_in">memcpy</span>(pfnOrg, pOrgBytes, <span class="number">14</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 메모리 속성 복원</span></span><br><span class="line">    VirtualProtect((LPVOID)pfnOrg, <span class="number">14</span>, dwOldProtect, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS WINAPI <span class="title">NewZwQuerySystemInformation</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    SYSTEM_INFORMATION_CLASS SystemInformationClass,</span></span></span><br><span class="line"><span class="function"><span class="params">    PVOID SystemInformation,</span></span></span><br><span class="line"><span class="function"><span class="params">    ULONG SystemInformationLength,</span></span></span><br><span class="line"><span class="function"><span class="params">    PULONG ReturnLength)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NTSTATUS status;</span><br><span class="line">    FARPROC pFunc;</span><br><span class="line">    PSYSTEM_PROCESS_INFORMATION pCur, pPrev = &#123; <span class="number">0</span>, &#125;;</span><br><span class="line">    <span class="keyword">char</span> szProcName[MAX_PATH] = &#123; <span class="number">0</span>, &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 작업 전에 unhook</span></span><br><span class="line">    unhook_by_code(DEF_NTDLL, DEF_ZWQUERYSYSTEMINFORMATION, g_pOrgBytes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// original API 호출</span></span><br><span class="line">    pFunc = GetProcAddress(GetModuleHandleA(DEF_NTDLL),</span><br><span class="line">        DEF_ZWQUERYSYSTEMINFORMATION);</span><br><span class="line">    status = ((PFZWQUERYSYSTEMINFORMATION)pFunc)</span><br><span class="line">        (SystemInformationClass, SystemInformation,</span><br><span class="line">            SystemInformationLength, ReturnLength);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (status != STATUS_SUCCESS)</span><br><span class="line">        <span class="keyword">goto</span> __NTQUERYSYSTEMINFORMATION_END;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// SystemProcessInformation 인 경우만 작업함</span></span><br><span class="line">    <span class="keyword">if</span> (SystemInformationClass == SystemProcessInformation)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// SYSTEM_PROCESS_INFORMATION 타입 캐스팅</span></span><br><span class="line">        <span class="comment">// pCur 는 single linked list 의 head</span></span><br><span class="line">        pCur = (PSYSTEM_PROCESS_INFORMATION)SystemInformation;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (TRUE)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 프로세스 이름 비교</span></span><br><span class="line">            <span class="comment">// g_szProcName = 은폐하려는 프로세스 이름</span></span><br><span class="line">            <span class="comment">// (=&gt; SetProcName() 에서 세팅됨)</span></span><br><span class="line">            <span class="keyword">if</span> (pCur-&gt;Reserved2[<span class="number">1</span>] != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!_tcsicmp((PWSTR)pCur-&gt;Reserved2[<span class="number">1</span>], g_szProcName))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 연결 리스트에서 은폐 프로세스 제거</span></span><br><span class="line">                    <span class="keyword">if</span> (pCur-&gt;NextEntryOffset == <span class="number">0</span>)</span><br><span class="line">                        pPrev-&gt;NextEntryOffset = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        pPrev-&gt;NextEntryOffset += pCur-&gt;NextEntryOffset;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    pPrev = pCur;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (pCur-&gt;NextEntryOffset == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 연결 리스트의 다음 항목</span></span><br><span class="line">            pCur = (PSYSTEM_PROCESS_INFORMATION)</span><br><span class="line">                ((DWORD_PTR)pCur + pCur-&gt;NextEntryOffset);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">__NTQUERYSYSTEMINFORMATION_END:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 함수 종료 전에 다시 API Hooking</span></span><br><span class="line">    hook_by_code(DEF_NTDLL, DEF_ZWQUERYSYSTEMINFORMATION,</span><br><span class="line">        (PROC)NewZwQuerySystemInformation, g_pOrgBytes);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL WINAPI <span class="title">DllMain</span><span class="params">(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>            szCurProc[MAX_PATH] = &#123; <span class="number">0</span>, &#125;;</span><br><span class="line">    <span class="keyword">char</span>* p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// #1. 예외처리</span></span><br><span class="line">    <span class="comment">// 현재 프로세스가 HookProc.exe 라면 후킹하지 않고 종료</span></span><br><span class="line">    GetModuleFileNameA(<span class="literal">NULL</span>, szCurProc, MAX_PATH);</span><br><span class="line">    p = <span class="built_in">strrchr</span>(szCurProc, <span class="string">'\\'</span>);</span><br><span class="line">    <span class="keyword">if</span> ((p != <span class="literal">NULL</span>) &amp;&amp; !_stricmp(p + <span class="number">1</span>, <span class="string">"HideProc.exe"</span>))</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (fdwReason)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// #2. API Hooking</span></span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">        hook_by_code(DEF_NTDLL, DEF_ZWQUERYSYSTEMINFORMATION,</span><br><span class="line">            (PROC)NewZwQuerySystemInformation, g_pOrgBytes);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// #3. API Unhooking </span></span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">        unhook_by_code(DEF_NTDLL, DEF_ZWQUERYSYSTEMINFORMATION,</span><br><span class="line">            g_pOrgBytes);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    __declspec(dllexport) <span class="function"><span class="keyword">void</span> <span class="title">SetProcName</span><span class="params">(LPCTSTR szProcName)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _tcscpy_s(g_szProcName, szProcName);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<br>

<h2 id="실행-결과"><a href="#실행-결과" class="headerlink" title="실행 결과"></a>실행 결과</h2><img src="/2020/01/16/WindowsAPIHookingStealthProcess-1/1.png" title="후킹1">

<img src="/2020/01/16/WindowsAPIHookingStealthProcess-1/2.png" title="후킹2">

<br>

<h2 id="마지막으로"><a href="#마지막으로" class="headerlink" title="마지막으로.."></a>마지막으로..</h2><p>여기까지가 코드 패치를 통한 스텔스 프로세스를 구현하는 기법에 대한 내용이었습니다. 다음번 포스팅에서는 글로벙 API 후킹을 통해서 앞서 언급했던 문제점을 해결할 것입니다.</p>
<br>

<h2 id="참고자료"><a href="#참고자료" class="headerlink" title="참고자료"></a>참고자료</h2><p><a href="https://docs.microsoft.com/en-us/windows/win32/api/tlhelp32/nf-tlhelp32-createtoolhelp32snapshot" target="_blank" rel="noopener">CreateToolhelp32Snapshot()</a></p>
<p><a href="https://docs.microsoft.com/ko-kr/windows/win32/psapi/enumerating-all-processes?redirectedfrom=MSDN" target="_blank" rel="noopener">EnumProcesses()</a></p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject</a>]</p>
<p><a href="https://blueskywithyou.tistory.com/48" target="_blank" rel="noopener">extern “C”</a></p>
<p><a href="https://sone.tistory.com/235" target="_blank" rel="noopener">Nt와 Zw Native Routine의 차이점</a></p>
<p><a href="https://jeep-shoes.tistory.com/66" target="_blank" rel="noopener">Nt/Zw Native API의 차이점</a></p>

    </div>

    
    
    
        
      

      <footer class="post-footer">
          
            
          
          <div class="post-tags">
            
              <a href="/tags/Windows/" rel="tag"># Windows</a>
            
              <a href="/tags/Windows-Reversing/" rel="tag"># Windows Reversing</a>
            
          </div>
        

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
                <a href="/2020/01/15/WindowsX64Hooking/" rel="next" title="WindowsX64Hooking">
                  <i class="fa fa-chevron-left"></i> WindowsX64Hooking
                </a>
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
                <a href="/2020/01/16/ProcessSearch/" rel="prev" title="ProcessSearch">
                  ProcessSearch <i class="fa fa-chevron-right"></i>
                </a>
              
            </div>
          </div>
        
      </footer>
    
  </div>
  
  
  
  </article>

  </div>


          </div>
          
    
    
  <div class="comments" id="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  
  

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">
        
        
        
        
      

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#들어가기에-앞서"><span class="nav-number">1.</span> <span class="nav-text">들어가기에 앞서</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#스텔스-프로세스"><span class="nav-number">2.</span> <span class="nav-text">스텔스 프로세스</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#해당-기법의-문제점"><span class="nav-number">3.</span> <span class="nav-text">해당 기법의 문제점</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#분석"><span class="nav-number">4.</span> <span class="nav-text">분석</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HideProc-exe-gt-HookProc-cpp"><span class="nav-number">4.1.</span> <span class="nav-text">HideProc.exe -&gt; HookProc.cpp</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#전체-소스-코드"><span class="nav-number">4.2.</span> <span class="nav-text">전체 소스 코드</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Stealth-dll-gt-stealth-cpp"><span class="nav-number">4.3.</span> <span class="nav-text">Stealth.dll -&gt; stealth.cpp</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SetProcName"><span class="nav-number">4.3.1.</span> <span class="nav-text">SetProcName()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DllMain"><span class="nav-number">4.3.2.</span> <span class="nav-text">DllMain()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#hook-by-code"><span class="nav-number">4.3.3.</span> <span class="nav-text">hook_by_code()</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#unhook-by-code"><span class="nav-number">4.3.3.1.</span> <span class="nav-text">unhook_by_code()</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#NewZwQuerySystemInformation"><span class="nav-number">4.3.4.</span> <span class="nav-text">NewZwQuerySystemInformation()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Stealth-cpp-소스코드"><span class="nav-number">4.3.5.</span> <span class="nav-text">Stealth.cpp 소스코드</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#실행-결과"><span class="nav-number">5.</span> <span class="nav-text">실행 결과</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#마지막으로"><span class="nav-number">6.</span> <span class="nav-text">마지막으로..</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#참고자료"><span class="nav-number">7.</span> <span class="nav-text">참고자료</span></a></li></ol></div>
        
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">777bareman777</p>
  <div class="site-description" itemprop="description"></div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">19</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">categories</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">tags</span>
        </a>
      </div>
    
  </nav>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">777bareman777</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.4.0</div>

        












        
      </div>
    </footer>
  </div>

  


  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.4.0"></script><script src="/js/motion.js?v=7.4.0"></script>
<script src="/js/schemes/muse.js?v=7.4.0"></script>
<script src="/js/next-boot.js?v=7.4.0"></script>



  





















  

  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://777bareman777.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>
<script>
  function disqus_config() {
    this.page.url = "http://777bareman777.github.io/2020/01/16/WindowsAPIHookingStealthProcess-1/";
    this.page.identifier = "2020/01/16/WindowsAPIHookingStealthProcess-1/";
    this.page.title = '스텔스 프로세스, 코드 패치 기법을 이용해서 -1';};
  function loadComments() {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: disqus_config
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://777bareman777.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  }
    window.addEventListener('load', loadComments, false);
  
</script>

</body>
</html>
